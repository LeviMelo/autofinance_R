Project structure for '/c/Users/Galaxy/LEVI/Projetos R/autofinance_R/v2/modules/03_corporate_actions':
===============================================================================
  R/build_registry.R
  R/fetch_dividends_quantmod.R
  R/fetch_splits_quantmod.R
  R/yahoo_symbol_map.R
  R/zzz_depends.R
  README.md



###############################################################################
### FILE: R/build_registry.R
###############################################################################
# v2/modules/03_corporate_actions/R/build_registry.R

af2_ca_cache_file <- function(cfg, tag = "splits_dividends") {
  cache_dir <- file.path(cfg$cache_dir, "corp_actions")
  if (!dir.exists(cache_dir)) dir.create(cache_dir, recursive = TRUE)
  file.path(cache_dir, paste0("corp_actions_", tag, ".rds"))
}

af2_ca_build_registry <- function(symbols,
                                  asset_types = NULL,
                                  cfg = NULL,
                                  from = "2018-01-01",
                                  to = Sys.Date(),
                                  verbose = TRUE,
                                  use_cache = TRUE,
                                  force_refresh = FALSE,
                                  n_workers = 1L) {

  cfg <- cfg %||% af2_get_config()
  symbols <- unique(toupper(trimws(as.character(symbols))))
  symbols <- symbols[!is.na(symbols) & nzchar(symbols)]
  if (!length(symbols)) stop("af2_ca_build_registry: empty symbols.", call. = FALSE)

  tag <- paste0(
    format(as.Date(from), "%Y%m%d"), "_",
    format(as.Date(to), "%Y%m%d"), "_",
    length(symbols)
  )
  cache_file <- af2_ca_cache_file(cfg, tag)

  if (isTRUE(use_cache) && file.exists(cache_file) && !isTRUE(force_refresh)) {
    if (verbose) af2_log("AF2_CA:", "Using cache: ", cache_file)
    return(readRDS(cache_file))
  }

  yahoo_syms <- af2_yahoo_symbol_vec(symbols, asset_types)
  map_dt <- data.table::data.table(
    symbol = symbols,
    yahoo_symbol = yahoo_syms
  )
  map_dt <- map_dt[!is.na(yahoo_symbol)]

  if (!nrow(map_dt)) {
    stop("af2_ca_build_registry: no Yahoo symbols could be mapped.", call. = FALSE)
  }

  if (verbose) {
    af2_log("AF2_CA:", "Fetching corporate actions for ", nrow(map_dt), " symbols (Yahoo).")
  }

  worker_fun <- function(i) {
    sym <- map_dt$symbol[i]
    ysym <- map_dt$yahoo_symbol[i]

    dt_s <- af2_ca_fetch_splits_one(ysym, from = from, to = to, verbose = FALSE)
    dt_d <- af2_ca_fetch_dividends_one(ysym, from = from, to = to, verbose = FALSE)

    out <- data.table::rbindlist(list(dt_s, dt_d), use.names = TRUE, fill = TRUE)
    if (!nrow(out)) return(NULL)

    out[, symbol := sym]
    out[, yahoo_symbol := ysym]

    out
  }

  res_list <- list()

  n_workers <- as.integer(n_workers)
  if (is.na(n_workers) || n_workers < 1L) n_workers <- 1L

  # Windows-safe optional parallel
  if (n_workers > 1L) {
    af2_ca_require("parallel")

    cl <- parallel::makeCluster(n_workers)
    on.exit(try(parallel::stopCluster(cl), silent = TRUE), add = TRUE)

    parallel::clusterExport(
      cl,
      varlist = c(
        "map_dt",
        "from", "to",
        "af2_ca_fetch_splits_one",
        "af2_ca_fetch_dividends_one"
      ),
      envir = environment()
    )
    parallel::clusterEvalQ(cl, {
      library(data.table)
      library(quantmod)
      library(xts)
      library(zoo)
    })

    idx <- seq_len(nrow(map_dt))
    res_list <- parallel::parLapply(cl, idx, worker_fun)

  } else {
    for (i in seq_len(nrow(map_dt))) {
      res_list[[i]] <- worker_fun(i)
      if (verbose && i %% 50 == 0) {
        af2_log("AF2_CA:", "Progress: ", i, "/", nrow(map_dt))
      }
    }
  }

  dt_all <- data.table::rbindlist(res_list, use.names = TRUE, fill = TRUE)

  if (!nrow(dt_all)) {
    # It is valid to have zero actions, but keep schema stable
    dt_all <- data.table::data.table(
      symbol = character(),
      yahoo_symbol = character(),
      refdate = as.Date(character()),
      action_type = character(),
      value = numeric(),
      source = character()
    )
  }

  # Normalize + order
  dt_all[, refdate := as.Date(refdate)]
  dt_all <- dt_all[order(symbol, action_type, refdate)]

  # Basic contract sanity
  req <- c("symbol", "yahoo_symbol", "refdate", "action_type", "value", "source")
  miss <- setdiff(req, names(dt_all))
  if (length(miss)) stop("Corporate actions registry missing cols: ", paste(miss, collapse = ", "))

  if (isTRUE(use_cache)) {
    saveRDS(dt_all, cache_file)
    if (verbose) af2_log("AF2_CA:", "Wrote cache: ", cache_file)
  }

  dt_all
}



###############################################################################
### FILE: R/fetch_dividends_quantmod.R
###############################################################################
# v2/modules/03_corporate_actions/R/fetch_dividends_quantmod.R

af2_ca_fetch_dividends_one <- function(yahoo_symbol,
                                       from = "2018-01-01",
                                       to = Sys.Date(),
                                       verbose = FALSE,
                                       split.adjust = TRUE) {
  if (is.na(yahoo_symbol) || !nzchar(yahoo_symbol)) return(NULL)

  x <- tryCatch(
    quantmod::getDividends(
      yahoo_symbol,
      from = from,
      to = to,
      auto.assign = FALSE,
      verbose = verbose,
      split.adjust = split.adjust
    ),
    error = function(e) {
      if (verbose) af2_log("AF2_CA:", "getDividends failed for ", yahoo_symbol, ": ", conditionMessage(e))
      NULL
    }
  )

  if (is.null(x)) return(NULL)
  if (!inherits(x, "xts")) return(NULL)
  if (NROW(x) == 0) return(NULL)

  dt <- data.table::data.table(
    yahoo_symbol = yahoo_symbol,
    refdate = as.Date(zoo::index(x)),
    action_type = "dividend",
    value = as.numeric(zoo::coredata(x)),
    source = "yahoo"
  )

  dt[is.finite(value) & value != 0 & !is.na(refdate)]
}


###############################################################################
### FILE: R/fetch_splits_quantmod.R
###############################################################################
# v2/modules/03_corporate_actions/R/fetch_splits_quantmod.R

af2_ca_fetch_splits_one <- function(yahoo_symbol,
                                    from = "2018-01-01",
                                    to = Sys.Date(),
                                    verbose = FALSE) {
  if (is.na(yahoo_symbol) || !nzchar(yahoo_symbol)) return(NULL)

  x <- tryCatch(
    quantmod::getSplits(
      yahoo_symbol,
      from = from,
      to = to,
      auto.assign = FALSE,
      verbose = verbose
    ),
    error = function(e) {
      if (verbose) af2_log("AF2_CA:", "getSplits failed for ", yahoo_symbol, ": ", conditionMessage(e))
      NULL
    }
  )

  # quantmod returns NA if no split data
  if (is.null(x)) return(NULL)
  if (length(x) == 1 && is.na(as.numeric(x))) return(NULL)
  if (!inherits(x, "xts")) return(NULL)

  # xts index = date, coredata = ratio
  dt <- data.table::data.table(
    yahoo_symbol = yahoo_symbol,
    refdate = as.Date(zoo::index(x)),
    action_type = "split",
    value = as.numeric(zoo::coredata(x)),
    source = "yahoo"
  )

  dt[is.finite(value) & !is.na(refdate)]
}


###############################################################################
### FILE: R/yahoo_symbol_map.R
###############################################################################
# v2/modules/03_corporate_actions/R/yahoo_symbol_map.R

af2_yahoo_symbol <- function(symbol, asset_type = NULL) {
  s <- toupper(trimws(as.character(symbol)))
  if (is.na(s) || !nzchar(s)) return(NA_character_)

  # If user already passed a Yahoo-style symbol, respect it
  if (grepl("\\.", s)) return(s)

  # Most B3 assets on Yahoo use .SA
  # This covers equities, FIIs, ETFs, many BDRs.
  paste0(s, ".SA")
}

af2_yahoo_symbol_vec <- function(symbols, asset_types = NULL) {
  if (is.null(asset_types)) {
    vapply(symbols, af2_yahoo_symbol, character(1))
  } else {
    mapply(af2_yahoo_symbol, symbols, asset_types, USE.NAMES = FALSE)
  }
}


###############################################################################
### FILE: R/zzz_depends.R
###############################################################################
# v2/modules/03_corporate_actions/R/zzz_depends.R

if (!exists("af2_get_config")) {
  stop("af2_get_config not found. Source v2/modules/00_core/R/config.R first.")
}
if (!exists("af2_log")) {
  stop("af2_log not found. Source v2/modules/00_core/R/logging.R first.")
}
if (!exists("%||%")) {
  stop("%||% not found. Source v2/modules/00_core/R/utils.R first.")
}

af2_ca_require <- function(pkgs) {
  for (p in pkgs) {
    if (!requireNamespace(p, quietly = TRUE)) {
      stop("Missing package for corporate actions module: ", p, call. = FALSE)
    }
  }
  invisible(TRUE)
}

# quantmod is the key dependency here
af2_ca_require(c("data.table", "quantmod", "xts"))

suppressPackageStartupMessages({
  library(data.table)
  library(quantmod)
  library(xts)
})



###############################################################################
### FILE: README.md
###############################################################################
# Module

Purpose:
- Define INPUT contract
- Define OUTPUT contract
- List functions
- List tests



