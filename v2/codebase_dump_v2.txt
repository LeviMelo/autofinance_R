Project structure for '/c/Users/Galaxy/LEVI/Projetos R/autofinance_R/v2':
===============================================================================
  contracts/adjustments.md
  contracts/panel_adj.md
  contracts/screener_input.md
  contracts/screener_output.md
  contracts/universe_raw.md
  modules/00_core/R/config.R
  modules/00_core/R/logging.R
  modules/00_core/R/utils.R
  modules/00_core/README.md
  modules/01_b3_universe/R/build_universe.R
  modules/01_b3_universe/R/fetch_daily.R
  modules/01_b3_universe/R/fetch_yearly.R
  modules/01_b3_universe/R/filter_by_type_rb3.R
  modules/01_b3_universe/R/rb3_init.R
  modules/01_b3_universe/R/select_min_cols.R
  modules/01_b3_universe/R/unify_liquidity.R
  modules/01_b3_universe/R/validate_types.R
  modules/01_b3_universe/R/zzz_depends.R
  modules/01_b3_universe/README.md
  modules/02_diagnostics/README.md
  modules/03_corporate_actions/codebase_dump_03_corporate_actions.txt
  modules/03_corporate_actions/R/build_registry.R
  modules/03_corporate_actions/R/fetch_dividends_quantmod.R
  modules/03_corporate_actions/R/fetch_splits_quantmod.R
  modules/03_corporate_actions/R/select_candidates.R
  modules/03_corporate_actions/R/yahoo_retry.R
  modules/03_corporate_actions/R/yahoo_symbol_map.R
  modules/03_corporate_actions/R/zzz_depends.R
  modules/03_corporate_actions/README.md
  modules/04_adjuster/R/apply_adjustments.R
  modules/04_adjuster/R/build_adjustments.R
  modules/04_adjuster/R/build_panel_adj.R
  modules/04_adjuster/R/build_panel_adj_selective.R
  modules/04_adjuster/R/validate_panel_adj.R
  modules/04_adjuster/R/zzz_depends.R
  modules/04_adjuster/README.md
  modules/05_screener/R/compute_metrics.R
  modules/05_screener/R/liquidity_filter.R
  modules/05_screener/R/run_screener.R
  modules/05_screener/R/score_rank.R
  modules/05_screener/R/screener_config.R
  modules/05_screener/R/validate_screener_input.R
  modules/05_screener/README.md
  README.md
  scripts/00_bootstrap_v2.R
  scripts/00_load_module_05.R
  scripts/00_make_fixtures.R
  scripts/01a_smoke_b3_fetch_one_year.R
  scripts/01b_build_universe_small_window.R
  scripts/02a_smoke_corp_actions_quantmod.R
  scripts/04_run_screener_mock_only.R
  scripts/04a_smoke_adjuster_small_window.R
  scripts/04b_diagnose_suspects_selective.R
  scripts/05a_smoke_screener_real_small_window.R
  scripts/05b_hard_screener_full_selective.R
  scripts/05c_hard_selective_split_audit.R
  scripts/05d_yahoo_vs_af2_crosscheck.R



###############################################################################
### FILE: scripts/00_load_module_05.R
###############################################################################
# v2/scripts/00_load_module_05.R
# Loads Module 05 (Screener) + the core dependencies it relies on.
# Guarantees af2_compute_symbol_metrics exists.

af2_src <- function(path) {
  if (!file.exists(path)) stop("Missing file: ", path, call. = FALSE)
  message("SOURCE: ", normalizePath(path, winslash = "/", mustWork = TRUE))
  source(path, local = FALSE)
}

# Ensure we are at project root (the folder that contains /v2)
if (!dir.exists("v2") && basename(getwd()) == "v2") setwd("..")
stopifnot(dir.exists("v2"))

# Core (required by screener functions)
af2_src("v2/modules/00_core/R/utils.R")
af2_src("v2/modules/00_core/R/logging.R")
af2_src("v2/modules/00_core/R/config.R")

# Module 05 (ORDER MATTERS: compute_metrics BEFORE run_screener)
af2_src("v2/modules/05_screener/R/screener_config.R")
af2_src("v2/modules/05_screener/R/validate_screener_input.R")
af2_src("v2/modules/05_screener/R/liquidity_filter.R")
af2_src("v2/modules/05_screener/R/score_rank.R")
af2_src("v2/modules/05_screener/R/compute_metrics.R")
af2_src("v2/modules/05_screener/R/run_screener.R")

# Hard sanity check (this is what just failed for you)
need <- c("af2_run_screener", "af2_compute_symbol_metrics", "af2_get_screener_config",
          "af2_validate_screener_input", "af2_compute_liquidity_from_panel")
miss <- need[!vapply(need, exists, logical(1), inherits = TRUE)]
if (length(miss)) {
  stop("Module 05 load FAILED. Missing functions: ", paste(miss, collapse = ", "), call. = FALSE)
}

message("OK: Module 05 loaded (including af2_compute_symbol_metrics).")



###############################################################################
### FILE: README.md
###############################################################################
# autofinance_R v2

Principles:
- In-memory first
- Contract-first
- Fixtures-first
- Screener cannot fetch or adjust data
- Adjuster is the single owner of history mutation



###############################################################################
### FILE: contracts/adjustments.md
###############################################################################
# adjustments.md

## Purpose
`adjustments` is the per-symbol daily adjustment timeline produced by Module 04.
It is an audit table: it explains *why* `panel_adj` differs from `universe_raw`.

## Table contract (schema)

### Keys
- `(symbol, refdate)` unique within this table.

### Required columns
| column            | type      | required | semantics |
|------------------|-----------|----------|----------|
| symbol           | character | yes      | uppercase ticker |
| refdate          | Date      | yes      | trading date |
| split_value      | numeric   | yes      | same-day split price-factor (1 means none). Multiple splits on same day are multiplied. |
| div_cash         | numeric   | yes      | same-day cash dividend amount (0 means none). Multiple dividends summed. |
| split_factor_cum | numeric   | yes      | cumulative split factor applied to *this date* (exclusive: events with refdate > date) |
| div_factor_event | numeric   | yes      | per-day dividend factor (normally 1; <1 on dividend date when computable) |
| div_factor_cum   | numeric   | yes      | cumulative dividend factor applied to *this date* (exclusive) |
| adj_factor_final | numeric   | yes      | `split_factor_cum * div_factor_cum` |
| source_mask      | character | yes      | provenance summary (e.g., `yahoo`, `manual`, `yahoo+manual`) |
| has_manual       | logical   | yes      | TRUE if any manual event contributed that day |
| issue_div        | logical   | yes      | TRUE when dividend factor could not be computed safely |

## Dividend issue policy (current v2 behavior)
On a day where `div_cash > 0`, dividend factor uses:
- `close_prev = lag(close_adj_split)`  
- If `close_prev` is missing/non-finite, `close_prev <= 0`, or `div_cash >= close_prev`,
  then the system sets:
  - `issue_div = TRUE`
  - `div_factor_event = 1` (no dividend adjustment applied for that event)

This is intentionally conservative: it avoids exploding the factor chain.

## Guarantees
- `split_value > 0`
- `div_cash >= 0`
- `split_factor_cum > 0`
- `div_factor_cum >= 0`
- `adj_factor_final >= 0`



###############################################################################
### FILE: contracts/panel_adj.md
###############################################################################
# panel_adj.md

## Purpose
`panel_adj` is the adjusted daily panel produced by Module 04 (Adjuster).
It contains raw OHLC, split-adjusted OHLC, and split+dividend adjusted OHLC.
It is the only input accepted by the Screener (Module 05).

## Table contract (schema)

### Keys
- **Primary key:** `(symbol, refdate)` must be **unique**.

### Required columns (minimum)
| column            | type      | required | semantics |
|------------------|-----------|----------|----------|
| symbol           | character | yes      | uppercase ticker |
| refdate          | Date      | yes      | trading date |
| asset_type       | character | yes      | `equity` / `fii` / `etf` / `bdr` |
| close_adj_final  | numeric   | yes      | final adjusted close (splits + dividends) |
| adjustment_state | character | yes      | see below |
| turnover         | numeric   | yes*     | liquidity volume in BRL (or `vol_fin` alternative) |
| qty              | numeric   | yes      | liquidity quantity proxy |

\* Either `turnover` OR `vol_fin` must exist. Downstream modules may normalize `vol_fin -> turnover`.

### Recommended columns (what v2 currently produces)
Raw aliases:
- `open_raw, high_raw, low_raw, close_raw`

Split-adjusted:
- `open_adj_split, high_adj_split, low_adj_split, close_adj_split`

Final adjusted (split + dividend):
- `open_adj_final, high_adj_final, low_adj_final, close_adj_final`

### adjustment_state semantics (exact values)
- `ok` : no split/dividend events in-range
- `dividend_only` : dividend events applied, no splits
- `split_only` : split events applied, no dividends
- `split_dividend` : both applied
- `manual_override` : at least one manual event present for the symbol (anywhere in-range)
- `suspect_unresolved` : dividend adjustment had an unresolved computation issue (`issue_div_any == TRUE`)

### Invariants / guarantees
- `(symbol, refdate)` uniqueness guaranteed.
- Adjustment factors are applied deterministically based on the `events` table.
- If `adjustment_state == suspect_unresolved`, downstream consumers must either:
  - stop (default policy), or
  - explicitly allow unresolved symbols.

## Relationship to other outputs
Module 04 also outputs:
- `events` (per symbol-date split_value/div_cash)
- `adjustments` (timeline of factors per date)



###############################################################################
### FILE: contracts/screener_input.md
###############################################################################
# screener_input.md

## Purpose
Defines what Module 05 (Screener / Feature builder) accepts.

## Input: panel_adj (from Module 04)

### Keys
- `(symbol, refdate)` must be unique.

### Required columns
- `symbol` (character)
- `refdate` (Date)
- `asset_type` (character)
- `close_adj_final` (numeric)
- `adjustment_state` (character)
- liquidity: either `turnover` or `vol_fin` must exist

### Recommended columns (for OHLC-based features)
- `open_adj_final`, `high_adj_final`, `low_adj_final`, `close_adj_final`

## Policy: unresolved suspects
If any rows have `adjustment_state == "suspect_unresolved"` then:
- default behavior: **stop**
- override: allow only if caller explicitly sets `allow_unresolved = TRUE`



###############################################################################
### FILE: contracts/screener_output.md
###############################################################################
# screener_output.md

## Purpose
Module 05 outputs a **feature vector** per symbol.
Ranking/scoring is optional and should be treated as a separate concern.

## Output: features (primary)
A table with **one row per symbol**.

### Keys
- `symbol` unique.

### Required metadata columns
| column      | type      | semantics |
|------------|-----------|----------|
| symbol     | character | uppercase ticker |
| asset_type | character | `equity` / `fii` / `etf` / `bdr` |
| end_date   | Date      | last date used for feature computation |
| n_obs      | integer   | number of rows used (post-slicing) |
| n_valid    | integer   | number of finite close observations |
| coverage   | numeric   | `n_valid / n_obs` |

### Baseline feature families (v2 minimum)
- Multi-horizon returns from `close_adj_final`:
  - `ret_21d`, `ret_63d`, `ret_126d`, `ret_252d` (configurable horizons)
- Close-to-close realized volatility (annualized):
  - `vol_cc_21d`, `vol_cc_63d`, ... (same horizons)
- OHLC-based realized volatility (annualized, NA-safe):
  - Parkinson range vol: `vol_pk_21d`, ...
  - Garman–Klass vol: `vol_gk_21d`, ...
- Drawdown/stress:
  - `max_dd`, `ulcer_index`
- Liquidity/microstructure proxies:
  - `median_turnover`, `days_traded_ratio`, `amihud`

### NA rules
- If insufficient data for a horizon window, that feature is `NA_real_`.
- Features must be present as columns even when NA (stable schema).

## Optional output: ranking (secondary)
If a scoring model is applied, Module 05 may also output:
- `full` table: features + score + ranks
- `by_type` list: same, split by `asset_type`

But **features remain the primary contract**.



###############################################################################
### FILE: contracts/universe_raw.md
###############################################################################
*** Begin Patch
*** Update File: contracts/screener_output.md
@@
-# screener_output.md
-
-This is a placeholder. Fill with the explicit schema + guarantees.
+# screener_output.md
+
+## Purpose
+Defines the **feature vector** output produced by Module 05.
+This output is intended to be consumed by **separate ranking/scoring logic** later.
+
+## Output object
+`features` (data.table/data.frame), **one row per symbol**.
+
+## Required identifier/meta columns
+| column      | type | meaning |
+|------------|------|---------|
+| symbol     | chr  | ticker |
+| asset_type | chr  | equity/fii/etf/bdr |
+
+## Recommended coverage/meta columns
+| column        | type | meaning |
+|--------------|------|---------|
+| end_refdate  | Date | last date used for features |
+| n_obs        | int  | number of rows used in the feature window |
+| days_traded_ratio | dbl | fraction of non-NA `close_adj_final` in window |
+
+## Core price/return features (examples)
+For each horizon `h` in config (e.g., 21/63/126/252):
+- `ret_{h}d` (simple price return over horizon)
+- `vol_{h}d` (annualized close-to-close volatility over last h obs)
+
+## OHLC-based risk features (recommended)
For each horizon `h` (when OHLC columns exist):
+- `parkinson_vol_{h}d` (annualized high/low-based volatility estimator)
+- `range_mean_{h}d` (mean daily range fraction: (high-low)/close)
+- `gap_vol_{h}d` (annualized volatility of open-to-prev-close returns)
+
+## Path-dependence / drawdown features
- `max_dd`
- `ulcer_index`
+
+## Liquidity features
- `amihud` (|ret| / turnover proxy)
+
+## NA policy
- Features may be NA if insufficient data exists for a symbol/horizon.
+- The table shape (column set) must remain stable across runs for the same config.
+
*** End Patch



###############################################################################
### FILE: modules/00_core/R/config.R
###############################################################################
# v2/modules/00_core/R/config.R

af2_config_default <- list(
  # Universe scope (used later)
  # Dev default: keep it small and fast.
  # Override explicitly for full rebuild.
  years = {
    y <- as.integer(format(Sys.Date(), "%Y"))
    (y-1L):y
  },
  include_types = c("equity", "fii", "etf", "bdr"),

  # Screener liquidity
  min_turnover = 5e5,
  min_days_traded_ratio = 0.8,

  # Corporate actions toggles (used later)
  enable_splits = TRUE,
  enable_manual_events = TRUE,

  # Paths
  cache_dir  = "v2/data/cache",
  raw_dir    = "v2/data/raw",
  fixtures_dir = "v2/data/fixtures",
  manual_dir = "v2/data/manual",
  logs_dir   = "v2/logs",

  # Safety
  allow_unresolved_in_screener = FALSE,

  # -------------------------------
  # Selective corporate-actions policy (the "trick")
  # -------------------------------
  enable_selective_actions = TRUE,

  # Cache strategy for corp actions:
  # - "batch" keeps current behavior (hash by symbol set)
  # - "by_symbol" enables incremental caching per ticker
  ca_cache_mode = "batch",

  # Prefilter heuristics (B3-only)
  ca_prefilter_recent_days   = 252L,
  ca_prefilter_top_n_overall = 200L,
  ca_prefilter_top_n_by_type = 50L,
  ca_prefilter_max_candidates = 300L,

  # One-day gap thresholds by type (very cheap anomaly filter)
  ca_prefilter_gap_equity = -0.20,
  ca_prefilter_gap_fii    = -0.12,
  ca_prefilter_gap_etf    = -0.15,
  ca_prefilter_gap_bdr    = -0.20,

  # Activeness / recency guards for selective CA
  ca_prefilter_active_days = 10L,

  # Use a shorter window for liquidity scoring (robust to old junk)
  ca_prefilter_liq_window_days = 63L,

  # -------------------------------
  # Split sanity gates (debug + safety)
  # Values are PRICE FACTORS after normalization.
  # Typical forward splits: 0.5, 0.333..., 0.2
  # Typical reverse splits: 2, 5, 10 (rare)
  # -------------------------------
  enable_split_plausibility_gate = FALSE,
  split_gate_min = 0.05,  # conservative, allows 20:1
  split_gate_max = 10.0,  # conservative, allows 1:10 reverse

  # Split-gap validation against raw
  enable_split_gap_validation = TRUE,
  split_gap_tol_log = 0.35,

  # Split-gap validation against raw (Cotahist)
  enable_split_gap_validation = TRUE,
  split_gap_tol_log = 0.35,

  # NEW: how far forward we allow snapping Yahoo split dates
  # to the next B3 trading day (for weekend/holiday/vendor-date mismatches)
  split_gap_max_forward_days = 5L,

  # NEW: prefer using post-day OPEN when available (splits are effective at market open);
  # fallback to CLOSE if OPEN missing.
  split_gap_use_open = TRUE

)

af2_get_config <- function(config = NULL) {
  cfg <- af2_config_default
  if (!is.null(config)) {
    # shallow override for now (keep simple)
    for (nm in names(config)) cfg[[nm]] <- config[[nm]]
  }
  # ensure dirs exist
  dir.create(cfg$cache_dir, recursive = TRUE, showWarnings = FALSE)
  dir.create(cfg$raw_dir, recursive = TRUE, showWarnings = FALSE)
  dir.create(cfg$fixtures_dir, recursive = TRUE, showWarnings = FALSE)
  dir.create(cfg$manual_dir, recursive = TRUE, showWarnings = FALSE)
  dir.create(cfg$logs_dir, recursive = TRUE, showWarnings = FALSE)

  # -------------------------------
  # Validation of sensitive knobs
  # -------------------------------
  if (!is.null(cfg$ca_cache_mode) &&
      !cfg$ca_cache_mode %in% c("batch", "by_symbol")) {
    stop("Invalid ca_cache_mode: ", cfg$ca_cache_mode,
         ". Allowed: batch, by_symbol", call. = FALSE)
  }

  cfg$ca_prefilter_recent_days <- as.integer(cfg$ca_prefilter_recent_days %||% 252L)
  cfg$ca_prefilter_top_n_overall <- as.integer(cfg$ca_prefilter_top_n_overall %||% 200L)
  cfg$ca_prefilter_top_n_by_type <- as.integer(cfg$ca_prefilter_top_n_by_type %||% 50L)
  cfg$ca_prefilter_max_candidates <- as.integer(cfg$ca_prefilter_max_candidates %||% 300L)

  cfg$enable_split_gap_validation <- isTRUE(cfg$enable_split_gap_validation)
  cfg$split_gap_tol_log <- as.numeric(cfg$split_gap_tol_log %||% 0.35)

  cfg$split_gap_max_forward_days <- as.integer(cfg$split_gap_max_forward_days %||% 5L)
  if (!is.finite(cfg$split_gap_max_forward_days) || cfg$split_gap_max_forward_days < 0L) {
    cfg$split_gap_max_forward_days <- 5L
  }

  cfg$split_gap_use_open <- isTRUE(cfg$split_gap_use_open)

  cfg
}



###############################################################################
### FILE: modules/00_core/R/logging.R
###############################################################################
# v2/modules/00_core/R/logging.R

af2_log <- function(prefix, ...) {
  msg <- paste0(prefix, " ", paste(..., collapse = ""))
  message(msg)
}

af2_log_cfg <- function(config) {
  af2_log("AF2_CFG:", "\n", paste(utils::capture.output(str(config)), collapse = "\n"))
}



###############################################################################
### FILE: modules/00_core/R/utils.R
###############################################################################
# v2/modules/00_core/R/utils.R

`%||%` <- function(x, y) if (!is.null(x)) x else y

af2_require <- function(pkgs) {
  pkgs <- unique(pkgs)
  missing <- pkgs[!vapply(pkgs, requireNamespace, logical(1), quietly = TRUE)]
  if (length(missing)) {
    stop("Missing packages in v2 environment: ",
         paste(missing, collapse = ", "),
         "\nInstall them explicitly to keep v2 deterministic.",
         call. = FALSE)
  }
  invisible(TRUE)
}

af2_assert_cols <- function(dt, cols, name = "object") {
  if (is.null(dt)) stop(name, " is NULL.", call. = FALSE)
  if (!is.data.frame(dt)) stop(name, " must be a data.frame/data.table.", call. = FALSE)
  miss <- setdiff(cols, names(dt))
  if (length(miss)) {
    stop(name, " missing required columns: ", paste(miss, collapse = ", "), call. = FALSE)
  }
  invisible(TRUE)
}

af2_assert_no_dupes <- function(dt, key_cols, name = "object") {
  af2_require("data.table")
  x <- data.table::as.data.table(dt)
  dup <- x[, .N, by = key_cols][N > 1L]
  if (nrow(dup)) {
    stop(name, " has duplicated keys on: ",
         paste(key_cols, collapse = ", "),
         "\nExample dup rows:\n",
         paste(utils::capture.output(print(utils::head(dup, 10))), collapse = "\n"),
         call. = FALSE)
  }
  invisible(TRUE)
}

af2_weekdays_only <- function(dates) {
  w <- weekdays(dates)
  !(w %in% c("Saturday", "Sunday", "sábado", "domingo"))
}

af2_make_bizdays_seq <- function(start_date, end_date, cal = "Brazil/B3") {
  start_date <- as.Date(start_date)
  end_date   <- as.Date(end_date)

  # Prefer the official calendar if available
  if (requireNamespace("bizdays", quietly = TRUE)) {
    out <- tryCatch(
      bizdays::bizseq(start_date, end_date, cal),
      error = function(e) NULL
    )
    if (!is.null(out) && length(out)) {
      return(as.Date(out))
    }
  }

  # Fallback: weekdays only
  d <- seq.Date(start_date, end_date, by = "day")
  d[af2_weekdays_only(d)]
}




###############################################################################
### FILE: modules/00_core/README.md
###############################################################################
# Module

Purpose:
- Define INPUT contract
- Define OUTPUT contract
- List functions
- List tests



###############################################################################
### FILE: modules/01_b3_universe/R/build_universe.R
###############################################################################
# v2/modules/01_b3_universe/R/build_universe.R

af2_b3_cache_key <- function(year, include_types) {
  paste0(
    "cotahist_yearly_",
    year, "_",
    paste(sort(include_types), collapse = "-"),
    ".rds"
  )
}

af2_b3_build_universe_year <- function(year,
                                       include_types = NULL,
                                       cfg = NULL,
                                       verbose = TRUE,
                                       use_cache = TRUE,
                                       force_download = FALSE,
                                       reprocess = FALSE) {
  cfg <- cfg %||% af2_get_config()

  include_types <- include_types %||% cfg$include_types
  include_types <- af2_b3_validate_types(include_types)

  # Cache path
  cache_dir <- file.path(cfg$cache_dir, "b3_universe")
  if (!dir.exists(cache_dir)) dir.create(cache_dir, recursive = TRUE)

  cache_file <- file.path(cache_dir, af2_b3_cache_key(year, include_types))

  if (isTRUE(use_cache) && file.exists(cache_file) && !isTRUE(force_download)) {
    if (verbose) af2_log("AF2_B3:", "Using cache: ", cache_file)
    dt_cached <- readRDS(cache_file)
    return(data.table::as.data.table(dt_cached))
  }

  # 1) Lazy fetch
  df_lazy <- af2_b3_fetch_yearly_lazy(
    year = year, cfg = cfg, verbose = verbose,
    force_download = force_download,
    reprocess = reprocess
  )

  # 2) Apply type filters lazily
  lazy_by_type <- af2_b3_apply_type_filters(df_lazy, include_types)

  # 3) Collect each type separately (bounded)
  out_list <- list()

  for (tp in names(lazy_by_type)) {
    if (verbose) af2_log("AF2_B3:", "Collecting type: ", tp, " for ", year)
    df_tp <- dplyr::collect(lazy_by_type[[tp]])
    if (!nrow(df_tp)) next

    dt_min <- af2_b3_select_min_cols(df_tp)
    dt_liq <- af2_b3_unify_liquidity(dt_min)
    dt_liq[, asset_type := tp]

    out_list[[tp]] <- dt_liq
  }

  if (!length(out_list)) {
    stop("af2_b3_build_universe_year: no data returned after filters for year ", year)
  }

  dt_year <- data.table::rbindlist(out_list, use.names = TRUE, fill = TRUE)
  data.table::setorder(dt_year, asset_type, symbol, refdate)

  # 4) Validate contract
  required <- c("symbol", "refdate", "open", "high", "low", "close", "turnover", "qty", "asset_type")
  miss <- setdiff(required, names(dt_year))
  if (length(miss)) {
    stop("Universe contract violated. Missing cols: ", paste(miss, collapse = ", "))
  }

  # 5) Drop obvious junk rows
  dt_year <- dt_year[!is.na(symbol) & symbol != "" & !is.na(refdate) & is.finite(close)]

  # 5b) Enforce unique (symbol, refdate) keys (upstream rb3 edge-case)
  # Dedupe rule (contract):
  # 1) max turnover, 2) max qty, 3) max close, 4) first deterministic row
  data.table::setorder(dt_year, asset_type, symbol, refdate)
  
  dup <- dt_year[, .N, by = .(symbol, refdate)][N > 1L]
  if (nrow(dup)) {
    if (verbose) {
      af2_log(
        "AF2_B3:",
        "WARNING: duplicated (symbol, refdate) detected in universe_raw year=", year,
        ". Applying dedupe rule. Examples:"
      )
      print(utils::head(dup[order(-N)], 10))
    }
  
    # Make ordering deterministic for tie-breaking
    if (!("turnover" %in% names(dt_year))) dt_year[, turnover := NA_real_]
    if (!("qty" %in% names(dt_year))) dt_year[, qty := NA_real_]
  
    dt_year <- dt_year[
      order(
        symbol, refdate,
        -data.table::fifelse(is.finite(turnover), turnover, -Inf),
        -data.table::fifelse(is.finite(qty), qty, -Inf),
        -data.table::fifelse(is.finite(close), close, -Inf)
      )
    ][, .SD[1L], by = .(symbol, refdate)]
  
    data.table::setorder(dt_year, asset_type, symbol, refdate)
  }

  if (verbose) {
    af2_log("AF2_B3:", "Year ", year, " rows = ", nrow(dt_year))
    af2_log("AF2_B3:", "Unique symbols = ", length(unique(dt_year$symbol)))
    af2_log("AF2_B3:", "Counts by type:")
    print(dt_year[, .N, by = asset_type][order(-N)])
  }

  # 6) Save cache
  if (isTRUE(use_cache)) {
    saveRDS(dt_year, cache_file)
    if (verbose) af2_log("AF2_B3:", "Wrote cache: ", cache_file)
  }

  dt_year
}

af2_b3_build_universe <- function(years = NULL,
                                  include_types = NULL,
                                  cfg = NULL,
                                  verbose = TRUE,
                                  use_cache = TRUE,
                                  force_download = FALSE,
                                  reprocess = FALSE) {
  cfg <- cfg %||% af2_get_config()
  years <- years %||% cfg$years
  years <- sort(unique(as.integer(years)))

  include_types <- include_types %||% cfg$include_types
  include_types <- af2_b3_validate_types(include_types)

  out <- list()
  for (y in years) {
    out[[as.character(y)]] <- af2_b3_build_universe_year(
      year = y,
      include_types = include_types,
      cfg = cfg,
      verbose = verbose,
      use_cache = use_cache,
      force_download = force_download,
      reprocess = reprocess
    )
  }

  dt_all <- data.table::rbindlist(out, use.names = TRUE, fill = TRUE)
  data.table::setorder(dt_all, asset_type, symbol, refdate)

  dt_all
}

af2_b3_cache_key_window <- function(start_date, end_date, include_types) {
  paste0(
    "cotahist_daily_",
    format(as.Date(start_date), "%Y%m%d"), "_",
    format(as.Date(end_date), "%Y%m%d"), "_",
    paste(sort(include_types), collapse = "-"),
    ".rds"
  )
}

af2_b3_build_universe_window <- function(start_date, end_date,
                                         include_types = NULL,
                                         cfg = NULL,
                                         verbose = TRUE,
                                         use_cache = TRUE,
                                         force_download = FALSE,
                                         reprocess = FALSE) {

  cfg <- cfg %||% af2_get_config()

  include_types <- include_types %||% cfg$include_types
  include_types <- af2_b3_validate_types(include_types)

  start_date <- as.Date(start_date)
  end_date   <- as.Date(end_date)

  # Cache path
  cache_dir <- file.path(cfg$cache_dir, "b3_universe")
  if (!dir.exists(cache_dir)) dir.create(cache_dir, recursive = TRUE)

  cache_file <- file.path(cache_dir, af2_b3_cache_key_window(start_date, end_date, include_types))

  if (isTRUE(use_cache) && file.exists(cache_file) && !isTRUE(force_download)) {
    if (verbose) af2_log("AF2_B3:", "Using cache: ", cache_file)
    dt_cached <- readRDS(cache_file)
    return(data.table::as.data.table(dt_cached))
  }

  # 1) Lazy fetch daily window
  df_lazy <- af2_b3_fetch_daily_lazy(
    start_date = start_date,
    end_date   = end_date,
    cfg = cfg,
    verbose = verbose,
    force_download = force_download,
    reprocess = reprocess
  )

  # 2) Apply type filters lazily
  lazy_by_type <- af2_b3_apply_type_filters(df_lazy, include_types)

  # 3) Collect each type separately (bounded)
  out_list <- list()

  for (tp in names(lazy_by_type)) {
    if (verbose) af2_log("AF2_B3:", "Collecting type: ", tp,
                         " for window ", start_date, " to ", end_date)

    df_tp <- dplyr::collect(lazy_by_type[[tp]])
    if (!nrow(df_tp)) next

    dt_min <- af2_b3_select_min_cols(df_tp)
    dt_liq <- af2_b3_unify_liquidity(dt_min)
    dt_liq[, asset_type := tp]

    out_list[[tp]] <- dt_liq
  }

  if (!length(out_list)) {
    stop("af2_b3_build_universe_window: no data returned after filters.")
  }

  dt_win <- data.table::rbindlist(out_list, use.names = TRUE, fill = TRUE)
  data.table::setorder(dt_win, asset_type, symbol, refdate)

  # 4) Validate contract
  required <- c("symbol", "refdate", "open", "high", "low", "close",
                "turnover", "qty", "asset_type")
  miss <- setdiff(required, names(dt_win))
  if (length(miss)) stop("Universe contract violated. Missing cols: ", paste(miss, collapse = ", "))

  # 5) Drop obvious junk
  dt_win <- dt_win[!is.na(symbol) & symbol != "" & !is.na(refdate) & is.finite(close)]
  
  # 5b) Enforce unique (symbol, refdate) keys (upstream rb3 edge-case)
  data.table::setorder(dt_win, asset_type, symbol, refdate)
  
  dup <- dt_win[, .N, by = .(symbol, refdate)][N > 1L]
  if (nrow(dup)) {
    if (verbose) {
      af2_log(
        "AF2_B3:",
        "WARNING: duplicated (symbol, refdate) detected in universe_raw window ",
        as.character(start_date), " to ", as.character(end_date),
        ". Applying dedupe rule. Examples:"
      )
      print(utils::head(dup[order(-N)], 10))
    }
  
    if (!("turnover" %in% names(dt_win))) dt_win[, turnover := NA_real_]
    if (!("qty" %in% names(dt_win))) dt_win[, qty := NA_real_]
  
    dt_win <- dt_win[
      order(
        symbol, refdate,
        -data.table::fifelse(is.finite(turnover), turnover, -Inf),
        -data.table::fifelse(is.finite(qty), qty, -Inf),
        -data.table::fifelse(is.finite(close), close, -Inf)
      )
    ][, .SD[1L], by = .(symbol, refdate)]
  
    data.table::setorder(dt_win, asset_type, symbol, refdate)
  }

  if (verbose) {
    af2_log("AF2_B3:", "Window rows = ", nrow(dt_win))
    af2_log("AF2_B3:", "Unique symbols = ", length(unique(dt_win$symbol)))
    af2_log("AF2_B3:", "Counts by type:")
    print(dt_win[, .N, by = asset_type][order(-N)])
  }

  if (isTRUE(use_cache)) {
    saveRDS(dt_win, cache_file)
    if (verbose) af2_log("AF2_B3:", "Wrote cache: ", cache_file)
  }

  dt_win
}



###############################################################################
### FILE: modules/01_b3_universe/R/fetch_daily.R
###############################################################################
# Fetch a daily window with rb3, then return *lazy* dataset handle

af2_b3_fetch_daily_lazy <- function(start_date, end_date,
                                    cfg = NULL, verbose = TRUE,
                                    force_download = FALSE,
                                    reprocess = FALSE,
                                    throttle = TRUE) {

  cfg <- cfg %||% af2_get_config()
  af2_b3_init_rb3(cfg, verbose = verbose)

  start_date <- as.Date(start_date)
  end_date   <- as.Date(end_date)

  # Now uses proper B3 bizdays if available
  refdates <- af2_make_bizdays_seq(start_date, end_date)

  if (!length(refdates)) {
    stop("af2_b3_fetch_daily_lazy: empty refdate sequence.")
  }

  if (verbose) {
    af2_log("AF2_B3:", "fetch_marketdata daily window: ",
            as.character(start_date), " to ", as.character(end_date),
            " (", length(refdates), " dates)")
  }

  ok <- TRUE
  tryCatch({
    rb3::fetch_marketdata(
      "b3-cotahist-daily",
      refdate = refdates,
      throttle = isTRUE(throttle),
      force_download = isTRUE(force_download),
      reprocess = isTRUE(reprocess)
    )
  }, error = function(e) {
    ok <<- FALSE
    af2_log("AF2_B3:", "fetch_marketdata daily failed: ", conditionMessage(e))
  })

  if (!ok) {
    for (d in refdates) {
      tryCatch({
        meta <- rb3::download_marketdata("b3-cotahist-daily", refdate = d)
        rb3::read_marketdata(meta)
      }, error = function(e2) {
        if (verbose) af2_log("AF2_B3:", "daily fallback failed for ", d, ": ", conditionMessage(e2))
      })
    }
  }

  df_lazy <- tryCatch({
    rb3::cotahist_get("daily")
  }, error = function(e) {
    stop("cotahist_get('daily') failed: ", conditionMessage(e))
  })

  df_lazy |>
    dplyr::filter(.data$refdate >= start_date, .data$refdate <= end_date)
}


###############################################################################
### FILE: modules/01_b3_universe/R/fetch_yearly.R
###############################################################################
# v2/modules/01_b3_universe/R/fetch_yearly.R
# Fetch one year with rb3, then return *lazy* dataset handle

af2_b3_fetch_yearly_lazy <- function(year, cfg = NULL, verbose = TRUE,
                                     force_download = FALSE,
                                     reprocess = FALSE) {
  cfg <- cfg %||% af2_get_config()
  af2_b3_init_rb3(cfg, verbose = verbose)

  year <- as.integer(year)

  if (verbose) af2_log("AF2_B3:", "fetch_marketdata yearly: ", year)

  ok <- TRUE
  tryCatch({
    rb3::fetch_marketdata(
      "b3-cotahist-yearly",
      year = year,
      throttle = TRUE,
      force_download = isTRUE(force_download),
      reprocess = isTRUE(reprocess)
    )
  }, error = function(e) {
    ok <<- FALSE
    af2_log("AF2_B3:", "fetch_marketdata failed for ", year, ": ", conditionMessage(e))
  })

  if (!ok) {
    # Fallback path
    tryCatch({
      meta <- rb3::download_marketdata("b3-cotahist-yearly", year = year)
      rb3::read_marketdata(meta)
      af2_log("AF2_B3:", "fallback download/read OK for ", year)
    }, error = function(e2) {
      stop("rb3 fallback download/read failed for ", year, ": ", conditionMessage(e2))
    })
  }

  df_lazy <- tryCatch({
    rb3::cotahist_get("yearly")
  }, error = function(e) {
    stop("cotahist_get('yearly') failed: ", conditionMessage(e))
  })

  start_y <- as.Date(paste0(year, "-01-01"))
  end_y   <- as.Date(paste0(year + 1L, "-01-01"))

  df_lazy <- df_lazy |>
    dplyr::filter(.data$refdate >= start_y, .data$refdate < end_y)

  df_lazy
}



###############################################################################
### FILE: modules/01_b3_universe/R/filter_by_type_rb3.R
###############################################################################
# v2/modules/01_b3_universe/R/filter_by_type_rb3.R
# Apply rb3 class filters BEFORE collect

af2_b3_apply_type_filters <- function(df_lazy, include_types) {
  include_types <- af2_b3_validate_types(include_types)

  # Start with empty list of lazy datasets, bind after filtering
  out_list <- list()

  if ("equity" %in% include_types) {
    out_list[["equity"]] <- rb3::cotahist_filter_equity(df_lazy)
  }
  if ("fii" %in% include_types) {
    out_list[["fii"]] <- rb3::cotahist_filter_fii(df_lazy)
  }
  if ("etf" %in% include_types) {
    out_list[["etf"]] <- rb3::cotahist_filter_etf(df_lazy)
  }
  if ("bdr" %in% include_types) {
    out_list[["bdr"]] <- rb3::cotahist_filter_bdr(df_lazy)
  }

  if (!length(out_list)) {
    stop("No include_types provided after validation.")
  }

  out_list
}



###############################################################################
### FILE: modules/01_b3_universe/R/rb3_init.R
###############################################################################
# v2/modules/01_b3_universe/R/rb3_init.R
# Deterministic rb3 cache bootstrap for v2

af2_b3_init_rb3 <- function(cfg = NULL, verbose = TRUE) {
  cfg <- cfg %||% af2_get_config()

  cache_dir <- file.path(cfg$cache_dir, "rb3")
  if (!dir.exists(cache_dir)) dir.create(cache_dir, recursive = TRUE)

  options(rb3.cachedir = normalizePath(cache_dir, winslash = "/", mustWork = FALSE))

  if (verbose) {
    af2_log("AF2_B3:", "rb3.cachedir = ", getOption("rb3.cachedir"))
  }

  # Bootstrap templates DB (safe no-op if already initialized)
  tryCatch({
    rb3::rb3_bootstrap()
    if (verbose) af2_log("AF2_B3:", "rb3_bootstrap OK.")
  }, error = function(e) {
    # We don't hard fail here because rb3 can still read cached data;
    # but we DO log clearly.
    af2_log("AF2_B3:", "rb3_bootstrap warning: ", conditionMessage(e))
  })

  invisible(TRUE)
}



###############################################################################
### FILE: modules/01_b3_universe/R/select_min_cols.R
###############################################################################
# v2/modules/01_b3_universe/R/select_min_cols.R
# Normalize column names across potential rb3 schema differences

af2_b3_pick_col <- function(dt, alternatives) {
  cand <- intersect(alternatives, names(dt))
  if (length(cand)) cand[1L] else NA_character_
}

af2_b3_select_min_cols <- function(dt) {
  # dt is a collected data.frame/data.table from rb3

  # Defensive mapping of OHLC + liquidity
  col_symbol <- af2_b3_pick_col(dt, c("symbol", "ticker"))
  col_ref    <- af2_b3_pick_col(dt, c("refdate", "date"))
  col_open   <- af2_b3_pick_col(dt, c("open", "price.open", "preco_abertura"))
  col_high   <- af2_b3_pick_col(dt, c("high", "price.high", "preco_maximo"))
  col_low    <- af2_b3_pick_col(dt, c("low", "price.low", "preco_minimo"))
  col_close  <- af2_b3_pick_col(dt, c("close", "price.close", "preco_ultimo"))

  # Liquidity candidates:
  # - financial_volume / volume in BRL
  # - trade_quantity in units
  col_volfin <- af2_b3_pick_col(dt, c("financial_volume", "volume", "vol_fin"))
  col_qty <- af2_b3_pick_col(dt, c("trade_quantity", "quantity", "qty"))

  missing_core <- c(
    symbol = col_symbol,
    refdate = col_ref,
    close = col_close
  )
  if (any(is.na(missing_core))) {
    stop(
      "COTAHIST schema missing core columns. Found names: ",
      paste(names(dt), collapse = ", ")
    )
  }

  out <- data.table::as.data.table(dt)

  out_min <- data.table::data.table(
    symbol  = trimws(as.character(out[[col_symbol]])),
    refdate = as.Date(out[[col_ref]]),
    open    = if (!is.na(col_open))  as.numeric(out[[col_open]])  else NA_real_,
    high    = if (!is.na(col_high))  as.numeric(out[[col_high]])  else NA_real_,
    low     = if (!is.na(col_low))   as.numeric(out[[col_low]])   else NA_real_,
    close   = as.numeric(out[[col_close]]),
    vol_fin = if (!is.na(col_volfin)) as.numeric(out[[col_volfin]]) else NA_real_,
    qty_raw = if (!is.na(col_qty))    as.numeric(out[[col_qty]])    else NA_real_
  )

  out_min
}



###############################################################################
### FILE: modules/01_b3_universe/R/unify_liquidity.R
###############################################################################
# v2/modules/01_b3_universe/R/unify_liquidity.R
# Convert raw liquidity into standardized 'turnover' and 'qty'

af2_b3_unify_liquidity <- function(dt_min) {
  dt <- data.table::as.data.table(dt_min)

  if (!all(c("symbol", "refdate", "close") %in% names(dt))) {
    stop("Liquidity unify requires at least symbol/refdate/close.")
  }

  # qty meaning in rb3 can be ambiguous across templates.
  # We treat 'qty_raw' as units proxy and keep it as qty.
  if (!("qty_raw" %in% names(dt))) dt[, qty_raw := NA_real_]
  if (!("vol_fin" %in% names(dt))) dt[, vol_fin := NA_real_]

  dt[, qty := qty_raw]

  # turnover in BRL:
  # Prefer provided financial volume when present, otherwise fallback to qty * close.
  dt[, turnover := data.table::fifelse(
    is.finite(vol_fin) & vol_fin > 0,
    vol_fin,
    data.table::fifelse(
      is.finite(qty) & qty > 0 & is.finite(close),
      qty * close,
      NA_real_
    )
  )]

  dt[, c("vol_fin", "qty_raw") := NULL]

  dt
}



###############################################################################
### FILE: modules/01_b3_universe/R/validate_types.R
###############################################################################
# v2/modules/01_b3_universe/R/validate_types.R

af2_b3_allowed_types <- c("equity", "fii", "etf", "bdr")

af2_b3_validate_types <- function(include_types) {
  include_types <- unique(tolower(include_types))
  bad <- setdiff(include_types, af2_b3_allowed_types)
  if (length(bad)) {
    stop(
      "Invalid include_types: ", paste(bad, collapse = ", "),
      ". Allowed: ", paste(af2_b3_allowed_types, collapse = ", ")
    )
  }
  include_types
}



###############################################################################
### FILE: modules/01_b3_universe/R/zzz_depends.R
###############################################################################
# v2/modules/01_b3_universe/R/zzz_depends.R
# Centralized dependency + core imports (NO recursion)

if (!exists("af2_get_config")) {
  stop("af2_get_config not found. Source v2/modules/00_core/R/config.R first.")
}
if (!exists("af2_log")) {
  stop("af2_log not found. Source v2/modules/00_core/R/logging.R first.")
}

# Keep it dumb and safe: no wrapper, no indirection.
af2_b3_require <- function(pkgs) {
  for (p in pkgs) {
    if (!requireNamespace(p, quietly = TRUE)) {
      stop("Missing package: ", p)
    }
  }
  invisible(TRUE)
}

af2_b3_require(c("data.table", "dplyr", "lubridate", "rb3"))

suppressPackageStartupMessages({
  library(data.table)
  library(dplyr)
  library(lubridate)
  library(rb3)
})



###############################################################################
### FILE: modules/01_b3_universe/README.md
###############################################################################
# Module

Purpose:
- Define INPUT contract
- Define OUTPUT contract
- List functions
- List tests



###############################################################################
### FILE: modules/02_diagnostics/README.md
###############################################################################
# Module

Purpose:
- Define INPUT contract
- Define OUTPUT contract
- List functions
- List tests



###############################################################################
### FILE: modules/03_corporate_actions/R/build_registry.R
###############################################################################
# v2/modules/03_corporate_actions/R/build_registry.R

af2_ca_cache_file <- function(cfg, tag = "splits_dividends") {
  cache_dir <- file.path(cfg$cache_dir, "corp_actions")
  if (!dir.exists(cache_dir)) dir.create(cache_dir, recursive = TRUE)
  file.path(cache_dir, paste0("corp_actions_", tag, ".rds"))
}

# Per-symbol cache directory
af2_ca_cache_dir_by_symbol <- function(cfg) {
  d <- file.path(cfg$cache_dir, "corp_actions", "by_symbol")
  if (!dir.exists(d)) dir.create(d, recursive = TRUE)
  d
}

af2_ca_cache_file_symbol <- function(cfg, symbol) {
  symbol <- toupper(trimws(as.character(symbol)))
  file.path(af2_ca_cache_dir_by_symbol(cfg), paste0(symbol, ".rds"))
}

af2_ca_build_registry <- function(symbols,
                                  asset_types = NULL,
                                  cfg = NULL,
                                  from = "2018-01-01",
                                  to = Sys.Date(),
                                  verbose = TRUE,
                                  use_cache = TRUE,
                                  force_refresh = FALSE,
                                  n_workers = 1L,
                                  cache_mode = c("batch", "by_symbol")) {

  cfg <- cfg %||% af2_get_config()
  symbols <- as.character(symbols)
  symbols <- toupper(trimws(symbols))
  symbols <- symbols[!is.na(symbols) & nzchar(symbols)]
  symbols <- sort(unique(symbols))

  cache_mode <- match.arg(cache_mode)

  if (cache_mode == "by_symbol") {
    if (!exists("af2_ca_build_registry_by_symbol")) {
      stop("by_symbol cache_mode requested but af2_ca_build_registry_by_symbol is not defined.",
           call. = FALSE)
    }
    return(
      af2_ca_build_registry_by_symbol(
        symbols = symbols,
        asset_types = asset_types,
        cfg = cfg,
        from = from,
        to = to,
        verbose = verbose,
        use_cache = use_cache,
        force_refresh = force_refresh
      )
    )
  }

  if (!length(symbols)) stop("af2_ca_build_registry: empty symbols.", call. = FALSE)

  af2_ca_require("digest")

  from <- as.Date(from)
  to   <- as.Date(to)

  # Bucket 'to' by week to avoid daily refetch storms in dev
  to_tag   <- as.Date(cut(to, breaks = "week"))
  from_tag <- from

  # symbols is already sorted+unique above
  sym_hash <- digest::digest(symbols, algo = "xxhash64")

  tag <- paste0(
    format(from_tag, "%Y%m%d"), "_",
    format(to_tag, "%Y%m%d"), "_",
    length(symbols), "_",
    sym_hash
  )

  cache_file <- af2_ca_cache_file(cfg, tag)

  if (isTRUE(use_cache) && file.exists(cache_file) && !isTRUE(force_refresh)) {
    if (verbose) af2_log("AF2_CA:", "Using cache: ", cache_file)
    return(readRDS(cache_file))
  }

  yahoo_syms <- af2_yahoo_symbol_vec(symbols, asset_types)
  map_dt <- data.table::data.table(
    symbol = symbols,
    yahoo_symbol = yahoo_syms
  )
  map_dt <- map_dt[!is.na(yahoo_symbol)]

  if (!nrow(map_dt)) {
    stop("af2_ca_build_registry: no Yahoo symbols could be mapped.", call. = FALSE)
  }

  if (verbose) {
    af2_log("AF2_CA:", "Fetching corporate actions for ", nrow(map_dt), " symbols (Yahoo).")
  }

  worker_fun <- function(i) {
    sym <- map_dt$symbol[i]
    ysym <- map_dt$yahoo_symbol[i]

    dt_s <- af2_ca_fetch_splits_one(ysym, from = from, to = to, verbose = FALSE)
    dt_d <- af2_ca_fetch_dividends_one(ysym, from = from, to = to, verbose = FALSE)

    out <- data.table::rbindlist(list(dt_s, dt_d), use.names = TRUE, fill = TRUE)
    if (!nrow(out)) return(NULL)

    out[, symbol := sym]
    out[, yahoo_symbol := ysym]

    out
  }

  res_list <- list()

  n_workers <- as.integer(n_workers)
  if (is.na(n_workers) || n_workers < 1L) n_workers <- 1L

  # Windows-safe optional parallel
  if (n_workers > 1L) {
    af2_ca_require("parallel")

    cl <- parallel::makeCluster(n_workers)
    on.exit(try(parallel::stopCluster(cl), silent = TRUE), add = TRUE)

    parallel::clusterExport(
      cl,
      varlist = c(
        "map_dt",
        "from", "to",
        "af2_ca_fetch_splits_one",
        "af2_ca_fetch_dividends_one",
        "af2_ca_with_retry",
        "af2_ca_is_rate_limit_error",
        "af2_log"
      ),
      envir = environment()
    )
    parallel::clusterEvalQ(cl, {
      library(data.table)
      library(quantmod)
      library(xts)
      library(zoo)
    })

    idx <- seq_len(nrow(map_dt))
    res_list <- parallel::parLapply(cl, idx, worker_fun)

  } else {
    for (i in seq_len(nrow(map_dt))) {
      res_list[[i]] <- worker_fun(i)
      if (verbose && i %% 50 == 0) {
        af2_log("AF2_CA:", "Progress: ", i, "/", nrow(map_dt))
      }
    }
  }

  dt_all <- data.table::rbindlist(res_list, use.names = TRUE, fill = TRUE)

  if (!nrow(dt_all)) {
    # It is valid to have zero actions, but keep schema stable
    dt_all <- data.table::data.table(
      symbol = character(),
      yahoo_symbol = character(),
      refdate = as.Date(character()),
      action_type = character(),
      value = numeric(),
      source = character()
    )
  }

  # Normalize + order
  dt_all[, refdate := as.Date(refdate)]
  dt_all <- dt_all[order(symbol, action_type, refdate)]

  # Basic contract sanity
  req <- c("symbol", "yahoo_symbol", "refdate", "action_type", "value", "source")
  miss <- setdiff(req, names(dt_all))
  if (length(miss)) stop("Corporate actions registry missing cols: ", paste(miss, collapse = ", "))

  if (isTRUE(use_cache)) {
    saveRDS(dt_all, cache_file)
    if (verbose) af2_log("AF2_CA:", "Wrote cache: ", cache_file)
  }

  dt_all
}

af2_ca_build_registry_by_symbol <- function(symbols,
                                            asset_types = NULL,
                                            cfg = NULL,
                                            from = "2018-01-01",
                                            to = Sys.Date(),
                                            verbose = TRUE,
                                            use_cache = TRUE,
                                            force_refresh = FALSE) {

  cfg <- cfg %||% af2_get_config()

  symbols <- as.character(symbols)
  symbols <- toupper(trimws(symbols))
  symbols <- symbols[!is.na(symbols) & nzchar(symbols)]
  symbols <- sort(unique(symbols))

  if (!length(symbols)) {
    stop("af2_ca_build_registry_by_symbol: empty symbols.", call. = FALSE)
  }

  from <- as.Date(from)
  to   <- as.Date(to)

  yahoo_syms <- af2_yahoo_symbol_vec(symbols, asset_types)
  map_dt <- data.table::data.table(
    symbol = symbols,
    yahoo_symbol = yahoo_syms
  )
  map_dt <- map_dt[!is.na(yahoo_symbol)]

  if (!nrow(map_dt)) {
    stop("af2_ca_build_registry_by_symbol: no Yahoo symbols could be mapped.", call. = FALSE)
  }

  if (verbose) {
    af2_log("AF2_CA:", "by_symbol mode: candidates=", nrow(map_dt))
  }

  res_list <- vector("list", nrow(map_dt))

  for (i in seq_len(nrow(map_dt))) {

    sym  <- map_dt$symbol[i]
    ysym <- map_dt$yahoo_symbol[i]

    cache_file <- af2_ca_cache_file_symbol(cfg, sym)

    if (isTRUE(use_cache) && file.exists(cache_file) && !isTRUE(force_refresh)) {
      dt_cached <- readRDS(cache_file)
      dt_cached <- data.table::as.data.table(dt_cached)
      if (nrow(dt_cached)) {
        dt_cached[, refdate := as.Date(refdate)]
        dt_cached <- dt_cached[refdate >= from & refdate <= to]
      }
      res_list[[i]] <- dt_cached
      next
    }

    dt_s <- af2_ca_fetch_splits_one(ysym, from = from, to = to, verbose = FALSE)
    dt_d <- af2_ca_fetch_dividends_one(ysym, from = from, to = to, verbose = FALSE)

    out <- data.table::rbindlist(list(dt_s, dt_d), use.names = TRUE, fill = TRUE)

    if (!nrow(out)) {
      out <- data.table::data.table(
        symbol = character(),
        yahoo_symbol = character(),
        refdate = as.Date(character()),
        action_type = character(),
        value = numeric(),
        source = character()
      )[0]
    } else {
      out[, symbol := sym]
      out[, yahoo_symbol := ysym]
    }

    if (isTRUE(use_cache)) {
      # Save even empty to avoid refetch storms
      saveRDS(out, cache_file)
    }

    res_list[[i]] <- out

    if (verbose && i %% 50 == 0) {
      af2_log("AF2_CA:", "by_symbol progress: ", i, "/", nrow(map_dt))
    }
  }

  dt_all <- data.table::rbindlist(res_list, use.names = TRUE, fill = TRUE)

  if (!nrow(dt_all)) {
    dt_all <- data.table::data.table(
      symbol = character(),
      yahoo_symbol = character(),
      refdate = as.Date(character()),
      action_type = character(),
      value = numeric(),
      source = character()
    )
  }

  dt_all[, refdate := as.Date(refdate)]
  dt_all <- dt_all[order(symbol, action_type, refdate)]

  req <- c("symbol", "yahoo_symbol", "refdate", "action_type", "value", "source")
  miss <- setdiff(req, names(dt_all))
  if (length(miss)) stop("Corporate actions registry missing cols: ", paste(miss, collapse = ", "))

  dt_all
}



###############################################################################
### FILE: modules/03_corporate_actions/R/fetch_dividends_quantmod.R
###############################################################################
# v2/modules/03_corporate_actions/R/fetch_dividends_quantmod.R
source("v2/modules/03_corporate_actions/R/yahoo_retry.R")

af2_ca_fetch_dividends_one <- function(yahoo_symbol,
                                       from = "2018-01-01",
                                       to = Sys.Date(),
                                       verbose = FALSE,
                                       split.adjust = TRUE) {
  if (is.na(yahoo_symbol) || !nzchar(yahoo_symbol)) return(NULL)

  div_fun <- quantmod::getDividends
  fml <- names(formals(div_fun))

  call_args <- list(
    Symbols = yahoo_symbol,
    from = from,
    to = to,
    auto.assign = FALSE,
    verbose = verbose
  )

  if ("split.adjust" %in% fml) {
    call_args$split.adjust <- split.adjust
  }

  x <- af2_ca_with_retry(
    function() do.call(div_fun, call_args),
    max_tries = 4L,
    base_sleep = 1.5,
    verbose = verbose
  )

  if (is.null(x)) return(NULL)
  if (!inherits(x, "xts")) return(NULL)
  if (NROW(x) == 0) return(NULL)

  dt <- data.table::data.table(
    yahoo_symbol = yahoo_symbol,
    refdate = as.Date(zoo::index(x)),
    action_type = "dividend",
    value = as.numeric(zoo::coredata(x)),
    source = "yahoo"
  )

  dt[is.finite(value) & value != 0 & !is.na(refdate)]
}


###############################################################################
### FILE: modules/03_corporate_actions/R/fetch_splits_quantmod.R
###############################################################################
# v2/modules/03_corporate_actions/R/fetch_splits_quantmod.R
source("v2/modules/03_corporate_actions/R/yahoo_retry.R")

af2_ca_fetch_splits_one <- function(yahoo_symbol,
                                    from = "2018-01-01",
                                    to = Sys.Date(),
                                    verbose = FALSE) {
  if (is.na(yahoo_symbol) || !nzchar(yahoo_symbol)) return(NULL)

  x <- af2_ca_with_retry(
    function() {
      quantmod::getSplits(
        yahoo_symbol,
        from = from,
        to = to,
        auto.assign = FALSE,
        verbose = verbose
      )
    },
    max_tries = 4L,
    base_sleep = 1.5,
    verbose = verbose
  )

  # quantmod returns NA if no split data
  if (is.null(x)) return(NULL)
  if (!inherits(x, "xts")) return(NULL)
  if (NROW(x) == 0) return(NULL)
  if (length(x) == 1 && is.na(as.numeric(x))) return(NULL)

  # xts index = date, coredata = ratio
  dt <- data.table::data.table(
    yahoo_symbol = yahoo_symbol,
    refdate = as.Date(zoo::index(x)),
    action_type = "split",
    value = as.numeric(zoo::coredata(x)),
    source = "yahoo"
  )

  dt[is.finite(value) & !is.na(refdate)]
}


###############################################################################
### FILE: modules/03_corporate_actions/R/select_candidates.R
###############################################################################
# v2/modules/03_corporate_actions/R/select_candidates.R

af2_ca_select_candidates <- function(universe_raw, cfg = NULL, verbose = TRUE) {

  af2_require(c("data.table"))
  cfg <- cfg %||% af2_get_config()

  dt <- data.table::as.data.table(universe_raw)

  # Allow either turnover or vol_fin (rb3 differences)
  if (!"turnover" %in% names(dt) && "vol_fin" %in% names(dt)) {
    dt[, turnover := vol_fin]
  }

  # Minimal columns needed for the prefilter
  af2_assert_cols(
    dt,
    c("symbol", "refdate", "close", "turnover", "asset_type"),
    name = "universe_raw(prefilter)"
  )

  # Normalize
  dt[, symbol := toupper(trimws(as.character(symbol)))]
  dt[, asset_type := tolower(trimws(as.character(asset_type)))]
  dt[, refdate := as.Date(refdate)]
  dt[, close := as.numeric(close)]
  dt[, turnover := as.numeric(turnover)]

  # -------------------------------
  # 0) Define recent window
  # -------------------------------
  end_date <- max(dt$refdate, na.rm = TRUE)

  recent_days <- as.integer(cfg$ca_prefilter_recent_days %||% 252L)
  if (!is.finite(recent_days) || recent_days < 20L) recent_days <- 252L

  # Optional tighter liquidity window (new knob; fallback to recent_days)
  liq_window_days <- as.integer(cfg$ca_prefilter_liq_window_days %||% 63L)
  if (!is.finite(liq_window_days) || liq_window_days < 20L) liq_window_days <- min(63L, recent_days)

  # Active trading filter (new knob)
  active_days <- as.integer(cfg$ca_prefilter_active_days %||% 10L)
  if (!is.finite(active_days) || active_days < 1L) active_days <- 10L

  # We approximate "last N bizdays" by date window,
  # since universe_raw already comes from B3 business dates.
  recent_start <- end_date - ceiling(recent_days * 1.6)
  liq_start    <- end_date - ceiling(liq_window_days * 1.6)
  active_start <- end_date - ceiling(active_days * 1.6)

  dt_recent <- dt[refdate >= recent_start & refdate <= end_date]
  data.table::setorder(dt_recent, symbol, refdate)
  dt_recent <- dt_recent[, tail(.SD, recent_days), by = symbol]

  dt_liqwin <- dt[refdate >= liq_start & refdate <= end_date]

  # -------------------------------
  # 1) Active symbols (must trade recently)
  # -------------------------------
  # A "trade" is any day with a finite close
  active_dt <- dt_recent[is.finite(close) & !is.na(close),
                         .(last_trade = max(refdate, na.rm = TRUE)),
                         by = .(symbol, asset_type)]

  active_dt[, is_active := last_trade >= active_start]
  active_syms <- active_dt[is_active == TRUE, unique(symbol)]

  if (verbose) {
    af2_log("AF2_CA_PREF:", "Active symbols= ", length(active_syms))
  }

  # If active filter is too strict in some environments, fail soft
  if (!length(active_syms)) {
    active_syms <- unique(dt_recent$symbol)
  }

  # -------------------------------
  # 2) Liquidity filter (short window)
  # -------------------------------
  dt_liqwin <- dt_liqwin[symbol %in% active_syms]

  dt_liqwin[, traded_flag := is.finite(close) & !is.na(close)]

  liq <- dt_liqwin[, .(
    median_turnover = stats::median(turnover, na.rm = TRUE),
    days_traded_ratio = mean(traded_flag, na.rm = TRUE)
  ), by = .(symbol, asset_type)]

  liq[is.na(median_turnover), median_turnover := 0]
  liq[is.na(days_traded_ratio), days_traded_ratio := 0]

  liq_ok_dt <- liq[
    median_turnover >= (cfg$min_turnover %||% 5e5) &
      days_traded_ratio >= (cfg$min_days_traded_ratio %||% 0.8)
  ]

  liq_ok_syms <- liq_ok_dt$symbol

  if (verbose) {
    af2_log("AF2_CA_PREF:", "Liquidity ok symbols= ", length(unique(liq_ok_syms)))
  }

  # -------------------------------
  # 3) Gap-flag detector (recent window)
  # -------------------------------
  dt_gap <- dt_recent[symbol %in% liq_ok_syms]
  data.table::setorder(dt_gap, symbol, refdate)

  dt_gap[, close_lag := data.table::shift(close, 1L), by = symbol]
  dt_gap[, ret_1d := data.table::fifelse(
    is.finite(close) & is.finite(close_lag) & close_lag > 0,
    close / close_lag - 1,
    NA_real_
  )]
  dt_gap[, close_lag := NULL]

  # Apply per-type thresholds
  thr_map <- data.table::data.table(
    asset_type = c("equity", "fii", "etf", "bdr"),
    thr = c(
      cfg$ca_prefilter_gap_equity %||% -0.20,
      cfg$ca_prefilter_gap_fii    %||% -0.12,
      cfg$ca_prefilter_gap_etf    %||% -0.15,
      cfg$ca_prefilter_gap_bdr    %||% -0.20
    )
  )

  dt_gap <- merge(dt_gap, thr_map, by = "asset_type", all.x = TRUE)

  gap_flags <- dt_gap[
    is.finite(ret_1d) & ret_1d <= thr,
    .(has_gap = TRUE),
    by = .(symbol)
  ]

  gap_syms <- gap_flags$symbol

  if (verbose) {
    af2_log("AF2_CA_PREF:", "Gap-flag symbols= ", length(unique(gap_syms)))
  }

  # -------------------------------
  # 4) Priority ranking source
  # -------------------------------
  # Priority = liquidity rank within liq_ok set
  # (Cheap, robust, and type-aware)
  liq_ok_dt[, liq_rank_overall := data.table::frank(-median_turnover, ties.method = "first")]
  liq_ok_dt[, liq_rank_type := data.table::frank(-median_turnover, ties.method = "first"), by = asset_type]

  top_overall <- as.integer(cfg$ca_prefilter_top_n_overall %||% 200L)
  top_by_type <- as.integer(cfg$ca_prefilter_top_n_by_type %||% 50L)
  max_cand    <- as.integer(cfg$ca_prefilter_max_candidates %||% 300L)

  if (!is.finite(top_overall) || top_overall < 1L) top_overall <- 200L
  if (!is.finite(top_by_type) || top_by_type < 1L) top_by_type <- 50L
  if (!is.finite(max_cand) || max_cand < 50L) max_cand <- 300L

  c1 <- liq_ok_dt[liq_rank_overall <= top_overall, unique(symbol)]
  c2 <- liq_ok_dt[liq_rank_type <= top_by_type, unique(symbol)]

  # -------------------------------
  # 5) Union + cap
  # -------------------------------
  cand_all <- unique(c(c1, c2, gap_syms))

  # If still empty (edge-case data), fall back to liquidity-ok
  if (!length(cand_all)) cand_all <- unique(liq_ok_syms)

  # Apply hard cap using priority order
  if (length(cand_all) > max_cand && nrow(liq_ok_dt)) {
    # Build a priority table for deterministic trimming
    pri <- liq_ok_dt[, .(symbol, priority = liq_rank_overall)]
    pri <- pri[order(priority)]
    pri_syms <- pri$symbol

    # Keep candidate order: priority first, then anything else
    ordered <- unique(c(intersect(pri_syms, cand_all), cand_all))
    cand_all <- head(ordered, max_cand)
  }

  if (verbose) {
    af2_log("AF2_CA_PREF:", "Candidates final= ", length(cand_all))
    #af2_log("AF2_CA_PREF:", "Selective actions enabled= ", isTRUE(cfg$enable_selective_actions))
    #af2_log("AF2_CA_PREF:", "Yahoo candidate symbols= ", length(cand_all))
  }

  cand_all
}



###############################################################################
### FILE: modules/03_corporate_actions/R/yahoo_retry.R
###############################################################################
# v2/modules/03_corporate_actions/R/yahoo_retry.R

af2_ca_is_rate_limit_error <- function(msg) {
  if (is.null(msg) || !nzchar(msg)) return(FALSE)
  grepl("429|Too Many Requests|rate limit", msg, ignore.case = TRUE)
}

af2_ca_with_retry <- function(fun,
                              max_tries = 4L,
                              base_sleep = 1.5,
                              jitter = 0.2,
                              verbose = FALSE) {

  max_tries <- as.integer(max_tries)
  if (is.na(max_tries) || max_tries < 1L) max_tries <- 1L

  for (k in seq_len(max_tries)) {
    out <- tryCatch(fun(), error = function(e) e)

    if (!inherits(out, "error")) return(out)

    msg <- conditionMessage(out)

    # Only backoff if it looks like rate limiting
    if (!af2_ca_is_rate_limit_error(msg)) {
      if (verbose) af2_log("AF2_CA:", "Non-429 error: ", msg)
      return(NULL)
    }

    # Backoff
    if (k < max_tries) {
      sleep_s <- base_sleep * (2^(k - 1))
      sleep_s <- sleep_s * runif(1, 1 - jitter, 1 + jitter)
      if (verbose) {
        af2_log("AF2_CA:", "429 detected. Retry ", k, "/", max_tries,
                " sleeping ~", round(sleep_s, 2), "s")
      }
      Sys.sleep(sleep_s)
    } else {
      if (verbose) af2_log("AF2_CA:", "429 persisted after retries.")
    }
  }

  NULL
}



###############################################################################
### FILE: modules/03_corporate_actions/R/yahoo_symbol_map.R
###############################################################################
# v2/modules/03_corporate_actions/R/yahoo_symbol_map.R

af2_yahoo_symbol <- function(symbol, asset_type = NULL) {
  s <- toupper(trimws(as.character(symbol)))
  if (is.na(s) || !nzchar(s)) return(NA_character_)

  # If user already passed a Yahoo-style symbol, respect it
  if (grepl("\\.", s)) return(s)

  # Most B3 assets on Yahoo use .SA
  # This covers equities, FIIs, ETFs, many BDRs.
  paste0(s, ".SA")
}

af2_yahoo_symbol_vec <- function(symbols, asset_types = NULL) {
  if (is.null(asset_types)) {
    vapply(symbols, af2_yahoo_symbol, character(1))
  } else {
    mapply(af2_yahoo_symbol, symbols, asset_types, USE.NAMES = FALSE)
  }
}


###############################################################################
### FILE: modules/03_corporate_actions/R/zzz_depends.R
###############################################################################
# v2/modules/03_corporate_actions/R/zzz_depends.R

if (!exists("af2_get_config")) {
  stop("af2_get_config not found. Source v2/modules/00_core/R/config.R first.")
}
if (!exists("af2_log")) {
  stop("af2_log not found. Source v2/modules/00_core/R/logging.R first.")
}
if (!exists("%||%")) {
  stop("%||% not found. Source v2/modules/00_core/R/utils.R first.")
}

af2_ca_require <- function(pkgs) {
  for (p in pkgs) {
    if (!requireNamespace(p, quietly = TRUE)) {
      stop("Missing package for corporate actions module: ", p, call. = FALSE)
    }
  }
  invisible(TRUE)
}

# quantmod is the key dependency here
af2_ca_require(c("data.table", "quantmod", "xts"))

suppressPackageStartupMessages({
  library(data.table)
  library(quantmod)
  library(xts)
})



###############################################################################
### FILE: modules/03_corporate_actions/README.md
###############################################################################
# Module

Purpose:
- Define INPUT contract
- Define OUTPUT contract
- List functions
- List tests



###############################################################################
### FILE: modules/03_corporate_actions/codebase_dump_03_corporate_actions.txt
###############################################################################
Project structure for '/c/Users/Galaxy/LEVI/Projetos R/autofinance_R/v2/modules/03_corporate_actions':
===============================================================================
  R/build_registry.R
  R/fetch_dividends_quantmod.R
  R/fetch_splits_quantmod.R
  R/yahoo_symbol_map.R
  R/zzz_depends.R
  README.md



###############################################################################
### FILE: R/build_registry.R
###############################################################################
# v2/modules/03_corporate_actions/R/build_registry.R

af2_ca_cache_file <- function(cfg, tag = "splits_dividends") {
  cache_dir <- file.path(cfg$cache_dir, "corp_actions")
  if (!dir.exists(cache_dir)) dir.create(cache_dir, recursive = TRUE)
  file.path(cache_dir, paste0("corp_actions_", tag, ".rds"))
}

af2_ca_build_registry <- function(symbols,
                                  asset_types = NULL,
                                  cfg = NULL,
                                  from = "2018-01-01",
                                  to = Sys.Date(),
                                  verbose = TRUE,
                                  use_cache = TRUE,
                                  force_refresh = FALSE,
                                  n_workers = 1L) {

  cfg <- cfg %||% af2_get_config()
  symbols <- unique(toupper(trimws(as.character(symbols))))
  symbols <- symbols[!is.na(symbols) & nzchar(symbols)]
  if (!length(symbols)) stop("af2_ca_build_registry: empty symbols.", call. = FALSE)

  tag <- paste0(
    format(as.Date(from), "%Y%m%d"), "_",
    format(as.Date(to), "%Y%m%d"), "_",
    length(symbols)
  )
  cache_file <- af2_ca_cache_file(cfg, tag)

  if (isTRUE(use_cache) && file.exists(cache_file) && !isTRUE(force_refresh)) {
    if (verbose) af2_log("AF2_CA:", "Using cache: ", cache_file)
    return(readRDS(cache_file))
  }

  yahoo_syms <- af2_yahoo_symbol_vec(symbols, asset_types)
  map_dt <- data.table::data.table(
    symbol = symbols,
    yahoo_symbol = yahoo_syms
  )
  map_dt <- map_dt[!is.na(yahoo_symbol)]

  if (!nrow(map_dt)) {
    stop("af2_ca_build_registry: no Yahoo symbols could be mapped.", call. = FALSE)
  }

  if (verbose) {
    af2_log("AF2_CA:", "Fetching corporate actions for ", nrow(map_dt), " symbols (Yahoo).")
  }

  worker_fun <- function(i) {
    sym <- map_dt$symbol[i]
    ysym <- map_dt$yahoo_symbol[i]

    dt_s <- af2_ca_fetch_splits_one(ysym, from = from, to = to, verbose = FALSE)
    dt_d <- af2_ca_fetch_dividends_one(ysym, from = from, to = to, verbose = FALSE)

    out <- data.table::rbindlist(list(dt_s, dt_d), use.names = TRUE, fill = TRUE)
    if (!nrow(out)) return(NULL)

    out[, symbol := sym]
    out[, yahoo_symbol := ysym]

    out
  }

  res_list <- list()

  n_workers <- as.integer(n_workers)
  if (is.na(n_workers) || n_workers < 1L) n_workers <- 1L

  # Windows-safe optional parallel
  if (n_workers > 1L) {
    af2_ca_require("parallel")

    cl <- parallel::makeCluster(n_workers)
    on.exit(try(parallel::stopCluster(cl), silent = TRUE), add = TRUE)

    parallel::clusterExport(
      cl,
      varlist = c(
        "map_dt",
        "from", "to",
        "af2_ca_fetch_splits_one",
        "af2_ca_fetch_dividends_one"
      ),
      envir = environment()
    )
    parallel::clusterEvalQ(cl, {
      library(data.table)
      library(quantmod)
      library(xts)
      library(zoo)
    })

    idx <- seq_len(nrow(map_dt))
    res_list <- parallel::parLapply(cl, idx, worker_fun)

  } else {
    for (i in seq_len(nrow(map_dt))) {
      res_list[[i]] <- worker_fun(i)
      if (verbose && i %% 50 == 0) {
        af2_log("AF2_CA:", "Progress: ", i, "/", nrow(map_dt))
      }
    }
  }

  dt_all <- data.table::rbindlist(res_list, use.names = TRUE, fill = TRUE)

  if (!nrow(dt_all)) {
    # It is valid to have zero actions, but keep schema stable
    dt_all <- data.table::data.table(
      symbol = character(),
      yahoo_symbol = character(),
      refdate = as.Date(character()),
      action_type = character(),
      value = numeric(),
      source = character()
    )
  }

  # Normalize + order
  dt_all[, refdate := as.Date(refdate)]
  dt_all <- dt_all[order(symbol, action_type, refdate)]

  # Basic contract sanity
  req <- c("symbol", "yahoo_symbol", "refdate", "action_type", "value", "source")
  miss <- setdiff(req, names(dt_all))
  if (length(miss)) stop("Corporate actions registry missing cols: ", paste(miss, collapse = ", "))

  if (isTRUE(use_cache)) {
    saveRDS(dt_all, cache_file)
    if (verbose) af2_log("AF2_CA:", "Wrote cache: ", cache_file)
  }

  dt_all
}



###############################################################################
### FILE: R/fetch_dividends_quantmod.R
###############################################################################
# v2/modules/03_corporate_actions/R/fetch_dividends_quantmod.R

af2_ca_fetch_dividends_one <- function(yahoo_symbol,
                                       from = "2018-01-01",
                                       to = Sys.Date(),
                                       verbose = FALSE,
                                       split.adjust = TRUE) {
  if (is.na(yahoo_symbol) || !nzchar(yahoo_symbol)) return(NULL)

  x <- tryCatch(
    quantmod::getDividends(
      yahoo_symbol,
      from = from,
      to = to,
      auto.assign = FALSE,
      verbose = verbose,
      split.adjust = split.adjust
    ),
    error = function(e) {
      if (verbose) af2_log("AF2_CA:", "getDividends failed for ", yahoo_symbol, ": ", conditionMessage(e))
      NULL
    }
  )

  if (is.null(x)) return(NULL)
  if (!inherits(x, "xts")) return(NULL)
  if (NROW(x) == 0) return(NULL)

  dt <- data.table::data.table(
    yahoo_symbol = yahoo_symbol,
    refdate = as.Date(zoo::index(x)),
    action_type = "dividend",
    value = as.numeric(zoo::coredata(x)),
    source = "yahoo"
  )

  dt[is.finite(value) & value != 0 & !is.na(refdate)]
}


###############################################################################
### FILE: R/fetch_splits_quantmod.R
###############################################################################
# v2/modules/03_corporate_actions/R/fetch_splits_quantmod.R

af2_ca_fetch_splits_one <- function(yahoo_symbol,
                                    from = "2018-01-01",
                                    to = Sys.Date(),
                                    verbose = FALSE) {
  if (is.na(yahoo_symbol) || !nzchar(yahoo_symbol)) return(NULL)

  x <- tryCatch(
    quantmod::getSplits(
      yahoo_symbol,
      from = from,
      to = to,
      auto.assign = FALSE,
      verbose = verbose
    ),
    error = function(e) {
      if (verbose) af2_log("AF2_CA:", "getSplits failed for ", yahoo_symbol, ": ", conditionMessage(e))
      NULL
    }
  )

  # quantmod returns NA if no split data
  if (is.null(x)) return(NULL)
  if (length(x) == 1 && is.na(as.numeric(x))) return(NULL)
  if (!inherits(x, "xts")) return(NULL)

  # xts index = date, coredata = ratio
  dt <- data.table::data.table(
    yahoo_symbol = yahoo_symbol,
    refdate = as.Date(zoo::index(x)),
    action_type = "split",
    value = as.numeric(zoo::coredata(x)),
    source = "yahoo"
  )

  dt[is.finite(value) & !is.na(refdate)]
}


###############################################################################
### FILE: R/yahoo_symbol_map.R
###############################################################################
# v2/modules/03_corporate_actions/R/yahoo_symbol_map.R

af2_yahoo_symbol <- function(symbol, asset_type = NULL) {
  s <- toupper(trimws(as.character(symbol)))
  if (is.na(s) || !nzchar(s)) return(NA_character_)

  # If user already passed a Yahoo-style symbol, respect it
  if (grepl("\\.", s)) return(s)

  # Most B3 assets on Yahoo use .SA
  # This covers equities, FIIs, ETFs, many BDRs.
  paste0(s, ".SA")
}

af2_yahoo_symbol_vec <- function(symbols, asset_types = NULL) {
  if (is.null(asset_types)) {
    vapply(symbols, af2_yahoo_symbol, character(1))
  } else {
    mapply(af2_yahoo_symbol, symbols, asset_types, USE.NAMES = FALSE)
  }
}


###############################################################################
### FILE: R/zzz_depends.R
###############################################################################
# v2/modules/03_corporate_actions/R/zzz_depends.R

if (!exists("af2_get_config")) {
  stop("af2_get_config not found. Source v2/modules/00_core/R/config.R first.")
}
if (!exists("af2_log")) {
  stop("af2_log not found. Source v2/modules/00_core/R/logging.R first.")
}
if (!exists("%||%")) {
  stop("%||% not found. Source v2/modules/00_core/R/utils.R first.")
}

af2_ca_require <- function(pkgs) {
  for (p in pkgs) {
    if (!requireNamespace(p, quietly = TRUE)) {
      stop("Missing package for corporate actions module: ", p, call. = FALSE)
    }
  }
  invisible(TRUE)
}

# quantmod is the key dependency here
af2_ca_require(c("data.table", "quantmod", "xts"))

suppressPackageStartupMessages({
  library(data.table)
  library(quantmod)
  library(xts)
})



###############################################################################
### FILE: README.md
###############################################################################
# Module

Purpose:
- Define INPUT contract
- Define OUTPUT contract
- List functions
- List tests






###############################################################################
### FILE: modules/04_adjuster/R/apply_adjustments.R
###############################################################################
# v2/modules/04_adjuster/R/apply_adjustments.R

# Helper: reverse cumulative product excluding same-day event.
# For a vector of daily event factors:
# factor(date) = product of event_factors for events with refdate > date
af2_adj_rev_cumprod_exclusive <- function(x) {
  if (!length(x)) return(x)
  v <- rev(cumprod(rev(x)))
  data.table::shift(v, 1L, type = "lead", fill = 1)
}

# Compute adjustments for one symbol
af2_adj_compute_symbol_adjustments <- function(dt_sym, ev_sym) {
  dt <- data.table::as.data.table(dt_sym)
  data.table::setorder(dt, refdate)

  # Universe raw contract minimum for adjuster
  af2_assert_cols(dt,
                  c("symbol", "refdate", "open", "high", "low", "close",
                    "turnover", "qty", "asset_type"),
                  name = "universe_raw(symbol)")

  # Prep event table for this symbol
  ev <- data.table::as.data.table(ev_sym)
  if (!nrow(ev)) {
    ev <- data.table(
      symbol = unique(dt$symbol)[1],
      refdate = as.Date(character()),
      split_value = numeric(),
      div_cash = numeric(),
      source_mask = character(),
      has_manual = logical()
    )
  }

  # Join events onto daily grid
  dt[, split_value := 1]
  dt[, div_cash := 0]
  dt[, source_mask := "none"]
  dt[, has_manual := FALSE]

  if (nrow(ev)) {
    dt[ev, on = .(symbol, refdate),
       `:=`(
         split_value = i.split_value,
         div_cash = i.div_cash,
         source_mask = i.source_mask,
         has_manual = i.has_manual
       )]
  }

  dt[is.na(split_value), split_value := 1]
  dt[is.na(div_cash), div_cash := 0]
  dt[is.na(source_mask), source_mask := "none"]
  dt[is.na(has_manual), has_manual := FALSE]

  # -----------------------
  # 1) Split cumulative factor
  # -----------------------
  dt[, split_factor_cum := af2_adj_rev_cumprod_exclusive(split_value)]

  # Apply split adjustment to OHLC
  dt[, open_adj_split  := open  * split_factor_cum]
  dt[, high_adj_split  := high  * split_factor_cum]
  dt[, low_adj_split   := low   * split_factor_cum]
  dt[, close_adj_split := close * split_factor_cum]

  # -----------------------
  # 2) Dividend event factor
  # -----------------------
  dt[, close_prev := data.table::shift(close_adj_split, 1L)]

  # Default no-dividend factor
  dt[, div_factor_event := 1]

  # Flag issues when we cannot compute a sane dividend factor
  dt[, issue_div := FALSE]

  has_div_row <- dt$div_cash > 0

  if (any(has_div_row, na.rm = TRUE)) {
    # bad cases
    bad_idx <- which(
      has_div_row & (
        !is.finite(dt$close_prev) |
          is.na(dt$close_prev) |
          dt$close_prev <= 0 |
          dt$div_cash >= dt$close_prev
      )
    )
    if (length(bad_idx)) dt[bad_idx, issue_div := TRUE]

    # good cases
    good_idx <- which(
      has_div_row &
        is.finite(dt$close_prev) &
        !is.na(dt$close_prev) &
        dt$close_prev > 0 &
        dt$div_cash < dt$close_prev
    )

    if (length(good_idx)) {
      dt[good_idx,
         div_factor_event := (close_prev - div_cash) / close_prev]
    }
  }

  # Guarantee numeric stability
  dt[!is.finite(div_factor_event) | is.na(div_factor_event), div_factor_event := 1]
  dt[div_factor_event < 0, div_factor_event := 0]

  # -----------------------
  # 3) Dividend cumulative factor
  # -----------------------
  dt[, div_factor_cum := af2_adj_rev_cumprod_exclusive(div_factor_event)]

  # -----------------------
  # 4) Final factor + apply
  # -----------------------
  dt[, adj_factor_final := split_factor_cum * div_factor_cum]

  dt[, open_adj_final  := open  * adj_factor_final]
  dt[, high_adj_final  := high  * adj_factor_final]
  dt[, low_adj_final   := low   * adj_factor_final]
  dt[, close_adj_final := close * adj_factor_final]

  # Prepare adjustment timeline output for auditing
  adj_timeline <- dt[, .(
    symbol,
    refdate,
    split_value,
    div_cash,
    split_factor_cum,
    div_factor_event,
    div_factor_cum,
    adj_factor_final,
    source_mask,
    has_manual,
    issue_div
  )]

  list(
    panel_cols = dt,
    adjustments = adj_timeline
  )
}

# Apply adjustments to full universe_raw
# Returns:
#   list(panel_adj = ..., adjustments = ...)
af2_adj_apply_adjustments <- function(universe_raw,
                                      events,
                                      verbose = TRUE) {

  dt <- data.table::as.data.table(universe_raw)
  data.table::setorder(dt, symbol, refdate)

  ev <- data.table::as.data.table(events)
  if (!nrow(ev)) {
    ev <- data.table(
      symbol = character(),
      refdate = as.Date(character()),
      split_value = numeric(),
      div_cash = numeric(),
      source_mask = character(),
      has_manual = logical()
    )
  }

  syms <- unique(dt$symbol)

  res_pan <- vector("list", length(syms))
  res_adj <- vector("list", length(syms))

  for (i in seq_along(syms)) {
    s <- syms[i]

    dt_sym <- dt[symbol == s]
    ev_sym <- ev[symbol == s]

    out <- af2_adj_compute_symbol_adjustments(dt_sym, ev_sym)

    res_pan[[i]] <- out$panel_cols
    res_adj[[i]] <- out$adjustments

    if (verbose && i %% 200 == 0) {
      af2_log("AF2_ADJ:", "Progress ", i, "/", length(syms))
    }
  }

  panel_all <- data.table::rbindlist(res_pan, use.names = TRUE, fill = TRUE)
  adj_all   <- data.table::rbindlist(res_adj, use.names = TRUE, fill = TRUE)

  data.table::setorder(panel_all, symbol, refdate)
  data.table::setorder(adj_all, symbol, refdate)

  list(panel_adj = panel_all, adjustments = adj_all)
}



###############################################################################
### FILE: modules/04_adjuster/R/build_adjustments.R
###############################################################################
# v2/modules/04_adjuster/R/build_adjustments.R

# Build normalized event table for the adjuster.
# Input corp_actions contract (from Module 03):
#   symbol, yahoo_symbol, refdate, action_type, value, source
#
# Output event table:
#   symbol, refdate, split_value, div_cash, source_mask, has_manual

af2_adj_normalize_corp_actions <- function(corp_actions, cfg = NULL) {
  cfg <- cfg %||% af2_get_config()
  if (is.null(corp_actions)) {
    return(data.table(
      symbol = character(),
      refdate = as.Date(character()),
      action_type = character(),
      value = numeric(),
      source = character()
    ))
  }

  dt <- data.table::as.data.table(corp_actions)

  # Allow either registry schema with yahoo_symbol or not
  if ("yahoo_symbol" %in% names(dt)) dt[, yahoo_symbol := NULL]

  # Basic required
  af2_assert_cols(dt, c("symbol", "refdate", "action_type", "value", "source"),
                  name = "corp_actions")

  dt[, symbol := toupper(trimws(as.character(symbol)))]
  dt[, action_type := tolower(trimws(as.character(action_type)))]
  dt[, refdate := as.Date(refdate)]
  dt[, value := as.numeric(value)]
  dt[, source := tolower(trimws(as.character(source)))]

  dt <- dt[!is.na(symbol) & nzchar(symbol) & !is.na(refdate)]
  dt <- dt[action_type %in% c("split", "dividend")]
  # Yahoo/quantmod getSplits() appears to return
  # PRICE FACTORS already (1/ratio).
  # We keep values as-is and only validate positivity.
  # --------------------------------------------
  # Yahoo/quantmod getSplits() appears to already
  # return PRICE FACTORS (1/ratio).
  # So we do NOT invert here.
  # --------------------------------------------
  # getSplits() may return ratio OR price factor depending on the symbol/market feed.
  # We keep values as-is here.
  # Orientation is validated later by split-gap logic when enabled.

  # Keep only valid positive numeric values.
  dt[action_type == "split" & (!is.finite(value) | value <= 0),
     value := NA_real_]

  dt <- dt[is.na(value) == FALSE]

  dt
}

af2_adj_normalize_manual_events <- function(manual_events, cfg = NULL) {
  cfg <- cfg %||% af2_get_config()
  if (is.null(manual_events)) {
    return(data.table(
      symbol = character(),
      refdate = as.Date(character()),
      action_type = character(),
      value = numeric(),
      source = character()
    ))
  }

  dt <- data.table::as.data.table(manual_events)

  af2_assert_cols(dt, c("symbol", "refdate", "action_type", "value"),
                  name = "manual_events")

  if (!"source" %in% names(dt)) dt[, source := "manual"]

  dt[, symbol := toupper(trimws(as.character(symbol)))]
  dt[, action_type := tolower(trimws(as.character(action_type)))]
  dt[, refdate := as.Date(refdate)]
  dt[, value := as.numeric(value)]
  dt[, source := "manual"]

  dt <- dt[!is.na(symbol) & nzchar(symbol) & !is.na(refdate)]
  dt <- dt[action_type %in% c("split", "dividend")]
  # Manual convention in v2:
  # store split values as PRICE FACTORS
  # consistent with Yahoo (1/ratio).
  dt[action_type == "split" & (!is.finite(value) | value <= 0),
     value := NA_real_]

  dt <- dt[is.na(value) == FALSE]

  dt
}

af2_adj_build_events <- function(corp_actions,
                                 manual_events = NULL,
                                 cfg = NULL,
                                 verbose = TRUE) {

  cfg <- cfg %||% af2_get_config()

  ca <- af2_adj_normalize_corp_actions(corp_actions, cfg = cfg)
  me <- af2_adj_normalize_manual_events(manual_events, cfg = cfg)

  dt_all <- data.table::rbindlist(list(ca, me), use.names = TRUE, fill = TRUE)
  if (!nrow(dt_all)) {
    return(data.table(
      symbol = character(),
      refdate = as.Date(character()),
      split_value = numeric(),
      div_cash = numeric(),
      source_mask = character(),
      has_manual = logical()
    ))
  }

  # ------------------------------------------------------------
  # Optional Yahoo split plausibility gate (quarantine, not edit)
  # Applies ONLY to Yahoo-sourced split rows before aggregation.
  # ------------------------------------------------------------
  if (isTRUE(cfg$enable_split_plausibility_gate)) {

    minv <- as.numeric(cfg$split_gate_min %||% 0.05)
    maxv <- as.numeric(cfg$split_gate_max %||% 20)

    if (!is.finite(minv) || minv <= 0) minv <- 0.05
    if (!is.finite(maxv) || maxv <= 0) maxv <- 20

    bad_splits <- dt_all[
      action_type == "split" &
        source == "yahoo" &
        (value < minv | value > maxv)
    ]

    if (nrow(bad_splits) && verbose) {
      af2_log("AF2_ADJ:",
              "Split gate active. Quarantining ", nrow(bad_splits),
              " Yahoo split rows outside [", minv, ", ", maxv, "].")
      # Print a small sample for visibility
      print(utils::head(bad_splits[order(symbol, refdate)], 10))
    }

    # Drop only the suspicious Yahoo split rows from factor construction
    if (nrow(bad_splits)) {
      dt_all <- dt_all[!(
        action_type == "split" &
          source == "yahoo" &
          (value < minv | value > maxv)
      )]
    }
  }

  # Aggregate same-day events:
  # - splits: multiply price factors
  # - dividends: sum cash amounts
  splits <- dt_all[action_type == "split",
                   .(split_value = prod(value, na.rm = TRUE),
                     source_mask = paste(sort(unique(source)), collapse = "+")),
                   by = .(symbol, refdate)]

  divs <- dt_all[action_type == "dividend",
                 .(div_cash = sum(value, na.rm = TRUE),
                   source_mask_div = paste(sort(unique(source)), collapse = "+")),
                 by = .(symbol, refdate)]

  # Merge into unified event table
  ev <- merge(
    splits, divs,
    by = c("symbol", "refdate"),
    all = TRUE
  )

  ev[is.na(split_value), split_value := 1]
  ev[is.na(div_cash), div_cash := 0]

  # Compose source mask
  ev[, source_mask := fifelse(
    !is.na(source_mask) & !is.na(source_mask_div),
    paste0(source_mask, "+", source_mask_div),
    fifelse(!is.na(source_mask), source_mask, source_mask_div)
  )]
  ev[is.na(source_mask), source_mask := "unknown"]

  ev[, c("source_mask_div") := NULL]

  ev[, has_manual := grepl("manual", source_mask)]

  # Clean obvious nonsense
  ev <- ev[!is.na(symbol) & nzchar(symbol) & !is.na(refdate)]
  ev <- ev[is.finite(split_value) & split_value > 0]
  ev <- ev[is.finite(div_cash) & div_cash >= 0]

  if (verbose) {
    af2_log("AF2_ADJ:", "Built events: ", nrow(ev), " rows for ",
            length(unique(ev$symbol)), " symbols.")
  }

  data.table::setorder(ev, symbol, refdate)
  ev
}



###############################################################################
### FILE: modules/04_adjuster/R/build_panel_adj.R
###############################################################################
# v2/modules/04_adjuster/R/build_panel_adj.R

# High-level builder:
#   universe_raw (Module 01 output)
#   corp_actions (Module 03 output)
#   manual_events (optional)
#
# Returns:
#   list(panel_adj = ..., adjustments = ..., events = ...)

af2_build_panel_adj <- function(universe_raw,
                                corp_actions = NULL,
                                manual_events = NULL,
                                cfg = NULL,
                                verbose = TRUE) {

  cfg <- cfg %||% af2_get_config()

  dt <- data.table::as.data.table(universe_raw)

  # Strict universe column expectations for v2
  af2_assert_cols(
    dt,
    c("symbol", "refdate", "open", "high", "low", "close",
      "turnover", "qty", "asset_type"),
    name = "universe_raw"
  )

  dt[, symbol := toupper(trimws(as.character(symbol)))]
  dt[, refdate := as.Date(refdate)]

  # ------------------------------------------------------------------
  # Defensive dedupe (rb3 edge cases)
  # We keep the first row per symbol/refdate after ordering.
  # This prevents hard failures on occasional upstream duplicates.
  # ------------------------------------------------------------------
  data.table::setorder(dt, asset_type, symbol, refdate)

  dup_check <- dt[, .N, by = .(symbol, refdate)][N > 1L]
  if (nrow(dup_check)) {
    af2_log(
      "AF2_ADJ:",
      "WARNING: universe_raw had duplicated symbol/refdate rows. ",
      "Examples: ",
      paste(utils::head(paste0(dup_check$symbol, "@", dup_check$refdate), 5), collapse = ", "),
      ". Keeping first row per key."
    )
    dt <- dt[, .SD[1L], by = .(symbol, refdate)]
  }


  af2_assert_no_dupes(dt, c("symbol", "refdate"), name = "universe_raw")

  # 1) Build event table (split_value + div_cash per symbol-date)
  events <- af2_adj_build_events(
    corp_actions = if (isTRUE(cfg$enable_splits)) corp_actions else NULL,
    manual_events = if (isTRUE(cfg$enable_manual_events)) manual_events else NULL,
    cfg = cfg,
    verbose = verbose
  )

  # 2) Apply adjustments
  out <- af2_adj_apply_adjustments(
    universe_raw = dt,
    events = events,
    verbose = verbose
  )

  panel <- out$panel_adj
  adj_tl <- out$adjustments

  # 3) Add raw aliases for clarity/audit
  panel[, `:=`(
    open_raw = open,
    high_raw = high,
    low_raw  = low,
    close_raw = close
  )]

  # 4) Compute adjustment_state per symbol (research-grade honesty)
  # We base this on:
  # - presence of split/dividend events
  # - whether manual was involved
  # - whether dividend computation had issues

  # Restrict event flags to the panel date range for state semantics
  panel_min <- min(panel$refdate, na.rm = TRUE)
  panel_max <- max(panel$refdate, na.rm = TRUE)

  events_state <- events[
    refdate >= panel_min & refdate <= panel_max
  ]
  
  ev_flags <- if (nrow(events_state)) {
    events_state[, .(
      has_split = any(is.finite(split_value) & split_value != 1),
      has_div   = any(is.finite(div_cash) & div_cash > 0),
      has_manual = any(isTRUE(has_manual))
    ), by = symbol]
  } else {
    data.table(symbol = unique(panel$symbol),
               has_split = FALSE, has_div = FALSE, has_manual = FALSE)
  }

  issue_flags <- adj_tl[, .(
    issue_div_any = any(isTRUE(issue_div))
  ), by = symbol]

  state_dt <- merge(ev_flags, issue_flags, by = "symbol", all = TRUE)
  state_dt[is.na(has_split), has_split := FALSE]
  state_dt[is.na(has_div), has_div := FALSE]
  state_dt[is.na(has_manual), has_manual := FALSE]
  state_dt[is.na(issue_div_any), issue_div_any := FALSE]

  state_dt[, adjustment_state := fifelse(
    issue_div_any, "suspect_unresolved",
    fifelse(
      has_manual, "manual_override",
      fifelse(
        has_split & has_div, "split_dividend",
        fifelse(
          has_split, "split_only",
          fifelse(
            has_div, "dividend_only",
            "ok"
          )
        )
      )
    )
  )]

  panel[state_dt, on = "symbol", adjustment_state := i.adjustment_state]

  # 5) Final column cleanup ordering
  keep_cols <- c(
    "symbol", "refdate", "asset_type",
    "open_raw", "high_raw", "low_raw", "close_raw",
    "open_adj_split", "high_adj_split", "low_adj_split", "close_adj_split",
    "open_adj_final", "high_adj_final", "low_adj_final", "close_adj_final",
    "turnover", "qty",
    "adjustment_state"
  )

  # Some columns may be missing if upstream had NA open/high/low;
  # preserve everything but move preferred cols to front.
  present_keep <- intersect(keep_cols, names(panel))
  other_cols <- setdiff(names(panel), present_keep)
  data.table::setcolorder(panel, c(present_keep, other_cols))

  if (verbose) {
    af2_log("AF2_ADJ:", "panel_adj rows = ", nrow(panel))
    af2_log("AF2_ADJ:", "symbols = ", length(unique(panel$symbol)))
    af2_log("AF2_ADJ:", "states:")
    print(panel[, .N, by = adjustment_state][order(-N)])
  }

  list(
    panel_adj = panel,
    adjustments = adj_tl,
    events = events
  )
}



###############################################################################
### FILE: modules/04_adjuster/R/build_panel_adj_selective.R
###############################################################################
# v2/modules/04_adjuster/R/build_panel_adj_selective.R
# High-level wrapper implementing the selective Yahoo "trick".

# ------------------------------------------------------------
# Split-gap validator + snapper for Yahoo splits
# - snaps split refdate forward to next trading day (<= max_fwd_days)
# - normalizes Yahoo split "value" orientation (ratio vs price-factor)
# - rejects splits that do not match raw jump (within tol_log)
# - returns BOTH: cleaned corp_actions + split_audit table
# ------------------------------------------------------------
af2_ca_fix_yahoo_splits_by_raw_gap <- function(corp_actions,
                                               universe_raw,
                                               cfg = NULL,
                                               verbose = TRUE) {

  cfg <- cfg %||% af2_get_config()

  ca <- data.table::as.data.table(corp_actions)
  dt <- data.table::as.data.table(universe_raw)

  if (!nrow(ca)) {
    return(list(corp_actions = ca, split_audit = NULL))
  }
  if (!nrow(dt)) {
    return(list(corp_actions = ca, split_audit = NULL))
  }

  af2_assert_cols(ca, c("symbol","refdate","action_type","value","source"), name = "corp_actions")
  af2_assert_cols(dt, c("symbol","refdate","open","close"), name = "universe_raw")

  # normalize
  ca[, symbol := toupper(trimws(as.character(symbol)))]
  ca[, action_type := tolower(trimws(as.character(action_type)))]
  ca[, source := tolower(trimws(as.character(source)))]
  ca[, refdate := as.Date(refdate)]
  ca[, value := as.numeric(value)]

  dt[, symbol := toupper(trimws(as.character(symbol)))]
  dt[, refdate := as.Date(refdate)]
  dt[, open := as.numeric(open)]
  dt[, close := as.numeric(close)]

  # Only Yahoo split rows are validated/snapped
  ys <- ca[
    action_type == "split" &
      source == "yahoo" &
      is.finite(value) & value > 0 &
      !is.na(refdate)
  ]

  if (!nrow(ys)) {
    return(list(corp_actions = ca, split_audit = data.table::data.table()[0]))
  }

  # knobs
  tol <- as.numeric(cfg$split_gap_tol_log %||% 0.35)
  if (!is.finite(tol) || tol <= 0) tol <- 0.35

  max_fwd <- as.integer(cfg$split_gap_max_forward_days %||% 0L)
  if (!is.finite(max_fwd) || max_fwd < 0L) max_fwd <- 0L

  use_open <- isTRUE(cfg$split_gap_use_open %||% FALSE)

  # prep raw grid (keyed) + prev close
  data.table::setorder(dt, symbol, refdate)
  data.table::setkey(dt, symbol, refdate)
  dt[, close_prev := data.table::shift(close, 1L), by = symbol]

  # create a per-row id so audit is stable
  ys_key <- ys[, .(
    row_id = .I,
    symbol,
    vendor_refdate = refdate,
    yahoo_value = value,
    yahoo_symbol = if ("yahoo_symbol" %in% names(ys)) as.character(yahoo_symbol) else NA_character_
  )]
  data.table::setkey(ys_key, symbol, vendor_refdate)

  # snap vendor_refdate -> next trading refdate (<= max_fwd days)
  # roll = -N rolls forward (next observation) up to N days
  snapped <- dt[ys_key,
    on      = .(symbol, refdate = vendor_refdate),
    roll    = -max_fwd,
    nomatch = NA,
    .(
      row_id         = i.row_id,
      symbol         = i.symbol,
      yahoo_symbol   = i.yahoo_symbol,
      vendor_refdate = i.vendor_refdate,
      eff_refdate    = refdate,
      lag_days       = as.integer(refdate - i.vendor_refdate),
      open           = open,
      close          = close,
      close_prev     = close_prev,
      yahoo_value    = i.yahoo_value
    )
  ]

  safe_log <- function(x) ifelse(is.finite(x) & x > 0, log(x), NA_real_)

  # observed raw ratios (post/pre)
  snapped[, ratio_cc := data.table::fifelse(
    is.finite(close) & is.finite(close_prev) & close_prev > 0,
    close / close_prev,
    NA_real_
  )]

  snapped[, ratio_oc := data.table::fifelse(
    use_open & is.finite(open) & is.finite(close_prev) & close_prev > 0,
    open / close_prev,
    NA_real_
  )]

  snapped[, log_v   := safe_log(yahoo_value)]
  snapped[, log_inv := safe_log(1 / yahoo_value)]
  snapped[, log_cc  := safe_log(ratio_cc)]
  snapped[, log_oc  := safe_log(ratio_oc)]

  # errors for two hypotheses:
  # Hval: yahoo_value already equals PRICE RATIO (price factor)
  # Hinv: 1/yahoo_value equals PRICE RATIO (yahoo_value is split "ratio")
  snapped[, err_val := abs(log_cc - log_v)]
  if (use_open) snapped[, err_val := pmin(err_val, abs(log_oc - log_v), na.rm = TRUE)]

  snapped[, err_inv := abs(log_cc - log_inv)]
  if (use_open) snapped[, err_inv := pmin(err_inv, abs(log_oc - log_inv), na.rm = TRUE)]

  snapped[, chosen_value := data.table::fifelse(err_inv < err_val, 1 / yahoo_value, yahoo_value)]
  snapped[, chosen_err   := pmin(err_val, err_inv, na.rm = TRUE)]

  # validity
  snapped[, has_prices := is.finite(chosen_err) & !is.na(chosen_err)]
  snapped[, is_snapped := !is.na(eff_refdate) & is.finite(lag_days) & lag_days >= 0 & lag_days <= max_fwd]

  snapped[, status := data.table::fifelse(
    !is_snapped | !has_prices, "unverified",
    data.table::fifelse(chosen_err <= tol, "kept", "rejected")
  )]

  split_audit <- snapped[, .(
    symbol, yahoo_symbol,
    vendor_refdate, eff_refdate, lag_days,
    yahoo_value,
    chosen_value,
    chosen_err,
    status
  )]

  # apply changes:
  # - kept: snap refdate -> eff_refdate, normalize value -> chosen_value
  # - rejected: drop split row
  # - unverified: keep as-is (do NOT drop; do NOT change)
  kept <- snapped[status == "kept" & is_snapped == TRUE & has_prices == TRUE]
  rej  <- snapped[status == "rejected"]  # keep for audit/log only; NEVER delete vendor rows

  if (verbose) {
    af2_log(
      "AF2_CA_PREF:",
      "Split-gap validation: snapped= ", nrow(snapped),
      "  kept= ", nrow(kept),
      "  rejected= ", nrow(rej),
      "  unverified= ", sum(split_audit$status == "unverified"),
      "  (tol_log= ", tol,
      " , max_fwd_days= ", max_fwd,
      " , use_open= ", use_open, " )"
    )
  }

  list(corp_actions = ca, split_audit = split_audit)
}

af2_build_panel_adj_selective <- function(universe_raw,
                                          manual_events = NULL,
                                          cfg = NULL,
                                          from_ca = "2018-01-01",
                                          to_ca = Sys.Date(),
                                          verbose = TRUE,
                                          use_cache = TRUE,
                                          force_refresh = FALSE,
                                          n_workers = 1L,
                                          force_symbols = NULL
                                          ) {

  cfg <- cfg %||% af2_get_config()

  dt <- data.table::as.data.table(universe_raw)
  af2_assert_cols(
    dt,
    c("symbol", "refdate", "open", "high", "low", "close", "turnover", "qty", "asset_type"),
    name = "universe_raw"
  )

  # 1) Decide candidate symbols for Yahoo actions
  if (isTRUE(cfg$enable_selective_actions)) {
    cand <- af2_ca_select_candidates(
      universe_raw = dt,
      cfg = cfg,
      verbose = verbose
    )
  } else {
    cand <- sort(unique(toupper(dt$symbol)))
  }

  if (verbose) {
    af2_log("AF2_CA_PREF:", "Selective actions enabled=", isTRUE(cfg$enable_selective_actions))
    af2_log("AF2_CA_PREF:", "Yahoo candidate symbols=", length(cand))
  }

  # -------------------------------
  # PATCH: allow explicit forced symbols
  # -------------------------------
  if (!is.null(force_symbols)) {
    force_symbols <- toupper(trimws(as.character(force_symbols)))
    force_symbols <- force_symbols[!is.na(force_symbols) & nzchar(force_symbols)]
    cand <- sort(unique(c(cand, force_symbols)))
  }

  # 2) Fetch registry ONLY for candidates
  ca <- NULL
  if (length(cand)) {
    ca <- af2_ca_build_registry(
      symbols = cand,
      asset_types = NULL,
      cfg = cfg,
      from = from_ca,
      to = to_ca,
      verbose = verbose,
      use_cache = use_cache,
      force_refresh = force_refresh,
      n_workers = n_workers,
      cache_mode = cfg$ca_cache_mode %||% "batch"
    )
  }

  ca_vendor_raw <- if (!is.null(ca)) data.table::copy(ca) else ca

  # -------------------------------
  # PATCH D2: reconcile Yahoo split conventions
  # against Cotahist raw gaps (auto-orient + drop)
  # -------------------------------
  split_audit <- NULL
  
  if (!is.null(ca) && nrow(ca) &&
      isTRUE(cfg$enable_split_gap_validation)) {
  
    fix <- af2_ca_fix_yahoo_splits_by_raw_gap(
      corp_actions = ca,
      universe_raw = dt,
      cfg = cfg,
      verbose = verbose
    )
  
    ca <- fix$corp_actions
    split_audit <- fix$split_audit
  }
  
  # (optional but highly recommended sanity log)
  if (verbose) {
    if (is.null(ca) || !nrow(ca)) {
      af2_log("AF2_CA_PREF:", "corp_actions AFTER validation is EMPTY -> panel will be unadjusted.")
    } else {
      af2_log("AF2_CA_PREF:", "corp_actions AFTER validation rows= ", nrow(ca))
      print(ca[, .N, by = .(action_type, source)][order(-N)])
    }
  }

  # ------------------------------------------------------------
  # POLICY: DO NOT auto-apply unverified/rejected Yahoo splits.
  # We keep vendor registry (ca) intact, but pass only "kept"
  # Yahoo split rows into the adjuster.
  # ------------------------------------------------------------
  ca_apply <- ca
  ca_quarantine <- NULL

  if (!is.null(ca_apply) && nrow(ca_apply) &&
      !is.null(split_audit) && nrow(split_audit)) {

    kept_keys <- split_audit[
      status == "kept" & !is.na(eff_refdate),
      .(symbol, refdate = eff_refdate)
    ]

    ys_all <- ca_apply[action_type == "split" & source == "yahoo"]

    ys_kept <- ys_all[kept_keys, on = .(symbol, refdate), nomatch = 0L]
    ca_quarantine <- ys_all[!kept_keys, on = .(symbol, refdate)]

    ca_apply <- data.table::rbindlist(
      list(
        ca_apply[!(action_type == "split" & source == "yahoo")],
        ys_kept
      ),
      use.names = TRUE, fill = TRUE
    )

    ca_apply <- unique(ca_apply)

    if (verbose) {
      af2_log(
        "AF2_CA_PREF:",
        "Yahoo split apply policy: kept=", nrow(ys_kept),
        " quarantine=", if (is.null(ca_quarantine)) 0L else nrow(ca_quarantine)
      )
    }
  }

  # 3) Run the normal adjuster builder
  out <- af2_build_panel_adj(
    universe_raw = dt,
    corp_actions = ca_apply,
    manual_events = manual_events,
    cfg = cfg,
    verbose = verbose
  )

  # Attach audit + quarantine (can be NULL if validation disabled)
  out$split_audit <- split_audit
  out$corp_actions_apply <- ca_apply
  out$corp_actions_quarantine <- ca_quarantine
  out
}



###############################################################################
### FILE: modules/04_adjuster/R/validate_panel_adj.R
###############################################################################
# v2/modules/04_adjuster/R/validate_panel_adj.R

af2_validate_panel_adj <- function(panel_adj) {

  af2_require(c("data.table"))

  af2_assert_cols(
    panel_adj,
    c("symbol", "refdate", "close_adj_final", "asset_type", "adjustment_state"),
    name = "panel_adj"
  )

  dt <- data.table::as.data.table(panel_adj)
  dt[, refdate := as.Date(refdate)]

  # Must have liquidity column for screener use
  has_turnover <- "turnover" %in% names(dt)
  has_vol_fin  <- "vol_fin" %in% names(dt)
  if (!has_turnover && !has_vol_fin) {
    stop("panel_adj must contain 'turnover' or 'vol_fin'.", call. = FALSE)
  }

  # No duplicate symbol-date
  af2_assert_no_dupes(dt, c("symbol", "refdate"), name = "panel_adj")

  invisible(TRUE)
}



###############################################################################
### FILE: modules/04_adjuster/R/zzz_depends.R
###############################################################################
# v2/modules/04_adjuster/R/zzz_depends.R
# Dependencies + guardrails for Module 04 (Adjuster)

# Must have core loaded first
if (!exists("af2_get_config")) {
  stop("af2_get_config not found. Source v2/modules/00_core/R/config.R first.")
}
if (!exists("af2_log")) {
  stop("af2_log not found. Source v2/modules/00_core/R/logging.R first.")
}
if (!exists("%||%")) {
  stop("%||% not found. Source v2/modules/00_core/R/utils.R first.")
}
if (!exists("af2_require")) {
  stop("af2_require not found. Source v2/modules/00_core/R/utils.R first.")
}
if (!exists("af2_assert_cols")) {
  stop("af2_assert_cols not found. Source v2/modules/00_core/R/utils.R first.")
}
if (!exists("af2_assert_no_dupes")) {
  stop("af2_assert_no_dupes not found. Source v2/modules/00_core/R/utils.R first.")
}

af2_adj_require <- function(pkgs) {
  for (p in pkgs) {
    if (!requireNamespace(p, quietly = TRUE)) {
      stop("Missing package for adjuster module: ", p, call. = FALSE)
    }
  }
  invisible(TRUE)
}

af2_adj_require(c("data.table"))

suppressPackageStartupMessages({
  library(data.table)
})



###############################################################################
### FILE: modules/04_adjuster/README.md
###############################################################################
# Module

Purpose:
- Define INPUT contract
- Define OUTPUT contract
- List functions
- List tests



###############################################################################
### FILE: modules/05_screener/R/compute_metrics.R
###############################################################################
# v2/modules/05_screener/R/compute_metrics.R
# Feature engineering for one symbol (feature-vector output).
# Uses adjusted FINAL OHLC whenever available.

af2_compute_symbol_features <- function(dt_sym, horizons_days) {
  af2_require(c("data.table"))

  dt <- data.table::as.data.table(dt_sym)
  data.table::setorder(dt, refdate)

  n_obs <- nrow(dt)
  if (n_obs < 30L) return(NULL)

  # Ensure required columns exist
  af2_assert_cols(dt, c("symbol", "refdate", "close_adj_final"), name = "panel_adj(symbol)")

  # Normalize liquidity column name
  if (!"turnover" %in% names(dt) && "vol_fin" %in% names(dt)) {
    dt[, turnover := vol_fin]
  }
  if (!"turnover" %in% names(dt)) dt[, turnover := NA_real_]

  # Try to use OHLC adjusted final; fall back to close-only where needed
  if (!"open_adj_final" %in% names(dt)) dt[, open_adj_final := NA_real_]
  if (!"high_adj_final" %in% names(dt)) dt[, high_adj_final := NA_real_]
  if (!"low_adj_final"  %in% names(dt)) dt[, low_adj_final  := NA_real_]

  # Coverage
  n_valid <- sum(is.finite(dt$close_adj_final) & !is.na(dt$close_adj_final))
  coverage <- if (n_obs > 0) n_valid / n_obs else NA_real_

  # Daily returns (close-close)
  dt[, close_prev := data.table::shift(close_adj_final, 1L)]
  dt[, ret_cc_log := data.table::fifelse(
    is.finite(close_adj_final) & is.finite(close_prev) & close_adj_final > 0 & close_prev > 0,
    log(close_adj_final / close_prev),
    NA_real_
  )]
  dt[, ret_cc_simple := data.table::fifelse(
    is.finite(close_adj_final) & is.finite(close_prev) & close_prev != 0,
    (close_adj_final / close_prev) - 1,
    NA_real_
  )]

  # Open gap (open vs prev close)
  dt[, gap_oc := data.table::fifelse(
    is.finite(open_adj_final) & is.finite(close_prev) & open_adj_final > 0 & close_prev > 0,
    (open_adj_final / close_prev) - 1,
    NA_real_
  )]

  # Intraday range (high-low)
  dt[, range_hl_log := data.table::fifelse(
    is.finite(high_adj_final) & is.finite(low_adj_final) &
      high_adj_final > 0 & low_adj_final > 0 & high_adj_final >= low_adj_final,
    log(high_adj_final / low_adj_final),
    NA_real_
  )]
  dt[, range_hl_pct := data.table::fifelse(
    is.finite(high_adj_final) & is.finite(low_adj_final) & is.finite(close_adj_final) &
      close_adj_final > 0 & high_adj_final >= low_adj_final,
    (high_adj_final - low_adj_final) / close_adj_final,
    NA_real_
  )]

  # Candle body (|close-open| / open)
  dt[, body_pct := data.table::fifelse(
    is.finite(open_adj_final) & is.finite(close_adj_final) & open_adj_final > 0,
    abs(close_adj_final - open_adj_final) / open_adj_final,
    NA_real_
  )]

  # True range % (ATR-like)
  dt[, tr := NA_real_]
  dt[is.finite(high_adj_final) & is.finite(low_adj_final),
     tr := high_adj_final - low_adj_final]
  dt[is.finite(tr) & is.finite(close_prev),
     tr := pmax(
       tr,
       abs(high_adj_final - close_prev),
       abs(low_adj_final - close_prev),
       na.rm = TRUE
     )]
  dt[, tr_pct := data.table::fifelse(
    is.finite(tr) & is.finite(close_prev) & close_prev > 0,
    tr / close_prev,
    NA_real_
  )]

  out <- list(
    symbol = dt$symbol[1],
    end_date = dt$refdate[n_obs],
    n_obs = as.integer(n_obs),
    n_valid = as.integer(n_valid),
    coverage = as.numeric(coverage)
  )

  # Helper: safe horizon return using row index (business-day count proxy)
  safe_price_ret <- function(p0, p1) {
    if (!is.finite(p0) || !is.finite(p1)) return(NA_real_)
    if (p0 == 0) return(NA_real_)
    (p1 / p0) - 1
  }

  # Multi-horizon features
  last_idx <- n_obs
  for (h in horizons_days) {
    h <- as.integer(h)

    # Return over horizon (close->close)
    if (h > 1L && (last_idx - h) >= 1L) {
      p0 <- dt$close_adj_final[last_idx - h]
      p1 <- dt$close_adj_final[last_idx]
      out[[paste0("ret_", h, "d")]] <- safe_price_ret(p0, p1)

      # Close-close vol (annualized)
      idx_start <- max(1L, last_idx - h + 1L)
      rwin <- dt$ret_cc_log[idx_start:last_idx]
      out[[paste0("vol_cc_", h, "d")]] <- stats::sd(rwin, na.rm = TRUE) * sqrt(252)

      # Parkinson volatility from HL range (annualized)
      x <- dt$range_hl_log[idx_start:last_idx]
      if (sum(is.finite(x)) >= 5L) {
        out[[paste0("vol_pk_", h, "d")]] <- sqrt(mean(x^2, na.rm = TRUE) / (4 * log(2))) * sqrt(252)
      } else {
        out[[paste0("vol_pk_", h, "d")]] <- NA_real_
      }

      # Garman–Klass volatility (annualized) - requires O,H,L,C
      o <- dt$open_adj_final[idx_start:last_idx]
      hi <- dt$high_adj_final[idx_start:last_idx]
      lo <- dt$low_adj_final[idx_start:last_idx]
      c <- dt$close_adj_final[idx_start:last_idx]
      ok <- is.finite(o) & is.finite(hi) & is.finite(lo) & is.finite(c) &
        o > 0 & hi > 0 & lo > 0 & c > 0 & hi >= lo
      if (sum(ok) >= 5L) {
        log_hl <- log(hi[ok] / lo[ok])
        log_co <- log(c[ok] / o[ok])
        sig2 <- mean(0.5 * (log_hl^2) - (2 * log(2) - 1) * (log_co^2), na.rm = TRUE)
        out[[paste0("vol_gk_", h, "d")]] <- sqrt(pmax(sig2, 0)) * sqrt(252)
      } else {
        out[[paste0("vol_gk_", h, "d")]] <- NA_real_
      }

      # Intraday range stats
      rp <- dt$range_hl_pct[idx_start:last_idx]
      out[[paste0("range_mean_", h, "d")]] <- mean(rp, na.rm = TRUE)
      out[[paste0("range_max_", h, "d")]]  <- suppressWarnings(max(rp, na.rm = TRUE))

      # Gap stats
      gp <- dt$gap_oc[idx_start:last_idx]
      out[[paste0("gap_min_", h, "d")]] <- suppressWarnings(min(gp, na.rm = TRUE))
      out[[paste0("gap_max_", h, "d")]] <- suppressWarnings(max(gp, na.rm = TRUE))
      out[[paste0("gap_abs_med_", h, "d")]] <- stats::median(abs(gp), na.rm = TRUE)

      # ATR-like stats
      trp <- dt$tr_pct[idx_start:last_idx]
      out[[paste0("tr_mean_", h, "d")]] <- mean(trp, na.rm = TRUE)

      # Body stats
      bp <- dt$body_pct[idx_start:last_idx]
      out[[paste0("body_mean_", h, "d")]] <- mean(bp, na.rm = TRUE)

    } else {
      # Populate missing horizons to keep schema stable
      out[[paste0("ret_", h, "d")]] <- NA_real_
      out[[paste0("vol_cc_", h, "d")]] <- NA_real_
      out[[paste0("vol_pk_", h, "d")]] <- NA_real_
      out[[paste0("vol_gk_", h, "d")]] <- NA_real_
      out[[paste0("range_mean_", h, "d")]] <- NA_real_
      out[[paste0("range_max_", h, "d")]] <- NA_real_
      out[[paste0("gap_min_", h, "d")]] <- NA_real_
      out[[paste0("gap_max_", h, "d")]] <- NA_real_
      out[[paste0("gap_abs_med_", h, "d")]] <- NA_real_
      out[[paste0("tr_mean_", h, "d")]] <- NA_real_
      out[[paste0("body_mean_", h, "d")]] <- NA_real_
    }
  }

  # Drawdown + ulcer (NA-robust)
  prices <- dt$close_adj_final
  if (requireNamespace("zoo", quietly = TRUE)) {
    prices <- zoo::na.locf(prices, na.rm = FALSE)
  }
  cm <- cummax(prices)
  dd <- prices / cm - 1
  out$max_dd <- suppressWarnings(min(dd, na.rm = TRUE))
  out$ulcer_index <- sqrt(mean((dd * 100)^2, na.rm = TRUE))

  # Liquidity features
  traded_flag <- is.finite(dt$close_adj_final) & !is.na(dt$close_adj_final)
  out$median_turnover <- stats::median(dt$turnover, na.rm = TRUE)
  out$days_traded_ratio <- mean(traded_flag, na.rm = TRUE)

  # Amihud-like illiquidity
  valid <- is.finite(dt$ret_cc_simple) & is.finite(dt$turnover) & dt$turnover > 0
  out$amihud <- if (any(valid)) {
    mean(abs(dt$ret_cc_simple[valid]) / dt$turnover[valid], na.rm = TRUE)
  } else NA_real_

  data.table::as.data.table(out)
}



###############################################################################
### FILE: modules/05_screener/R/liquidity_filter.R
###############################################################################
# v2/modules/05_screener/R/liquidity_filter.R

af2_compute_liquidity_from_panel <- function(panel_adj,
                                             min_turnover,
                                             min_days_traded_ratio) {
  af2_require("data.table")
  dt <- data.table::as.data.table(panel_adj)

  # unify turnover column name
  if (!"turnover" %in% names(dt) && "vol_fin" %in% names(dt)) {
    dt[, turnover := vol_fin]
  }

  dt[, traded_flag := is.finite(close_adj_final) & !is.na(close_adj_final)]

  liq <- dt[, .(
    median_turnover = stats::median(turnover, na.rm = TRUE),
    days_traded_ratio = mean(traded_flag, na.rm = TRUE)
  ), by = symbol]

  liq[is.na(median_turnover), median_turnover := 0]
  liq[is.na(days_traded_ratio), days_traded_ratio := 0]

  liq[
    median_turnover >= min_turnover &
      days_traded_ratio >= min_days_traded_ratio
  ]
}



###############################################################################
### FILE: modules/05_screener/R/run_screener.R
###############################################################################
# v2/modules/05_screener/R/run_screener.R

# Return modes:
#   return="ranked"   -> current behavior (score + ranks)
#   return="features" -> ONLY the feature table (per-symbol metrics), no scoring

af2_run_screener <- function(panel_adj,
                             config = NULL,
                             allow_unresolved = NULL,
                             return = c("ranked", "features")) {

  af2_require("data.table")
  return <- match.arg(return)

  # If caller didn't specify, default to core config policy
  if (is.null(allow_unresolved)) {
    cfg_core <- af2_get_config()
    allow_unresolved <- isTRUE(cfg_core$allow_unresolved_in_screener)
  }

  cfg <- af2_get_screener_config(config)

  # 0) Validate input contract hard
  af2_validate_screener_input(panel_adj, allow_unresolved = allow_unresolved)

  dt <- data.table::as.data.table(panel_adj)
  dt[, refdate := as.Date(refdate)]

  # unify turnover name
  if (!"turnover" %in% names(dt) && "vol_fin" %in% names(dt)) {
    dt[, turnover := vol_fin]
  }

  # 1) Liquidity filter
  liq <- af2_compute_liquidity_from_panel(
    dt,
    min_turnover = cfg$min_turnover,
    min_days_traded_ratio = cfg$min_days_traded_ratio
  )
  if (!nrow(liq)) stop("af2_run_screener: no symbols pass liquidity filter.", call. = FALSE)

  dt <- dt[symbol %in% liq$symbol]
  data.table::setorder(dt, symbol, refdate)

  # 2) Compute metrics per symbol on last lookback window
  metrics_list <- list()
  syms <- unique(dt$symbol)

  for (sym in syms) {
    sdt <- dt[symbol == sym]

    # Ensure we keep enough rows to compute the longest horizon return.
    need_n <- max(
      as.integer(cfg$lookback_days),
      as.integer(max(cfg$horizons_days)) + 1L
    )

    if (nrow(sdt) > need_n) {
      sdt <- sdt[(.N - need_n + 1):.N]
    }

    m <- af2_compute_symbol_metrics(sdt, cfg$horizons_days)
    if (!is.null(m)) {
      # attach asset_type
      m[, asset_type := unique(sdt$asset_type)[1]]
      metrics_list[[sym]] <- m
    }
  }

  metrics <- data.table::rbindlist(metrics_list, fill = TRUE)
  if (!nrow(metrics)) stop("af2_run_screener: metrics computation yielded zero rows.", call. = FALSE)

  # If requested: return ONLY features (no scoring/ranking)
  if (return == "features") {
    return(list(
      features = metrics[order(symbol)],
      liquidity = liq[order(symbol)],
      config = cfg
    ))
  }

  # 3) Score + rank (default behavior)
  out <- af2_score_and_rank(metrics, cfg$score_weights)

  by_type <- split(out, out$asset_type)
  by_type <- lapply(by_type, function(x) x[order(x$rank_type)])

  list(
    full = out[order(rank_overall)],
    by_type = by_type,
    features = metrics[order(symbol)],
    liquidity = liq[order(symbol)],
    config = cfg
  )
}




###############################################################################
### FILE: modules/05_screener/R/score_rank.R
###############################################################################
# v2/modules/05_screener/R/score_rank.R

af2_score_and_rank <- function(metrics, score_weights) {
  af2_require("data.table")
  dt <- data.table::as.data.table(metrics)

  dt[, score := 0]

  for (nm in names(score_weights)) {
    if (!nm %in% names(dt)) next
    x <- dt[[nm]]
    if (all(is.na(x))) next
    mu <- mean(x, na.rm = TRUE)
    s  <- stats::sd(x, na.rm = TRUE)
    if (!is.finite(s) || s == 0) next

    z <- (x - mu) / s
    z[!is.finite(z) | is.na(z)] <- 0
    dt[, score := score + score_weights[[nm]] * z]
  }

  dt[, rank_overall := rank(-score, ties.method = "first")]
  if ("asset_type" %in% names(dt)) {
    dt[, rank_type := rank(-score, ties.method = "first"), by = asset_type]
  } else {
    dt[, rank_type := NA_integer_]
  }

  dt[order(rank_overall)]
}



###############################################################################
### FILE: modules/05_screener/R/screener_config.R
###############################################################################
# v2/modules/05_screener/R/screener_config.R

af2_screener_config_default <- list(
  lookback_days   = 252L,
  horizons_days   = c(21L, 63L, 126L, 252L),

  # Liquidity
  min_turnover = 5e5,
  min_days_traded_ratio = 0.8,

  # Scoring weights (z-score aggregation)
  score_weights = list(
    # Momentum
    ret_21d  = +0.3,
    ret_63d  = +0.6,
    ret_126d = +0.9,
    ret_252d = +1.0,

    # Risk / stability penalties
    vol_21d  = -0.4,
    vol_252d = -0.7,
    max_dd   = -0.8,
    ulcer_index = -0.8,

    # Liquidity penalty
    amihud = -0.5
  )
)

af2_get_screener_config <- function(config = NULL) {
  cfg <- af2_screener_config_default

  if (!is.null(config)) {
    for (nm in names(config)) cfg[[nm]] <- config[[nm]]
  }

  # Defensive normalization
  if (is.null(cfg$horizons_days)) cfg$horizons_days <- integer()
  cfg$horizons_days <- as.integer(cfg$horizons_days)
  cfg$lookback_days <- as.integer(cfg$lookback_days)

  if (length(cfg$horizons_days)) {
    max_h <- max(cfg$horizons_days, na.rm = TRUE)
    if (is.finite(max_h) && cfg$lookback_days < (max_h + 1L)) {
      cfg$lookback_days <- max_h + 1L
    }
  }

  cfg
}



###############################################################################
### FILE: modules/05_screener/R/validate_screener_input.R
###############################################################################
# v2/modules/05_screener/R/validate_screener_input.R

af2_validate_screener_input <- function(panel_adj, allow_unresolved = FALSE) {
  af2_require(c("data.table"))
  af2_assert_cols(
    panel_adj,
    c("symbol", "refdate", "close_adj_final", "asset_type", "adjustment_state"),
    name = "panel_adj"
  )

  dt <- data.table::as.data.table(panel_adj)
  dt[, refdate := as.Date(refdate)]

  # Basic type sanity
  if (!is.character(dt$symbol)) stop("panel_adj$symbol must be character.", call. = FALSE)
  if (!is.character(dt$asset_type)) stop("panel_adj$asset_type must be character.", call. = FALSE)
  if (!is.character(dt$adjustment_state)) stop("panel_adj$adjustment_state must be character.", call. = FALSE)

  # Must have at least one liquidity column
  has_turnover <- "turnover" %in% names(dt)
  has_vol_fin  <- "vol_fin" %in% names(dt)
  if (!has_turnover && !has_vol_fin) {
    stop("panel_adj must contain either 'turnover' or 'vol_fin' for liquidity logic.", call. = FALSE)
  }

  # No duplicate rows per symbol-date
  af2_assert_no_dupes(dt, c("symbol", "refdate"), name = "panel_adj")

  # Adjustment state policy
  bad <- dt[adjustment_state == "suspect_unresolved"]
  if (nrow(bad) && !isTRUE(allow_unresolved)) {
    stop(
      "Screener input contains unresolved suspects.\n",
      "You must fix upstream adjuster/manual registry OR set allow_unresolved=TRUE.\n",
      "Example symbols: ", paste(unique(utils::head(bad$symbol, 10)), collapse = ", "),
      call. = FALSE
    )
  }

  invisible(TRUE)
}



###############################################################################
### FILE: modules/05_screener/README.md
###############################################################################
# Module

Purpose:
- Define INPUT contract
- Define OUTPUT contract
- List functions
- List tests



###############################################################################
### FILE: scripts/00_bootstrap_v2.R
###############################################################################
# v2/scripts/00_bootstrap_v2.R
# Creates the v2 directory structure + minimal placeholder READMEs.
# Run from project root: source("v2/scripts/00_bootstrap_v2.R")

af2_bootstrap_v2 <- function(root = "v2", verbose = TRUE) {
  dirs <- c(
    root,
    file.path(root, "README.md"),
    file.path(root, "contracts"),
    file.path(root, "data", "raw"),
    file.path(root, "data", "cache"),
    file.path(root, "data", "fixtures"),
    file.path(root, "data", "manual"),
    file.path(root, "logs"),
    file.path(root, "modules"),
    file.path(root, "modules", "00_core", "R"),
    file.path(root, "modules", "00_core", "tests"),
    file.path(root, "modules", "01_b3_universe", "R"),
    file.path(root, "modules", "01_b3_universe", "tests"),
    file.path(root, "modules", "02_diagnostics", "R"),
    file.path(root, "modules", "02_diagnostics", "tests"),
    file.path(root, "modules", "03_corporate_actions", "R"),
    file.path(root, "modules", "03_corporate_actions", "tests"),
    file.path(root, "modules", "04_adjuster", "R"),
    file.path(root, "modules", "04_adjuster", "tests"),
    file.path(root, "modules", "05_screener", "R"),
    file.path(root, "modules", "05_screener", "tests"),
    file.path(root, "modules", "06_risk", "R"),
    file.path(root, "modules", "06_risk", "tests"),
    file.path(root, "modules", "07_portfolio", "R"),
    file.path(root, "modules", "07_portfolio", "tests"),
    file.path(root, "modules", "08_backtest", "R"),
    file.path(root, "modules", "08_backtest", "tests"),
    file.path(root, "scripts")
  )

  # Create directories (ignore .md entries)
  dir_paths <- dirs[!grepl("\\.md$", dirs)]
  for (d in dir_paths) {
    if (!dir.exists(d)) {
      dir.create(d, recursive = TRUE, showWarnings = FALSE)
      if (verbose) message("Created: ", d)
    }
  }

  # Minimal contracts placeholders
  contract_files <- c(
    "universe_raw.md",
    "adjustments.md",
    "panel_adj.md",
    "screener_input.md",
    "screener_output.md"
  )
  for (f in contract_files) {
    p <- file.path(root, "contracts", f)
    if (!file.exists(p)) {
      writeLines(
        c(
          paste0("# ", f),
          "",
          "This is a placeholder. Fill with the explicit schema + guarantees."
        ),
        con = p
      )
      if (verbose) message("Seeded contract: ", p)
    }
  }

  # Module READMEs
  module_readmes <- c(
    file.path(root, "modules", "00_core", "README.md"),
    file.path(root, "modules", "01_b3_universe", "README.md"),
    file.path(root, "modules", "02_diagnostics", "README.md"),
    file.path(root, "modules", "03_corporate_actions", "README.md"),
    file.path(root, "modules", "04_adjuster", "README.md"),
    file.path(root, "modules", "05_screener", "README.md")
  )
  for (p in module_readmes) {
    if (!file.exists(p)) {
      writeLines(
        c(
          "# Module",
          "",
          "Purpose:",
          "- Define INPUT contract",
          "- Define OUTPUT contract",
          "- List functions",
          "- List tests"
        ),
        con = p
      )
      if (verbose) message("Seeded README: ", p)
    }
  }

  # Root README
  root_readme <- file.path(root, "README.md")
  if (!file.exists(root_readme)) {
    writeLines(
      c(
        "# autofinance_R v2",
        "",
        "Principles:",
        "- In-memory first",
        "- Contract-first",
        "- Fixtures-first",
        "- Screener cannot fetch or adjust data",
        "- Adjuster is the single owner of history mutation"
      ),
      con = root_readme
    )
    if (verbose) message("Seeded: ", root_readme)
  }

  invisible(TRUE)
}

af2_bootstrap_v2()



###############################################################################
### FILE: scripts/00_make_fixtures.R
###############################################################################
# v2/scripts/00_make_fixtures.R
# Generates deterministic mock panels for screener development.
# Run from project root:
#   source("v2/modules/00_core/R/utils.R")
#   source("v2/modules/00_core/R/config.R")
#   source("v2/scripts/00_make_fixtures.R")

af2_make_price_path <- function(dates, start_price = 10,
                                drift = 0.0003, vol = 0.01,
                                seed = 1L) {
  set.seed(seed)
  n <- length(dates)
  eps <- rnorm(n, mean = drift, sd = vol)
  px <- start_price * cumprod(1 + eps)
  pmax(px, 0.01)
}

af2_write_fixture <- function(dt, name, cfg) {
  p <- file.path(cfg$fixtures_dir, paste0(name, ".rds"))
  saveRDS(dt, p)
  message("Wrote fixture: ", p)
}

af2_make_fixtures <- function(config = NULL) {
  af2_require(c("data.table", "lubridate"))
  cfg <- af2_get_config(config)

  # ~260 business days ending today
  end_date <- Sys.Date()
  start_date <- end_date - 400
  dates <- af2_make_bizdays_seq(start_date, end_date)
  dates <- tail(dates, 260)

  symbols <- c("AAA4", "BBB11", "CCC34", "DDD11")
  asset_type_map <- c(
    AAA4 = "equity",
    BBB11 = "fii",
    CCC34 = "bdr",
    DDD11 = "etf"
  )

  # Construct 4 different behaviors
  px_A <- af2_make_price_path(dates, 10, drift = 0.0008, vol = 0.007, seed = 11)  # strong uptrend
  px_B <- af2_make_price_path(dates, 100, drift = 0.0001, vol = 0.003, seed = 22) # low vol/flat
  px_C <- af2_make_price_path(dates, 30, drift = 0.0003, vol = 0.020, seed = 33)  # volatile
  px_D <- af2_make_price_path(dates, 50, drift = -0.0002, vol = 0.010, seed = 44) # mild down

  price_list <- list(AAA4 = px_A, BBB11 = px_B, CCC34 = px_C, DDD11 = px_D)

  # Base liquidity
  liq_level <- c(AAA4 = 2e6, BBB11 = 8e5, CCC34 = 1.5e6, DDD11 = 1.2e6)

  rows <- list()
  for (sym in symbols) {
    px <- price_list[[sym]]
    turnover <- liq_level[[sym]] * (1 + rnorm(length(px), 0, 0.1))
    turnover <- pmax(turnover, 1e4)

    dt <- data.table::data.table(
      symbol = sym,
      refdate = dates,
      close_raw = px,
      close_adj_split = px,
      close_adj_final = px,
      turnover = turnover,
      qty = round(turnover / px),
      asset_type = asset_type_map[[sym]],
      adjustment_state = "ok"
    )
    rows[[sym]] <- dt
  }

  panel_mock_small <- data.table::rbindlist(rows)
  data.table::setorder(panel_mock_small, symbol, refdate)

  # Edge cases fixture
  panel_mock_edge <- data.table::copy(panel_mock_small)

  # Make one symbol illiquid
  panel_mock_edge[symbol == "BBB11", turnover := 1e4]

  # Insert missing block for CCC34
  miss_idx <- panel_mock_edge[symbol == "CCC34", .I][50:70]
  panel_mock_edge[miss_idx, close_adj_final := NA_real_]

  # Mark DDD11 unresolved suspect
  panel_mock_edge[symbol == "DDD11", adjustment_state := "suspect_unresolved"]

  # "Split case" fixture (simulates pre-adjustment discontinuity,
  # but we store final as already fixed for screener use)
  panel_mock_split <- data.table::copy(panel_mock_small)
  # create raw discontinuity for AAA4 around mid
  mid <- panel_mock_split[symbol == "AAA4", .I][130]
  panel_mock_split[mid:nrow(panel_mock_split)][symbol == "AAA4", close_raw := close_raw / 5]
  # but keep adjusted final coherent
  panel_mock_split[symbol == "AAA4", close_adj_split := close_adj_final]
  panel_mock_split[symbol == "AAA4", adjustment_state := "split_only"]

  # Save
  af2_write_fixture(panel_mock_small, "panel_mock_small", cfg)
  af2_write_fixture(panel_mock_edge, "panel_mock_edge_cases", cfg)
  af2_write_fixture(panel_mock_split, "panel_mock_split_case", cfg)

  invisible(TRUE)
}

af2_make_fixtures()



###############################################################################
### FILE: scripts/01a_smoke_b3_fetch_one_year.R
###############################################################################
# v2/scripts/01a_smoke_b3_fetch_one_year.R
# Real-data smoke test:
# - fetch 1 year
# - include only 1-2 types
# - confirm contract + speed + caching

source("v2/modules/00_core/R/utils.R")
source("v2/modules/00_core/R/config.R")
source("v2/modules/00_core/R/logging.R")

source("v2/modules/01_b3_universe/R/zzz_depends.R")
source("v2/modules/01_b3_universe/R/rb3_init.R")
source("v2/modules/01_b3_universe/R/validate_types.R")
source("v2/modules/01_b3_universe/R/select_min_cols.R")
source("v2/modules/01_b3_universe/R/unify_liquidity.R")
source("v2/modules/01_b3_universe/R/filter_by_type_rb3.R")
source("v2/modules/01_b3_universe/R/fetch_yearly.R")
source("v2/modules/01_b3_universe/R/build_universe.R")

cfg <- af2_get_config()
af2_log("AF2_CFG:", "\n", paste(capture.output(str(cfg)), collapse = "\n"))

year_test <- max(cfg$years)
types_test <- c("equity", "etf")

af2_log("AF2_B3:", "SMOKE: year=", year_test, " types=", paste(types_test, collapse = ","))

t0 <- Sys.time()
dt <- af2_b3_build_universe_year(
  year = year_test,
  include_types = types_test,
  cfg = cfg,
  verbose = TRUE,
  use_cache = TRUE,
  force_download = FALSE,
  reprocess = FALSE
)
t1 <- Sys.time()

af2_log("AF2_B3:", "SMOKE elapsed seconds: ", round(as.numeric(difftime(t1, t0, units = "secs")), 2))

af2_log("AF2_B3:", "Head:")
print(utils::head(dt, 10))

# Contract check
req <- c("symbol","refdate","open","high","low","close","turnover","qty","asset_type")
stopifnot(all(req %in% names(dt)))

af2_log("AF2_B3:", "SMOKE OK.")



###############################################################################
### FILE: scripts/01b_build_universe_small_window.R
###############################################################################
# v2/scripts/01b_build_universe_small_window.R
# Build a small 2-year universe for all 4 types
# and save a narrow raw panel artifact.

source("v2/modules/00_core/R/utils.R")
source("v2/modules/00_core/R/config.R")
source("v2/modules/00_core/R/logging.R")

source("v2/modules/01_b3_universe/R/zzz_depends.R")
source("v2/modules/01_b3_universe/R/rb3_init.R")
source("v2/modules/01_b3_universe/R/validate_types.R")
source("v2/modules/01_b3_universe/R/select_min_cols.R")
source("v2/modules/01_b3_universe/R/unify_liquidity.R")
source("v2/modules/01_b3_universe/R/filter_by_type_rb3.R")
source("v2/modules/01_b3_universe/R/fetch_yearly.R")
source("v2/modules/01_b3_universe/R/fetch_daily.R")
source("v2/modules/01_b3_universe/R/build_universe.R")

cfg <- af2_get_config()

# Choose mode here to avoid future screener regressions.
# "yearly" = backfill-style artifact
# "daily"  = screener-grade recent window
mode <- "yearly"
types_all <- c("equity","fii","etf","bdr")

if (mode == "yearly") {

  years_small <- sort(unique(c(max(cfg$years) - 1L, max(cfg$years))))

  af2_log("AF2_B3:", "Building small-window universe (YEARLY): ",
          paste(years_small, collapse = ", "),
          " types=", paste(types_all, collapse = ","))

  dt_all <- af2_b3_build_universe(
    years = years_small,
    include_types = types_all,
    cfg = cfg,
    verbose = TRUE,
    use_cache = TRUE
  )

  artifact_file <- file.path(
    file.path(cfg$raw_dir, "b3_universe"),
    paste0("universe_raw_", min(years_small), "_", max(years_small), ".rds")
  )

} else {

  # Recent ~2-year screener-style window
  end_date <- Sys.Date() - 1
  start_date <- end_date - 730

  af2_log("AF2_B3:", "Building small-window universe (DAILY): ",
          as.character(start_date), " to ", as.character(end_date),
          " types=", paste(types_all, collapse = ","))

  dt_all <- af2_b3_build_universe_window(
    start_date = start_date,
    end_date   = end_date,
    include_types = types_all,
    cfg = cfg,
    verbose = TRUE,
    use_cache = TRUE
  )

  artifact_file <- file.path(
    file.path(cfg$raw_dir, "b3_universe"),
    paste0("universe_raw_daily_",
           format(as.Date(start_date), "%Y%m%d"), "_",
           format(as.Date(end_date), "%Y%m%d"),
           ".rds")
  )
}

af2_log("AF2_B3:", "Universe rows total: ", nrow(dt_all))
af2_log("AF2_B3:", "Symbols total: ", length(unique(dt_all$symbol)))

artifact_dir <- file.path(cfg$raw_dir, "b3_universe")
if (!dir.exists(artifact_dir)) dir.create(artifact_dir, recursive = TRUE)

saveRDS(dt_all, artifact_file)
af2_log("AF2_B3:", "Wrote artifact: ", artifact_file)

RUN_DAILY_SMOKE <- FALSE

if (mode == "yearly" && isTRUE(RUN_DAILY_SMOKE)) {
  end_date <- Sys.Date() - 1
  start_date <- end_date - 90  # ~3 months
  dt_daily_lazy <- af2_b3_fetch_daily_lazy(
    start_date, end_date,
    cfg = cfg,
    verbose = TRUE,
    throttle = FALSE
  )
  # just force a tiny collect to prove it works
  print(dt_daily_lazy |> dplyr::slice_head(n = 5) |> dplyr::collect())
}



###############################################################################
### FILE: scripts/02a_smoke_corp_actions_quantmod.R
###############################################################################
# v2/scripts/02a_smoke_corp_actions_quantmod.R

# Core
source("v2/modules/00_core/R/utils.R")
source("v2/modules/00_core/R/config.R")
source("v2/modules/00_core/R/logging.R")

# Universe (to get a recent symbol list)
source("v2/modules/01_b3_universe/R/zzz_depends.R")
source("v2/modules/01_b3_universe/R/rb3_init.R")
source("v2/modules/01_b3_universe/R/validate_types.R")
source("v2/modules/01_b3_universe/R/select_min_cols.R")
source("v2/modules/01_b3_universe/R/unify_liquidity.R")
source("v2/modules/01_b3_universe/R/filter_by_type_rb3.R")
source("v2/modules/01_b3_universe/R/fetch_yearly.R")
source("v2/modules/01_b3_universe/R/build_universe.R")

# Corporate actions
source("v2/modules/03_corporate_actions/R/zzz_depends.R")
source("v2/modules/03_corporate_actions/R/yahoo_symbol_map.R")
source("v2/modules/03_corporate_actions/R/fetch_splits_quantmod.R")
source("v2/modules/03_corporate_actions/R/fetch_dividends_quantmod.R")
source("v2/modules/03_corporate_actions/R/build_registry.R")

cfg <- af2_get_config()

# Use last config year, tiny types subset to keep smoke fast
year_test <- max(cfg$years)
types_test <- c("equity")

af2_log("AF2_B3:", "SMOKE universe for corp-actions seed: year=", year_test)

dt_univ <- af2_b3_build_universe_year(
  year = year_test,
  include_types = types_test,
  cfg = cfg,
  verbose = TRUE,
  use_cache = TRUE
)

# Grab a small symbol slice
syms <- unique(dt_univ$symbol)
syms <- head(syms, 20)

af2_log("AF2_CA:", "SMOKE fetching splits+dividends for 20 symbols...")

dt_ca <- af2_ca_build_registry(
  symbols = syms,
  cfg = cfg,
  from = as.Date(paste0(year_test - 3, "-01-01")),
  to = Sys.Date(),
  verbose = TRUE,
  use_cache = TRUE,
  force_refresh = FALSE,
  n_workers = 1L
)

print(dt_ca)
af2_log("AF2_CA:", "OK - corp-actions smoke finished.")



###############################################################################
### FILE: scripts/04_run_screener_mock_only.R
###############################################################################
# v2/scripts/04_run_screener_mock_only.R
# Runs the v2 screener ONLY on fixtures.
# This is your daily sanity anchor.

# Core
source("v2/modules/00_core/R/utils.R")
source("v2/modules/00_core/R/config.R")
source("v2/modules/00_core/R/logging.R")

# Screener
source("v2/modules/05_screener/R/screener_config.R")
source("v2/modules/05_screener/R/validate_screener_input.R")
source("v2/modules/05_screener/R/liquidity_filter.R")
source("v2/modules/05_screener/R/compute_metrics.R")
source("v2/modules/05_screener/R/score_rank.R")
source("v2/modules/05_screener/R/run_screener.R")

cfg <- af2_get_config()

fixture_path <- file.path(cfg$fixtures_dir, "panel_mock_small.rds")
if (!file.exists(fixture_path)) {
  stop("Fixture not found: ", fixture_path,
       "\nRun: source('v2/scripts/00_make_fixtures.R')", call. = FALSE)
}

panel <- readRDS(fixture_path)

af2_log_cfg(cfg)
af2_log("AF2_SCR:", "Running screener on mock_small...")

res <- af2_run_screener(panel)

stopifnot(is.list(res), "full" %in% names(res))
stopifnot(nrow(res$full) == 4L)
stopifnot(all(c("AAA4","BBB11","CCC34","DDD11") %in% res$full$symbol))

# Rankings should be complete for this fixture
stopifnot(all(!is.na(res$full$rank_overall)))

print(utils::head(res$full, 10))

af2_log("AF2_SCR:", "OK - mock-only screener passed.")



###############################################################################
### FILE: scripts/04a_smoke_adjuster_small_window.R
###############################################################################
# v2/scripts/04a_smoke_adjuster_small_window.R

# Core
source("v2/modules/00_core/R/utils.R")
source("v2/modules/00_core/R/config.R")
source("v2/modules/00_core/R/logging.R")

# Module 01 (universe)
source("v2/modules/01_b3_universe/R/zzz_depends.R")
source("v2/modules/01_b3_universe/R/rb3_init.R")
source("v2/modules/01_b3_universe/R/validate_types.R")
source("v2/modules/01_b3_universe/R/select_min_cols.R")
source("v2/modules/01_b3_universe/R/unify_liquidity.R")
source("v2/modules/01_b3_universe/R/filter_by_type_rb3.R")
source("v2/modules/01_b3_universe/R/fetch_yearly.R")
source("v2/modules/01_b3_universe/R/fetch_daily.R")
source("v2/modules/01_b3_universe/R/build_universe.R")

# Module 03 (corp actions)
source("v2/modules/03_corporate_actions/R/zzz_depends.R")
source("v2/modules/03_corporate_actions/R/yahoo_symbol_map.R")
source("v2/modules/03_corporate_actions/R/fetch_splits_quantmod.R")
source("v2/modules/03_corporate_actions/R/fetch_dividends_quantmod.R")
source("v2/modules/03_corporate_actions/R/build_registry.R")

# Module 04 (adjuster)
source("v2/modules/04_adjuster/R/zzz_depends.R")
source("v2/modules/04_adjuster/R/build_adjustments.R")
source("v2/modules/04_adjuster/R/apply_adjustments.R")
source("v2/modules/04_adjuster/R/build_panel_adj.R")
source("v2/modules/04_adjuster/R/validate_panel_adj.R")

cfg <- af2_get_config()

# 1) Build small recent universe window
end_date <- Sys.Date() - 1
start_date <- end_date - 365  # 1 year smoke

types_all <- c("equity","fii","etf","bdr")

af2_log("AF2_SMOKE04:", "Universe window ", start_date, " to ", end_date)

univ <- af2_b3_build_universe_window(
  start_date = start_date,
  end_date   = end_date,
  include_types = types_all,
  cfg = cfg,
  verbose = TRUE,
  use_cache = TRUE
)

# take a small symbol subset for faster Yahoo calls
set.seed(1)
syms <- sort(unique(univ$symbol))
syms_small <- head(sample(syms, min(20, length(syms))), 20)

af2_log("AF2_SMOKE04:", "Corp actions for ", length(syms_small), " symbols")

ca <- af2_ca_build_registry(
  symbols = syms_small,
  cfg = cfg,
  from = "2018-01-01",
  to = Sys.Date(),
  verbose = TRUE,
  use_cache = TRUE,
  force_refresh = FALSE,
  n_workers = 1L
)

# 2) Filter universe to same subset
univ_small <- univ[symbol %in% syms_small]

# 3) Build adjusted panel
res <- af2_build_panel_adj(
  universe_raw = univ_small,
  corp_actions = ca,
  manual_events = NULL,
  cfg = cfg,
  verbose = TRUE
)

panel_adj <- res$panel_adj

# 4) Validate
af2_validate_panel_adj(panel_adj)

# 5) Show sample
print(utils::head(panel_adj, 20))

af2_log("AF2_SMOKE04:", "OK - adjuster smoke passed.")



###############################################################################
### FILE: scripts/04b_diagnose_suspects_selective.R
###############################################################################
# v2/scripts/04b_diagnose_suspects_selective.R
# Focused diagnostic run for known bad actors.
# Uses selective wrapper + force_symbols capability.

# ----------------------------
# 00) Core
# ----------------------------
source("v2/modules/00_core/R/utils.R")
source("v2/modules/00_core/R/config.R")
source("v2/modules/00_core/R/logging.R")

# ----------------------------
# 01) Universe
# ----------------------------
source("v2/modules/01_b3_universe/R/zzz_depends.R")
source("v2/modules/01_b3_universe/R/rb3_init.R")
source("v2/modules/01_b3_universe/R/validate_types.R")
source("v2/modules/01_b3_universe/R/select_min_cols.R")
source("v2/modules/01_b3_universe/R/unify_liquidity.R")
source("v2/modules/01_b3_universe/R/filter_by_type_rb3.R")
source("v2/modules/01_b3_universe/R/fetch_daily.R")
source("v2/modules/01_b3_universe/R/build_universe.R")

# ----------------------------
# 02) Corporate actions + selective prefilter
# ----------------------------
source("v2/modules/03_corporate_actions/R/zzz_depends.R")
source("v2/modules/03_corporate_actions/R/yahoo_symbol_map.R")
source("v2/modules/03_corporate_actions/R/fetch_splits_quantmod.R")
source("v2/modules/03_corporate_actions/R/fetch_dividends_quantmod.R")
source("v2/modules/03_corporate_actions/R/build_registry.R")
source("v2/modules/03_corporate_actions/R/select_candidates.R")

# ----------------------------
# 03) Adjuster
# ----------------------------
source("v2/modules/04_adjuster/R/zzz_depends.R")
source("v2/modules/04_adjuster/R/build_adjustments.R")
source("v2/modules/04_adjuster/R/apply_adjustments.R")
source("v2/modules/04_adjuster/R/build_panel_adj.R")
source("v2/modules/04_adjuster/R/build_panel_adj_selective.R")
source("v2/modules/04_adjuster/R/validate_panel_adj.R")

# ----------------------------
# Step 0 — Config overrides for a clean diagnostic
# ----------------------------
cfg_dbg <- af2_get_config(list(
  # First pass: disable selective so you see raw Yahoo behavior
  # You can flip this to TRUE in a second run.
  enable_selective_actions = FALSE,

  # Good for incremental cache behavior
  ca_cache_mode = "by_symbol",

  # First pass: do NOT gate splits
  enable_split_plausibility_gate = FALSE,

  split_gate_min = 0.05,
  split_gate_max = 20
))

af2_log_cfg(cfg_dbg)

# ----------------------------
# Step 1 — Your known bad actors
# ----------------------------
sus <- c("AMER3","MGLU3","OIBR3","TIMS3","HAPV3","AURA33",
         "ALZR11","HFOF11","RBVA11","TEPP11",
         "NFLX34","WALM34","AVGO34")

# ----------------------------
# 04) Build a small recent universe window
# ----------------------------
types_all <- c("equity","fii","etf","bdr")

end_date   <- Sys.Date() - 1
start_date <- end_date - 365

af2_log("AF2_DIAG04B:", "Universe window ", start_date, " to ", end_date)

univ <- af2_b3_build_universe_window(
  start_date = start_date,
  end_date   = end_date,
  include_types = types_all,
  cfg = cfg_dbg,
  verbose = TRUE,
  use_cache = TRUE
)

# Restrict universe to suspects to reduce workload noise
univ_sus <- univ[symbol %in% sus]

af2_log("AF2_DIAG04B:", "Suspect rows=", nrow(univ_sus),
        " symbols=", length(unique(univ_sus$symbol)))

# ----------------------------
# 05) Build adjusted panel via selective wrapper
# ----------------------------
res <- af2_build_panel_adj_selective(
  universe_raw = univ_sus,
  manual_events = NULL,
  cfg = cfg_dbg,
  from_ca = "2018-01-01",
  to_ca   = Sys.Date(),
  verbose = TRUE,
  use_cache = TRUE,
  force_refresh = FALSE,
  n_workers = 1L,

  # This now works after Patch 1
  force_symbols = sus
)

panel_adj <- res$panel_adj
af2_validate_panel_adj(panel_adj)

# ----------------------------
# PATCH C — Split-day shock sanity check (collision-proof)
# ----------------------------
# Goal:
# On dates where a split exists:
#   - raw close should show a large 1-day mechanical jump
#   - adjusted close should show a much smaller jump
#
# This version avoids merge name collisions with panel_adj.

events <- data.table::as.data.table(res$events)

# Keep only actual split events (price factors != 1)
spl_ev <- events[
  is.finite(split_value) & split_value != 1,
  .(
    symbol,
    refdate,
    split_value_event = split_value,
    source_mask_event = source_mask,
    has_manual_event  = has_manual
  )
]

panel_chk <- data.table::as.data.table(panel_adj)
data.table::setorder(panel_chk, symbol, refdate)

# Attach event-side split info WITHOUT clobbering any existing split_value
panel_chk <- merge(
  panel_chk,
  spl_ev,
  by = c("symbol", "refdate"),
  all.x = TRUE
)

# Choose a unified split factor column for diagnostics:
# Prefer the event table value when present; fall back to panel's split_value if it exists.
panel_chk[, split_factor := split_value_event]

if ("split_value" %in% names(panel_chk)) {
  panel_chk[is.na(split_factor) & is.finite(split_value) & split_value != 1,
            split_factor := split_value]
}

# Safety: ensure expected price columns exist
need_cols <- c("close_raw", "close_adj_final")
missing_cols <- setdiff(need_cols, names(panel_chk))
if (length(missing_cols)) {
  stop("PATCH C error: missing columns in panel_adj: ",
       paste(missing_cols, collapse = ", "))
}

# Day-to-day ratios
panel_chk[, `:=`(
  raw_ratio = close_raw / data.table::shift(close_raw),
  adj_ratio = close_adj_final / data.table::shift(close_adj_final)
), by = symbol]

# Scale-free shock size
panel_chk[, `:=`(
  raw_shock = abs(log(raw_ratio)),
  adj_shock = abs(log(adj_ratio))
)]

# Only true split days
split_days <- panel_chk[
  is.finite(split_factor) & split_factor != 1
]

if (nrow(split_days)) {

  cat("\nAF2_DIAG04B: Split-day shock summary",
      "(expect adj_shock << raw_shock)\n")

  by_sym <- split_days[, .(
    n_split_days   = .N,
    mean_raw_shock = mean(raw_shock, na.rm = TRUE),
    mean_adj_shock = mean(adj_shock, na.rm = TRUE),
    pct_improved   = mean(adj_shock < raw_shock, na.rm = TRUE)
  ), by = symbol][order(-n_split_days, -pct_improved)]

  print(by_sym)

  cat("\nAF2_DIAG04B: Worst raw split-day jumps (top 20)\n")
  print(
    split_days[
      order(-raw_shock)
    ][1:min(20L, .N),
      .(
        symbol, refdate,
        split_factor,
        close_raw, raw_ratio, raw_shock,
        close_adj_final, adj_ratio, adj_shock,
        source_mask_event, has_manual_event
      )
    ]
  )

} else {
  cat("\nAF2_DIAG04B: No split days found in this window.\n")
}

af2_log("AF2_DIAG04B:", "panel_adj rows=", nrow(panel_adj),
        " symbols=", length(unique(panel_adj$symbol)))

print(panel_adj[, .N, by = adjustment_state][order(-N)])



###############################################################################
### FILE: scripts/05a_smoke_screener_real_small_window.R
###############################################################################
# v2/scripts/05a_smoke_screener_real_small_window.R
# End-to-end real-data smoke:
# Universe (rb3 daily) -> Corp actions (quantmod/Yahoo cached)
# -> Adjuster -> Screener
#
# Goal:
# - Prove the full v2 spine works on a small real window + sampled symbols
# - Avoid Yahoo hammering via Module 03 cache
# - Surface any contract mismatches early

# ----------------------------
# 00) Core
# ----------------------------
source("v2/modules/00_core/R/utils.R")
source("v2/modules/00_core/R/config.R")
source("v2/modules/00_core/R/logging.R")

cfg <- af2_get_config()

af2_log_cfg(cfg)

# ----------------------------
# 01) Universe (rb3)
# ----------------------------
source("v2/modules/01_b3_universe/R/zzz_depends.R")
source("v2/modules/01_b3_universe/R/rb3_init.R")
source("v2/modules/01_b3_universe/R/validate_types.R")
source("v2/modules/01_b3_universe/R/select_min_cols.R")
source("v2/modules/01_b3_universe/R/unify_liquidity.R")
source("v2/modules/01_b3_universe/R/filter_by_type_rb3.R")
source("v2/modules/01_b3_universe/R/fetch_yearly.R")
source("v2/modules/01_b3_universe/R/fetch_daily.R")
source("v2/modules/01_b3_universe/R/build_universe.R")

types_all <- c("equity", "fii", "etf", "bdr")

end_date   <- Sys.Date() - 1
start_date <- end_date - 730  # ~2y for faster smoke

af2_log("AF2_SMOKE05:", "Universe window ", as.character(start_date), " to ", as.character(end_date))

dt_univ <- af2_b3_build_universe_window(
  start_date = start_date,
  end_date   = end_date,
  include_types = types_all,
  cfg = cfg,
  verbose = TRUE,
  use_cache = TRUE
)

af2_log("AF2_SMOKE05:", "Universe rows=", nrow(dt_univ),
        " symbols=", length(unique(dt_univ$symbol)))

# ----------------------------
# 02) Sample symbols
# ----------------------------
set.seed(42)
sample_n <- 50L

all_syms <- unique(dt_univ$symbol)
syms_smoke <- if (length(all_syms) > sample_n) sample(all_syms, sample_n) else all_syms

dt_univ_smoke <- dt_univ[symbol %in% syms_smoke]

af2_log("AF2_SMOKE05:", "Sampled symbols=", length(syms_smoke),
        " sampled rows=", nrow(dt_univ_smoke))

# ----------------------------
# 03) Corporate actions (quantmod/Yahoo)
# ----------------------------
source("v2/modules/03_corporate_actions/R/zzz_depends.R")
source("v2/modules/03_corporate_actions/R/yahoo_symbol_map.R")
source("v2/modules/03_corporate_actions/R/fetch_splits_quantmod.R")
source("v2/modules/03_corporate_actions/R/fetch_dividends_quantmod.R")
source("v2/modules/03_corporate_actions/R/build_registry.R")

from_ca <- as.Date("2018-01-01")
to_ca   <- Sys.Date()

# keep conservative parallel for Windows; adjust if you want
n_workers <- 2L

af2_log("AF2_SMOKE05:", "Building corp-actions registry for ", length(syms_smoke), " symbols")

registry <- af2_ca_build_registry(
  symbols = syms_smoke,
  cfg = cfg,
  from = from_ca,
  to = to_ca,
  verbose = TRUE,
  use_cache = TRUE,
  force_refresh = FALSE,
  n_workers = n_workers
)

af2_log("AF2_SMOKE05:", "Registry rows=", nrow(registry),
        " symbols with actions=", length(unique(registry$symbol)))

# ----------------------------
# 04) Adjuster (Module 04)
# ----------------------------
source("v2/modules/04_adjuster/R/zzz_depends.R")
source("v2/modules/04_adjuster/R/build_adjustments.R")
source("v2/modules/04_adjuster/R/apply_adjustments.R")
source("v2/modules/04_adjuster/R/build_panel_adj.R")
source("v2/modules/04_adjuster/R/validate_panel_adj.R")

res_adj <- af2_build_panel_adj(
  universe_raw = dt_univ_smoke,
  corp_actions = registry,
  manual_events = NULL,
  cfg = cfg,
  verbose = TRUE
)

panel_adj <- res_adj$panel_adj

af2_validate_panel_adj(panel_adj)

af2_log("AF2_SMOKE05:", "panel_adj rows=", nrow(panel_adj),
        " symbols=", length(unique(panel_adj$symbol)))

# ----------------------------
# 05) Screener (real data)
# ----------------------------
source("v2/modules/05_screener/R/screener_config.R")
source("v2/modules/05_screener/R/validate_screener_input.R")
source("v2/modules/05_screener/R/liquidity_filter.R")
source("v2/modules/05_screener/R/compute_metrics.R")
source("v2/modules/05_screener/R/score_rank.R")
source("v2/modules/05_screener/R/run_screener.R")

af2_log("AF2_SMOKE05:", "Running real-data screener (allow_unresolved=TRUE for smoke).")

res <- af2_run_screener(
  panel_adj,
  config = list(
    lookback_days = 80L,
    horizons_days = c(21L, 63L)
  ),
  allow_unresolved = TRUE
)

af2_log("AF2_SMOKE05:", "by_type integrity check:")
print(lapply(res$by_type, function(x) unique(x$asset_type)))

af2_log("AF2_SMOKE05:", "Top 10 overall:")
print(utils::head(res$full, 10))

af2_log("AF2_SMOKE05:", "Top 5 by type:")
for (tp in names(res$by_type)) {
  af2_log("AF2_SMOKE05:", "Type=", tp)
  print(utils::head(res$by_type[[tp]], 5))
}

af2_log("AF2_SMOKE05:", "OK - real-data screener smoke passed.")



###############################################################################
### FILE: scripts/05b_hard_screener_full_selective.R
###############################################################################
# v2/scripts/05b_hard_screener_full_selective.R
# Full-B3-ish hard test WITH the selective Yahoo "trick".
# Expectation:
# - Universe may have ~2000+ symbols
# - Yahoo fetch should be a small fraction (candidates)
# - Per-symbol caching can be enabled

# ----------------------------
# 00) Core
# ----------------------------
source("v2/modules/00_core/R/utils.R")
source("v2/modules/00_core/R/config.R")
source("v2/modules/00_core/R/logging.R")

cfg <- af2_get_config(list(
  # Turn on the real architecture knobs here
  enable_selective_actions = TRUE,

  # Strongly recommended for the hard run:
  ca_cache_mode = "by_symbol",

  # You can tighten/loosen these as you learn
  ca_prefilter_top_n_overall = 200L,
  ca_prefilter_top_n_by_type = 50L,
  ca_prefilter_max_candidates = 300L
))

af2_log_cfg(cfg)

# ----------------------------
# 01) Universe (rb3)
# ----------------------------
source("v2/modules/01_b3_universe/R/zzz_depends.R")
source("v2/modules/01_b3_universe/R/rb3_init.R")
source("v2/modules/01_b3_universe/R/validate_types.R")
source("v2/modules/01_b3_universe/R/select_min_cols.R")
source("v2/modules/01_b3_universe/R/unify_liquidity.R")
source("v2/modules/01_b3_universe/R/filter_by_type_rb3.R")
source("v2/modules/01_b3_universe/R/fetch_daily.R")
source("v2/modules/01_b3_universe/R/build_universe.R")

types_all <- c("equity", "fii", "etf", "bdr")

end_date   <- Sys.Date() - 1
start_date <- end_date - 730

af2_log("AF2_HARD05:", "Universe window ", as.character(start_date), " to ", as.character(end_date))

dt_univ <- af2_b3_build_universe_window(
  start_date = start_date,
  end_date   = end_date,
  include_types = types_all,
  cfg = cfg,
  verbose = TRUE,
  use_cache = TRUE
)

af2_log("AF2_HARD05:", "Universe rows=", nrow(dt_univ),
        " symbols=", length(unique(dt_univ$symbol)))

# ----------------------------
# 02) Corporate actions + Adjuster (selective wrapper)
# ----------------------------
source("v2/modules/03_corporate_actions/R/zzz_depends.R")
source("v2/modules/03_corporate_actions/R/yahoo_symbol_map.R")
source("v2/modules/03_corporate_actions/R/fetch_splits_quantmod.R")
source("v2/modules/03_corporate_actions/R/fetch_dividends_quantmod.R")
source("v2/modules/03_corporate_actions/R/build_registry.R")
source("v2/modules/03_corporate_actions/R/select_candidates.R")

source("v2/modules/04_adjuster/R/zzz_depends.R")
source("v2/modules/04_adjuster/R/build_adjustments.R")
source("v2/modules/04_adjuster/R/apply_adjustments.R")
source("v2/modules/04_adjuster/R/build_panel_adj.R")
source("v2/modules/04_adjuster/R/build_panel_adj_selective.R")
source("v2/modules/04_adjuster/R/validate_panel_adj.R")

af2_log("AF2_HARD05:", "Building adjusted panel with selective Yahoo registry...")

res_adj <- af2_build_panel_adj_selective(
  universe_raw = dt_univ,
  manual_events = NULL,
  cfg = cfg,
  from_ca = "2018-01-01",
  to_ca   = Sys.Date(),
  verbose = TRUE,
  use_cache = TRUE,
  force_refresh = FALSE,
  n_workers = 1L
)

panel_adj <- res_adj$panel_adj
af2_validate_panel_adj(panel_adj)

af2_log("AF2_HARD05:", "panel_adj rows=", nrow(panel_adj),
        " symbols=", length(unique(panel_adj$symbol)))

# ----------------------------
# 03) Screener
# ----------------------------
source("v2/modules/05_screener/R/screener_config.R")
source("v2/modules/05_screener/R/validate_screener_input.R")
source("v2/modules/05_screener/R/liquidity_filter.R")
source("v2/modules/05_screener/R/compute_metrics.R")
source("v2/modules/05_screener/R/score_rank.R")
source("v2/modules/05_screener/R/run_screener.R")

af2_log("AF2_HARD05:", "Running screener on full adjusted panel...")

res <- af2_run_screener(
  panel_adj,
  config = list(
    lookback_days = 252L,
    horizons_days = c(21L, 63L, 126L, 252L)
  ),
  allow_unresolved = NULL
)

af2_log("AF2_HARD05:", "Top 20 overall:")
print(utils::head(res$full, 20))

af2_log("AF2_HARD05:", "OK - hard selective full run finished.")



###############################################################################
### FILE: scripts/05c_hard_selective_split_audit.R
###############################################################################
# v2/scripts/05c_hard_selective_split_audit.R
# Full-universe HARD diagnostic:
# - Uses the real selective CA architecture
# - Builds a full adjusted panel
# - Audits split consistency at scale
#
# Goal:
# Identify whether split misinterpretation / duplication / missing data
# is systemic beyond your 13-symbol suspect list.

# ----------------------------
# 00) Core
# ----------------------------
source("v2/modules/00_core/R/utils.R")
source("v2/modules/00_core/R/config.R")
source("v2/modules/00_core/R/logging.R")

# data.table is assumed elsewhere, but load defensively
suppressWarnings(suppressMessages({
  if (!requireNamespace("data.table", quietly = TRUE)) {
    stop("data.table required for this script.")
  }
}))
library(data.table)

# ----------------------------
# 00b) Audit knobs (edit here)
# ----------------------------
audit_cfg <- list(
  # Universe length
  lookback_days_universe = 730L,

  # RAW-gap thresholds for "split-like" candidates
  # We intentionally use multiple cutoffs to avoid a single presumptive band.
  raw_ratio_bands = list(
    band1 = c(0.20, 5.00),
    band2 = c(0.10, 10.0),
    band3 = c(0.05, 20.0)
  ),

  # What counts as "raw barely moved"
  # Used to flag suspicious split events that don't match COTAHIST reality.
  small_move_band = c(0.80, 1.25),

  # How many rows to print for each suspicious bucket
  top_n_print = 25L
)

# ----------------------------
# 00c) Real architecture config (selective ON)
# ----------------------------
cfg <- af2_get_config(list(
  enable_selective_actions = TRUE,
  ca_cache_mode = "by_symbol",

  # Keep prefilter limits realistic for full run
  ca_prefilter_top_n_overall   = 200L,
  ca_prefilter_top_n_by_type   = 50L,
  ca_prefilter_max_candidates  = 300L,

  # IMPORTANT:
  # For this audit we want to SEE Yahoo behavior,
  # not suppress it. So keep this OFF here.
  enable_split_plausibility_gate = FALSE
))

af2_log_cfg(cfg)

# ----------------------------
# 01) Universe (rb3)
# ----------------------------
source("v2/modules/01_b3_universe/R/zzz_depends.R")
source("v2/modules/01_b3_universe/R/rb3_init.R")
source("v2/modules/01_b3_universe/R/validate_types.R")
source("v2/modules/01_b3_universe/R/select_min_cols.R")
source("v2/modules/01_b3_universe/R/unify_liquidity.R")
source("v2/modules/01_b3_universe/R/filter_by_type_rb3.R")
source("v2/modules/01_b3_universe/R/fetch_daily.R")
source("v2/modules/01_b3_universe/R/build_universe.R")

types_all <- c("equity", "fii", "etf", "bdr")

end_date   <- Sys.Date() - 1
start_date <- end_date - as.integer(audit_cfg$lookback_days_universe)

af2_log("AF2_AUDIT05C:", "Universe window ", as.character(start_date),
        " to ", as.character(end_date))

dt_univ <- af2_b3_build_universe_window(
  start_date = start_date,
  end_date   = end_date,
  include_types = types_all,
  cfg = cfg,
  verbose = TRUE,
  use_cache = TRUE
)

af2_log("AF2_AUDIT05C:", "Universe rows=", nrow(dt_univ),
        " symbols=", length(unique(dt_univ$symbol)))

# ----------------------------
# 02) Corporate actions + Adjuster (selective wrapper)
# ----------------------------
source("v2/modules/03_corporate_actions/R/zzz_depends.R")
source("v2/modules/03_corporate_actions/R/yahoo_symbol_map.R")
source("v2/modules/03_corporate_actions/R/fetch_splits_quantmod.R")
source("v2/modules/03_corporate_actions/R/fetch_dividends_quantmod.R")
source("v2/modules/03_corporate_actions/R/build_registry.R")
source("v2/modules/03_corporate_actions/R/select_candidates.R")

source("v2/modules/04_adjuster/R/zzz_depends.R")
source("v2/modules/04_adjuster/R/build_adjustments.R")
source("v2/modules/04_adjuster/R/apply_adjustments.R")
source("v2/modules/04_adjuster/R/build_panel_adj.R")
source("v2/modules/04_adjuster/R/build_panel_adj_selective.R")
source("v2/modules/04_adjuster/R/validate_panel_adj.R")

af2_log("AF2_AUDIT05C:", "Building adjusted panel with selective Yahoo registry...")

res_adj <- af2_build_panel_adj_selective(
  universe_raw = dt_univ,
  manual_events = NULL,
  cfg = cfg,
  from_ca = "2018-01-01",
  to_ca   = Sys.Date(),
  verbose = TRUE,
  use_cache = TRUE,
  force_refresh = FALSE,
  n_workers = 1L
)

panel_adj <- as.data.table(res_adj$panel_adj)
events    <- as.data.table(res_adj$events)

af2_validate_panel_adj(panel_adj)

af2_log("AF2_AUDIT05C:", "panel_adj rows=", nrow(panel_adj),
        " symbols=", length(unique(panel_adj$symbol)))
af2_log("AF2_AUDIT05C:", "events rows=", nrow(events),
        " symbols=", length(unique(events$symbol)))

# Defensive: ensure we have the expected columns
needed_panel <- c("symbol","refdate","asset_type","close_raw","close_adj_final")
missing_panel <- setdiff(needed_panel, names(panel_adj))
if (length(missing_panel)) {
  af2_log("AF2_AUDIT05C:", "ERROR: panel missing cols: ",
          paste(missing_panel, collapse = ", "))
  stop("panel_adj missing required columns for audit.")
}

needed_events <- c("symbol","refdate","split_value","source_mask","has_manual")
missing_events <- setdiff(needed_events, names(events))
if (length(missing_events)) {
  af2_log("AF2_AUDIT05C:", "ERROR: events missing cols: ",
          paste(missing_events, collapse = ", "))
  stop("events missing required columns for audit.")
}

# ----------------------------
# 03) Build RAW and ADJ shock series
# ----------------------------
setorder(panel_adj, symbol, refdate)

panel_adj[, raw_ratio := close_raw / shift(close_raw, 1L), by = symbol]
panel_adj[, adj_ratio := close_adj_final / shift(close_adj_final, 1L), by = symbol]

panel_adj[, raw_shock := abs(log(raw_ratio))]
panel_adj[, adj_shock := abs(log(adj_ratio))]

# Clean impossible rows
panel_adj <- panel_adj[
  is.finite(raw_ratio) & raw_ratio > 0 &
  is.finite(adj_ratio) & adj_ratio > 0
]

# ----------------------------
# 04) Event-driven split days
# ----------------------------
ev_splits <- events[is.finite(split_value) & split_value != 1]

# Join split info into panel on same date
panel_ev <- merge(
  panel_adj,
  ev_splits[, .(symbol, refdate, split_factor = split_value,
                source_mask_event = source_mask,
                has_manual_event = has_manual)],
  by = c("symbol","refdate"),
  all.x = TRUE
)

panel_ev[, is_split_day_event := !is.na(split_factor)]

af2_log("AF2_AUDIT05C:", "Event-driven split days detected: ",
        uniqueN(panel_ev[is_split_day_event == TRUE, .(symbol, refdate)]),
        " (symbol-date pairs)")

# ----------------------------
# 05) RAW-gap-driven split-like candidates
# ----------------------------
make_raw_candidates <- function(dt, band, label) {
  lo <- band[1]; hi <- band[2]
  out <- dt[
    raw_ratio < lo | raw_ratio > hi,
    .(symbol, refdate, asset_type, close_raw,
      raw_ratio, raw_shock, adj_ratio, adj_shock)
  ]
  out[, band_label := label]
  out
}

raw_cands <- rbindlist(lapply(names(audit_cfg$raw_ratio_bands), function(nm) {
  make_raw_candidates(panel_ev, audit_cfg$raw_ratio_bands[[nm]], nm)
}), use.names = TRUE, fill = TRUE)

af2_log("AF2_AUDIT05C:", "RAW-gap candidates (any band): ",
        nrow(raw_cands), " rows in total across bands.")

# ----------------------------
# 06) Coverage diagnostics (FIXED)
# ----------------------------

# Build a unique key of raw-gap symbol-date by band
raw_cands_key <- unique(raw_cands[, .(symbol, refdate, band_label)])

# Attach whether registry says that symbol-date is a split day
raw_cands_key <- merge(
  raw_cands_key,
  panel_ev[, .(symbol, refdate, is_split_day_event)],
  by = c("symbol","refdate"),
  all.x = TRUE
)

raw_cands_key[is.na(is_split_day_event), is_split_day_event := FALSE]

# Summarize coverage per band
cov_by_band <- raw_cands_key[
  , .(
    n_rows = .N,
    n_symbols = uniqueN(symbol),
    n_rows_with_event = sum(is_split_day_event),
    pct_rows_with_event = round(mean(is_split_day_event), 4)
  ),
  by = band_label
][order(band_label)]

af2_log("AF2_AUDIT05C:", "Coverage of RAW-gap candidates by registry splits:")
print(cov_by_band)

# ----------------------------
# 07) Suspicion buckets
# ----------------------------
small_lo <- audit_cfg$small_move_band[1]
small_hi <- audit_cfg$small_move_band[2]

# A) "Bad split event" suspects:
# Event says split, but raw barely moved
bad_event <- panel_ev[
  is_split_day_event == TRUE &
    raw_ratio >= small_lo & raw_ratio <= small_hi,
  .(symbol, refdate, asset_type,
    split_factor,
    raw_ratio, raw_shock,
    adj_ratio, adj_shock,
    close_raw, close_adj_final,
    source_mask_event, has_manual_event)
]

# B) "Missing split" suspects:
# Raw shows huge jump (use the middle band by default),
# but no event split recorded
band_mid <- "band1"
miss_event <- raw_cands_key[
  band_label == band_mid &
    is_split_day_event == FALSE
][
  panel_ev, on = .(symbol, refdate), nomatch = 0L
][
  , .(symbol, refdate, asset_type,
      raw_ratio, raw_shock,
      adj_ratio, adj_shock,
      close_raw, close_adj_final)
]

# C) "Harmful adjustment" suspects:
# On event split days, adjusted shock worse than raw shock
harm_event <- panel_ev[
  is_split_day_event == TRUE &
    is.finite(adj_shock) & is.finite(raw_shock) &
    adj_shock > raw_shock,
  .(symbol, refdate, asset_type,
    split_factor,
    raw_ratio, raw_shock,
    adj_ratio, adj_shock,
    close_raw, close_adj_final,
    source_mask_event, has_manual_event)
]

# ----------------------------
# 08) Summaries that are not just raw tables
# ----------------------------
af2_log("AF2_AUDIT05C:", "==================== SUMMARY ====================")

# 08a) Counts by asset type
af2_log("AF2_AUDIT05C:", "Split events by asset_type (event-driven):")
print(ev_splits[panel_adj[, .(symbol, asset_type)], on = "symbol",
               nomatch = 0L][
  , .N, by = asset_type
][order(-N)])

# 08b) How often adjustment improves on event split days
event_day_metrics <- panel_ev[
  is_split_day_event == TRUE,
  .(
    n_split_days = .N,
    mean_raw_shock = mean(raw_shock, na.rm = TRUE),
    mean_adj_shock = mean(adj_shock, na.rm = TRUE),
    pct_improved = mean(adj_shock < raw_shock, na.rm = TRUE)
  ),
  by = symbol
][order(-mean_raw_shock)]

af2_log("AF2_AUDIT05C:",
        "Event split-day shock summary (expect mean_adj_shock << mean_raw_shock).")
print(head(event_day_metrics, audit_cfg$top_n_print))

# 08c) Bucket summaries
af2_log("AF2_AUDIT05C:", "Potential BAD split events (event says split, raw small move).")
af2_log("AF2_AUDIT05C:",
        "Count rows=", nrow(bad_event),
        " symbols=", uniqueN(bad_event$symbol))
if (nrow(bad_event)) {
  print(head(bad_event[order(-adj_shock)], audit_cfg$top_n_print))
}

af2_log("AF2_AUDIT05C:", "Potential MISSING splits (raw big move, no event) using band1.")
af2_log("AF2_AUDIT05C:",
        "Count rows=", nrow(miss_event),
        " symbols=", uniqueN(miss_event$symbol))
if (nrow(miss_event)) {
  print(head(miss_event[order(-raw_shock)], audit_cfg$top_n_print))
}

af2_log("AF2_AUDIT05C:", "Potential HARMFUL split adjustments (adj_shock > raw_shock on event days).")
af2_log("AF2_AUDIT05C:",
        "Count rows=", nrow(harm_event),
        " symbols=", uniqueN(harm_event$symbol))
if (nrow(harm_event)) {
  print(head(harm_event[order(-adj_shock)], audit_cfg$top_n_print))
}

# 08d) Global rates
global_event_pairs <- uniqueN(panel_ev[is_split_day_event == TRUE, .(symbol, refdate)])
global_harm_pairs  <- uniqueN(harm_event[, .(symbol, refdate)])

af2_log("AF2_AUDIT05C:", "Global event split-day pairs=", global_event_pairs)
af2_log("AF2_AUDIT05C:", "Global harmful event pairs=", global_harm_pairs)
af2_log("AF2_AUDIT05C:",
        "Harmful rate on event split days=",
        if (global_event_pairs > 0) round(global_harm_pairs / global_event_pairs, 4) else NA_real_)

# 08e) Cross-check: how many raw-gap candidates exist vs registry splits
af2_log("AF2_AUDIT05C:", "RAW-gap band coverage recap:")
print(cov_by_band)

af2_log("AF2_AUDIT05C:", "================== END SUMMARY ==================")

# ----------------------------
# 09) Optional: feed adjusted panel into screener
# ----------------------------
source("v2/modules/05_screener/R/screener_config.R")
source("v2/modules/05_screener/R/validate_screener_input.R")
source("v2/modules/05_screener/R/liquidity_filter.R")
source("v2/modules/05_screener/R/compute_metrics.R")
source("v2/modules/05_screener/R/score_rank.R")
source("v2/modules/05_screener/R/run_screener.R")

af2_log("AF2_AUDIT05C:", "Running screener on full adjusted panel...")

res <- af2_run_screener(
  panel_ev, # includes raw/adj ratios + split flags, harmless
  config = list(
    lookback_days = 252L,
    horizons_days = c(21L, 63L, 126L, 252L)
  ),
  allow_unresolved = NULL
)

af2_log("AF2_AUDIT05C:", "Top 20 overall:")
print(utils::head(res$full, 20))

af2_log("AF2_AUDIT05C:", "OK - hard selective split audit finished.")



###############################################################################
### FILE: scripts/05d_yahoo_vs_af2_crosscheck.R
###############################################################################
# v2/scripts/05d_yahoo_vs_af2_crosscheck.R
# Robust cross-check AF2 adjusted prices vs Yahoo:
#  - raw close from Yahoo
#  - Yahoo's own Adjusted column (Ad)
#  - adjustOHLC reconstruction (with symbol.name)

# ----------------------------
# 00) Core + config
# ----------------------------
source("v2/modules/00_core/R/utils.R")
source("v2/modules/00_core/R/config.R")
source("v2/modules/00_core/R/logging.R")

cfg <- af2_get_config(list(
  enable_selective_actions = TRUE,
  ca_cache_mode = "by_symbol",
  enable_split_plausibility_gate = FALSE,
  # NEW:
  enable_split_gap_validation = TRUE,
  split_gap_tol_log = 0.35
))
af2_log_cfg(cfg)

# ----------------------------
# 01) Universe
# ----------------------------
source("v2/modules/01_b3_universe/R/zzz_depends.R")
source("v2/modules/01_b3_universe/R/rb3_init.R")
source("v2/modules/01_b3_universe/R/validate_types.R")
source("v2/modules/01_b3_universe/R/select_min_cols.R")
source("v2/modules/01_b3_universe/R/unify_liquidity.R")
source("v2/modules/01_b3_universe/R/filter_by_type_rb3.R")
source("v2/modules/01_b3_universe/R/fetch_daily.R")
source("v2/modules/01_b3_universe/R/build_universe.R")

# ----------------------------
# 02) Corporate actions + Adjuster
# ----------------------------
source("v2/modules/03_corporate_actions/R/zzz_depends.R")
source("v2/modules/03_corporate_actions/R/yahoo_symbol_map.R")
source("v2/modules/03_corporate_actions/R/fetch_splits_quantmod.R")
source("v2/modules/03_corporate_actions/R/fetch_dividends_quantmod.R")
source("v2/modules/03_corporate_actions/R/build_registry.R")
source("v2/modules/03_corporate_actions/R/select_candidates.R")

source("v2/modules/04_adjuster/R/zzz_depends.R")
source("v2/modules/04_adjuster/R/build_adjustments.R")
source("v2/modules/04_adjuster/R/apply_adjustments.R")
source("v2/modules/04_adjuster/R/build_panel_adj.R")
source("v2/modules/04_adjuster/R/build_panel_adj_selective.R")

# ----------------------------
# 03) Packages
# ----------------------------
suppressWarnings({
  library(data.table)
  library(quantmod)
})

# ----------------------------
# 04) Suspects
# ----------------------------
sus <- c("AMER3","TIMS3","ALZR11","HAPV3","OIBR3",
         "MGLU3","NFLX34","AVGO34","WALM34","AURA33")

types_all <- c("equity","fii","etf","bdr")

end_date   <- Sys.Date() - 1
start_date <- end_date - 730

af2_log("AF2_YX05D:", "Universe window ", start_date, " to ", end_date)

univ <- af2_b3_build_universe_window(
  start_date = start_date,
  end_date   = end_date,
  include_types = types_all,
  cfg = cfg,
  verbose = TRUE,
  use_cache = TRUE
)

univ_sus <- univ[symbol %in% sus]

res_adj <- tryCatch(
  af2_build_panel_adj_selective(
    universe_raw = univ_sus,
    manual_events = NULL,
    cfg = cfg,
    from_ca = "2018-01-01",
    to_ca   = Sys.Date(),
    verbose = TRUE,
    use_cache = TRUE,
    force_refresh = FALSE,
    n_workers = 1L,
    force_symbols = sus
  ),
  error = function(err) {
    af2_log("AF2_YX05D:", "ERROR building AF2 panel: ", conditionMessage(err))
    stop(conditionMessage(err), call. = FALSE)
  }
)

panel <- as.data.table(res_adj$panel_adj)

# ----------------------------
# Helpers
# ----------------------------
as_dt_series <- function(vec_xts, symbol_clean, colname) {
  if (is.null(vec_xts) || NROW(vec_xts) == 0) return(NULL)
  dt <- data.table(
    symbol  = symbol_clean,
    refdate = as.Date(index(vec_xts))
  )
  dt[[colname]] <- as.numeric(vec_xts)
  dt
}

safe_adjustOHLC <- function(x, ysym) {
  # Most precise method: rebuild using getSplits/getDividends
  # But MUST pass symbol.name when auto.assign=FALSE
  tryCatch(
    adjustOHLC(x, use.Adjusted = FALSE, symbol.name = ysym),
    error = function(e) NULL
  )
}

# ----------------------------
# 05) Per-symbol cross-check
# ----------------------------
out_list <- list()

for (s in sus) {
  ysym <- paste0(s, ".SA")

  af2_log("AF2_YX05D:", "--------------------------------------------")
  af2_log("AF2_YX05D:", "Yahoo fetch for ", ysym)

  x <- tryCatch(
    getSymbols(ysym, src = "yahoo", from = start_date, to = end_date,
               auto.assign = FALSE),
    error = function(e) NULL
  )

  if (is.null(x) || NROW(x) == 0) {
    af2_log("AF2_YX05D:", "WARNING: Yahoo OHLC missing for ", ysym)
    next
  }

  # Direct presence checks
  sp <- tryCatch(getSplits(ysym), error = function(e) NULL)
  dv <- tryCatch(getDividends(ysym), error = function(e) NULL)

  af2_log("AF2_YX05D:", "getSplits rows for ", s, ": ", if (is.null(sp)) 0 else NROW(sp))
  af2_log("AF2_YX05D:", "getDividends rows for ", s, ": ", if (is.null(dv)) 0 else NROW(dv))

  # 1) Yahoo raw close
  dt_y_raw <- as_dt_series(Cl(x), s, "close_y_raw")

  # 2) Yahoo Adjusted column close (if present)
  dt_y_adjcol <- NULL
  adj_vec <- tryCatch(Ad(x), error = function(e) NULL)
  dt_y_adjcol <- as_dt_series(adj_vec, s, "close_y_adjcol")

  # 3) adjustOHLC reconstructed adjusted close
  x_adj <- safe_adjustOHLC(x, ysym)
  dt_y_adjcalc <- as_dt_series(if (!is.null(x_adj)) Cl(x_adj) else NULL, s, "close_y_adjcalc")

  # Start merge with raw
  dt <- dt_y_raw

  if (!is.null(dt_y_adjcol)) {
    dt <- merge(dt, dt_y_adjcol, by = c("symbol","refdate"), all = TRUE)
  }
  if (!is.null(dt_y_adjcalc)) {
    dt <- merge(dt, dt_y_adjcalc, by = c("symbol","refdate"), all = TRUE)
  }

  # AF2 data
  # Pull TRUE raw straight from the universe window (Cotahist)
  dt_b3 <- univ_sus[symbol == s, .(
    symbol, refdate,
    close_b3_raw = close
  )]

  # AF2 final from the adjusted panel
  dt_af2 <- panel[symbol == s, .(
    symbol, refdate,
    close_af2_final = close_adj_final
  )]

  dt_af2 <- merge(dt_b3, dt_af2, by = c("symbol","refdate"), all = TRUE)
  dt <- merge(dt, dt_af2, by = c("symbol","refdate"), all = TRUE)


  # Log-diff diagnostics (guarded)
  dt[, diff_af2_vs_y_adjcol := ifelse(
    is.finite(close_af2_final) & is.finite(close_y_adjcol) & close_af2_final > 0 & close_y_adjcol > 0,
    log(close_af2_final) - log(close_y_adjcol),
    NA_real_
  )]

  dt[, diff_af2_vs_y_adjcalc := ifelse(
    is.finite(close_af2_final) & is.finite(close_y_adjcalc) & close_af2_final > 0 & close_y_adjcalc > 0,
    log(close_af2_final) - log(close_y_adjcalc),
    NA_real_
  )]

  dt[, diff_b3raw_vs_yraw := ifelse(
    is.finite(close_b3_raw) & is.finite(close_y_raw) & close_b3_raw > 0 & close_y_raw > 0,
    log(close_b3_raw) - log(close_y_raw),
    NA_real_
  )]

  # Summaries
  sm1 <- dt[!is.na(diff_af2_vs_y_adjcol), .(
    n = .N,
    mean_abs_log_diff = mean(abs(diff_af2_vs_y_adjcol), na.rm = TRUE),
    max_abs_log_diff  = max(abs(diff_af2_vs_y_adjcol), na.rm = TRUE)
  )]
  sm1[, method := "AF2 vs Yahoo Adjusted column"]

  sm2 <- dt[!is.na(diff_af2_vs_y_adjcalc), .(
    n = .N,
    mean_abs_log_diff = mean(abs(diff_af2_vs_y_adjcalc), na.rm = TRUE),
    max_abs_log_diff  = max(abs(diff_af2_vs_y_adjcalc), na.rm = TRUE)
  )]
  sm2[, method := "AF2 vs adjustOHLC(rebuilt)"]

  sm3 <- dt[!is.na(diff_b3raw_vs_yraw), .(
    n = .N,
    mean_abs_log_diff = mean(abs(diff_b3raw_vs_yraw), na.rm = TRUE),
    max_abs_log_diff  = max(abs(diff_b3raw_vs_yraw), na.rm = TRUE)
  )]
  sm3[, method := "B3 raw vs Yahoo raw"]

  sm <- rbindlist(list(sm1, sm2, sm3), use.names = TRUE, fill = TRUE)
  sm[, symbol := s]

  af2_log("AF2_YX05D:", "Summary diagnostics for ", s)
  print(sm)

  # At this point, 'dt' already contains:
  # - Yahoo raw
  # - Yahoo Adjusted column
  # - Yahoo adjustOHLC rebuild
  # and we then merged AF2/B3 into it.
  dt_final <- copy(dt)

  out_list[[s]] <- dt_final
}

af2_log("AF2_YX05D:", "Done. Inspect out_list for per-symbol tables.")



