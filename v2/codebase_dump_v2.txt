Project structure for '/c/Users/Galaxy/LEVI/Projetos R/autofinance_R/v2':
===============================================================================
  contracts/adjustments.md
  contracts/panel_adj.md
  contracts/screener_input.md
  contracts/screener_output.md
  contracts/universe_raw.md
  diagnostics/plots_splits/ALZR11_raw_vs_adj_splits.png
  diagnostics/plots_splits/AMBP3_raw_vs_adj_splits.png
  diagnostics/plots_splits/AMER3_raw_vs_adj_splits.png
  diagnostics/plots_splits/AURA33_raw_vs_adj_splits.png
  diagnostics/plots_splits/AVGO34_raw_vs_adj_splits.png
  diagnostics/plots_splits/GGRC11_raw_vs_adj_splits.png
  diagnostics/plots_splits/HAPV3_raw_vs_adj_splits.png
  diagnostics/plots_splits/HFOF11_raw_vs_adj_splits.png
  diagnostics/plots_splits/HGBS11_raw_vs_adj_splits.png
  diagnostics/plots_splits/JSAF11_raw_vs_adj_splits.png
  diagnostics/plots_splits/M2ST34_raw_vs_adj_splits.png
  diagnostics/plots_splits/MGLU3_raw_vs_adj_splits.png
  diagnostics/plots_splits/NFLX34_raw_vs_adj_splits.png
  diagnostics/plots_splits/NVDC34_raw_vs_adj_splits.png
  diagnostics/plots_splits/OIBR3_raw_vs_adj_splits.png
  diagnostics/plots_splits/RBVA11_raw_vs_adj_splits.png
  diagnostics/plots_splits/TEPP11_raw_vs_adj_splits.png
  diagnostics/plots_splits/TIMS3_raw_vs_adj_splits.png
  diagnostics/plots_splits/WALM34_raw_vs_adj_splits.png
  modules/00_core/R/config.R
  modules/00_core/R/logging.R
  modules/00_core/R/utils.R
  modules/00_core/README.md
  modules/01_b3_universe/R/build_universe.R
  modules/01_b3_universe/R/fetch_daily.R
  modules/01_b3_universe/R/fetch_yearly.R
  modules/01_b3_universe/R/filter_by_type_rb3.R
  modules/01_b3_universe/R/rb3_init.R
  modules/01_b3_universe/R/select_min_cols.R
  modules/01_b3_universe/R/unify_liquidity.R
  modules/01_b3_universe/R/validate_types.R
  modules/01_b3_universe/R/zzz_depends.R
  modules/01_b3_universe/README.md
  modules/02_diagnostics/README.md
  modules/03_corporate_actions/codebase_dump_03_corporate_actions.txt
  modules/03_corporate_actions/R/build_registry.R
  modules/03_corporate_actions/R/fetch_dividends_quantmod.R
  modules/03_corporate_actions/R/fetch_splits_quantmod.R
  modules/03_corporate_actions/R/select_candidates.R
  modules/03_corporate_actions/R/yahoo_retry.R
  modules/03_corporate_actions/R/yahoo_symbol_map.R
  modules/03_corporate_actions/R/zzz_depends.R
  modules/03_corporate_actions/README.md
  modules/04_adjuster/R/apply_adjustments.R
  modules/04_adjuster/R/build_adjustments.R
  modules/04_adjuster/R/build_panel_adj.R
  modules/04_adjuster/R/build_panel_adj_selective.R
  modules/04_adjuster/R/validate_panel_adj.R
  modules/04_adjuster/R/zzz_depends.R
  modules/04_adjuster/README.md
  modules/05_screener/R/compute_metrics.R
  modules/05_screener/R/liquidity_filter.R
  modules/05_screener/R/run_screener.R
  modules/05_screener/R/score_rank.R
  modules/05_screener/R/screener_config.R
  modules/05_screener/R/validate_screener_input.R
  modules/05_screener/README.md
  README.md
  scripts/00_bootstrap_v2.R
  scripts/00_make_fixtures.R
  scripts/01a_smoke_b3_fetch_one_year.R
  scripts/01b_build_universe_small_window.R
  scripts/02a_smoke_corp_actions_quantmod.R
  scripts/04_run_screener_mock_only.R
  scripts/04a_smoke_adjuster_small_window.R
  scripts/05a_smoke_screener_real_small_window.R
  scripts/05b_hard_screener_full_selective.R



###############################################################################
### FILE: README.md
###############################################################################
# autofinance_R v2

Principles:
- In-memory first
- Contract-first
- Fixtures-first
- Screener cannot fetch or adjust data
- Adjuster is the single owner of history mutation



###############################################################################
### FILE: contracts/adjustments.md
###############################################################################
# adjustments.md

This is a placeholder. Fill with the explicit schema + guarantees.



###############################################################################
### FILE: contracts/panel_adj.md
###############################################################################
# panel_adj.md

This is a placeholder. Fill with the explicit schema + guarantees.



###############################################################################
### FILE: contracts/screener_input.md
###############################################################################
# screener_input.md

This is a placeholder. Fill with the explicit schema + guarantees.



###############################################################################
### FILE: contracts/screener_output.md
###############################################################################
# screener_output.md

This is a placeholder. Fill with the explicit schema + guarantees.



###############################################################################
### FILE: contracts/universe_raw.md
###############################################################################
# universe_raw.md

This is a placeholder. Fill with the explicit schema + guarantees.



###############################################################################
### FILE: modules/00_core/R/config.R
###############################################################################
# v2/modules/00_core/R/config.R

af2_config_default <- list(
  # Universe scope (used later)
  # Dev default: keep it small and fast.
  # Override explicitly for full rebuild.
  years = {
    y <- as.integer(format(Sys.Date(), "%Y"))
    (y-1L):y
  },
  include_types = c("equity", "fii", "etf", "bdr"),

  # Screener liquidity
  min_turnover = 5e5,
  min_days_traded_ratio = 0.8,

  # Corporate actions toggles (used later)
  enable_splits = TRUE,
  enable_manual_events = TRUE,

  # Paths
  cache_dir  = "v2/data/cache",
  raw_dir    = "v2/data/raw",
  fixtures_dir = "v2/data/fixtures",
  manual_dir = "v2/data/manual",
  logs_dir   = "v2/logs",

  # Safety
  allow_unresolved_in_screener = FALSE,

  # -------------------------------
  # Selective corporate-actions policy (the "trick")
  # -------------------------------
  enable_selective_actions = TRUE,

  # Cache strategy for corp actions:
  # - "batch" keeps current behavior (hash by symbol set)
  # - "by_symbol" enables incremental caching per ticker
  ca_cache_mode = "batch",

  # Prefilter heuristics (B3-only)
  ca_prefilter_recent_days   = 252L,
  ca_prefilter_top_n_overall = 200L,
  ca_prefilter_top_n_by_type = 50L,
  ca_prefilter_max_candidates = 300L,

  # One-day gap thresholds by type (very cheap anomaly filter)
  ca_prefilter_gap_equity = -0.20,
  ca_prefilter_gap_fii    = -0.12,
  ca_prefilter_gap_etf    = -0.15,
  ca_prefilter_gap_bdr    = -0.20,

  # Activeness / recency guards for selective CA
  ca_prefilter_active_days = 10L,

  # Use a shorter window for liquidity scoring (robust to old junk)
  ca_prefilter_liq_window_days = 63L

)

af2_get_config <- function(config = NULL) {
  cfg <- af2_config_default
  if (!is.null(config)) {
    # shallow override for now (keep simple)
    for (nm in names(config)) cfg[[nm]] <- config[[nm]]
  }
  # ensure dirs exist
  dir.create(cfg$cache_dir, recursive = TRUE, showWarnings = FALSE)
  dir.create(cfg$raw_dir, recursive = TRUE, showWarnings = FALSE)
  dir.create(cfg$fixtures_dir, recursive = TRUE, showWarnings = FALSE)
  dir.create(cfg$manual_dir, recursive = TRUE, showWarnings = FALSE)
  dir.create(cfg$logs_dir, recursive = TRUE, showWarnings = FALSE)

  # -------------------------------
  # Validation of sensitive knobs
  # -------------------------------
  if (!is.null(cfg$ca_cache_mode) &&
      !cfg$ca_cache_mode %in% c("batch", "by_symbol")) {
    stop("Invalid ca_cache_mode: ", cfg$ca_cache_mode,
         ". Allowed: batch, by_symbol", call. = FALSE)
  }

  cfg$ca_prefilter_recent_days <- as.integer(cfg$ca_prefilter_recent_days %||% 252L)
  cfg$ca_prefilter_top_n_overall <- as.integer(cfg$ca_prefilter_top_n_overall %||% 200L)
  cfg$ca_prefilter_top_n_by_type <- as.integer(cfg$ca_prefilter_top_n_by_type %||% 50L)
  cfg$ca_prefilter_max_candidates <- as.integer(cfg$ca_prefilter_max_candidates %||% 300L)

  cfg
}



###############################################################################
### FILE: modules/00_core/R/logging.R
###############################################################################
# v2/modules/00_core/R/logging.R

af2_log <- function(prefix, ...) {
  msg <- paste0(prefix, " ", paste(..., collapse = ""))
  message(msg)
}

af2_log_cfg <- function(config) {
  af2_log("AF2_CFG:", "\n", paste(utils::capture.output(str(config)), collapse = "\n"))
}



###############################################################################
### FILE: modules/00_core/R/utils.R
###############################################################################
# v2/modules/00_core/R/utils.R

`%||%` <- function(x, y) if (!is.null(x)) x else y

af2_require <- function(pkgs) {
  pkgs <- unique(pkgs)
  missing <- pkgs[!vapply(pkgs, requireNamespace, logical(1), quietly = TRUE)]
  if (length(missing)) {
    stop("Missing packages in v2 environment: ",
         paste(missing, collapse = ", "),
         "\nInstall them explicitly to keep v2 deterministic.",
         call. = FALSE)
  }
  invisible(TRUE)
}

af2_assert_cols <- function(dt, cols, name = "object") {
  if (is.null(dt)) stop(name, " is NULL.", call. = FALSE)
  if (!is.data.frame(dt)) stop(name, " must be a data.frame/data.table.", call. = FALSE)
  miss <- setdiff(cols, names(dt))
  if (length(miss)) {
    stop(name, " missing required columns: ", paste(miss, collapse = ", "), call. = FALSE)
  }
  invisible(TRUE)
}

af2_assert_no_dupes <- function(dt, key_cols, name = "object") {
  af2_require("data.table")
  x <- data.table::as.data.table(dt)
  dup <- x[, .N, by = key_cols][N > 1L]
  if (nrow(dup)) {
    stop(name, " has duplicated keys on: ",
         paste(key_cols, collapse = ", "),
         "\nExample dup rows:\n",
         paste(utils::capture.output(print(utils::head(dup, 10))), collapse = "\n"),
         call. = FALSE)
  }
  invisible(TRUE)
}

af2_weekdays_only <- function(dates) {
  w <- weekdays(dates)
  !(w %in% c("Saturday", "Sunday", "sÃ¡bado", "domingo"))
}

af2_make_bizdays_seq <- function(start_date, end_date, cal = "Brazil/B3") {
  start_date <- as.Date(start_date)
  end_date   <- as.Date(end_date)

  # Prefer the official calendar if available
  if (requireNamespace("bizdays", quietly = TRUE)) {
    out <- tryCatch(
      bizdays::bizseq(start_date, end_date, cal),
      error = function(e) NULL
    )
    if (!is.null(out) && length(out)) {
      return(as.Date(out))
    }
  }

  # Fallback: weekdays only
  d <- seq.Date(start_date, end_date, by = "day")
  d[af2_weekdays_only(d)]
}




###############################################################################
### FILE: modules/00_core/README.md
###############################################################################
# Module

Purpose:
- Define INPUT contract
- Define OUTPUT contract
- List functions
- List tests



###############################################################################
### FILE: modules/01_b3_universe/R/build_universe.R
###############################################################################
# v2/modules/01_b3_universe/R/build_universe.R

af2_b3_cache_key <- function(year, include_types) {
  paste0(
    "cotahist_yearly_",
    year, "_",
    paste(sort(include_types), collapse = "-"),
    ".rds"
  )
}

af2_b3_build_universe_year <- function(year,
                                       include_types = NULL,
                                       cfg = NULL,
                                       verbose = TRUE,
                                       use_cache = TRUE,
                                       force_download = FALSE,
                                       reprocess = FALSE) {
  cfg <- cfg %||% af2_get_config()

  include_types <- include_types %||% cfg$include_types
  include_types <- af2_b3_validate_types(include_types)

  # Cache path
  cache_dir <- file.path(cfg$cache_dir, "b3_universe")
  if (!dir.exists(cache_dir)) dir.create(cache_dir, recursive = TRUE)

  cache_file <- file.path(cache_dir, af2_b3_cache_key(year, include_types))

  if (isTRUE(use_cache) && file.exists(cache_file) && !isTRUE(force_download)) {
    if (verbose) af2_log("AF2_B3:", "Using cache: ", cache_file)
    dt_cached <- readRDS(cache_file)
    return(data.table::as.data.table(dt_cached))
  }

  # 1) Lazy fetch
  df_lazy <- af2_b3_fetch_yearly_lazy(
    year = year, cfg = cfg, verbose = verbose,
    force_download = force_download,
    reprocess = reprocess
  )

  # 2) Apply type filters lazily
  lazy_by_type <- af2_b3_apply_type_filters(df_lazy, include_types)

  # 3) Collect each type separately (bounded)
  out_list <- list()

  for (tp in names(lazy_by_type)) {
    if (verbose) af2_log("AF2_B3:", "Collecting type: ", tp, " for ", year)
    df_tp <- dplyr::collect(lazy_by_type[[tp]])
    if (!nrow(df_tp)) next

    dt_min <- af2_b3_select_min_cols(df_tp)
    dt_liq <- af2_b3_unify_liquidity(dt_min)
    dt_liq[, asset_type := tp]

    out_list[[tp]] <- dt_liq
  }

  if (!length(out_list)) {
    stop("af2_b3_build_universe_year: no data returned after filters for year ", year)
  }

  dt_year <- data.table::rbindlist(out_list, use.names = TRUE, fill = TRUE)
  data.table::setorder(dt_year, asset_type, symbol, refdate)

  # 4) Validate contract
  required <- c("symbol", "refdate", "open", "high", "low", "close", "turnover", "qty", "asset_type")
  miss <- setdiff(required, names(dt_year))
  if (length(miss)) {
    stop("Universe contract violated. Missing cols: ", paste(miss, collapse = ", "))
  }

  # 5) Drop obvious junk rows
  dt_year <- dt_year[!is.na(symbol) & symbol != "" & !is.na(refdate) & is.finite(close)]

  if (verbose) {
    af2_log("AF2_B3:", "Year ", year, " rows = ", nrow(dt_year))
    af2_log("AF2_B3:", "Unique symbols = ", length(unique(dt_year$symbol)))
    af2_log("AF2_B3:", "Counts by type:")
    print(dt_year[, .N, by = asset_type][order(-N)])
  }

  # 6) Save cache
  if (isTRUE(use_cache)) {
    saveRDS(dt_year, cache_file)
    if (verbose) af2_log("AF2_B3:", "Wrote cache: ", cache_file)
  }

  dt_year
}

af2_b3_build_universe <- function(years = NULL,
                                  include_types = NULL,
                                  cfg = NULL,
                                  verbose = TRUE,
                                  use_cache = TRUE,
                                  force_download = FALSE,
                                  reprocess = FALSE) {
  cfg <- cfg %||% af2_get_config()
  years <- years %||% cfg$years
  years <- sort(unique(as.integer(years)))

  include_types <- include_types %||% cfg$include_types
  include_types <- af2_b3_validate_types(include_types)

  out <- list()
  for (y in years) {
    out[[as.character(y)]] <- af2_b3_build_universe_year(
      year = y,
      include_types = include_types,
      cfg = cfg,
      verbose = verbose,
      use_cache = use_cache,
      force_download = force_download,
      reprocess = reprocess
    )
  }

  dt_all <- data.table::rbindlist(out, use.names = TRUE, fill = TRUE)
  data.table::setorder(dt_all, asset_type, symbol, refdate)

  dt_all
}

af2_b3_cache_key_window <- function(start_date, end_date, include_types) {
  paste0(
    "cotahist_daily_",
    format(as.Date(start_date), "%Y%m%d"), "_",
    format(as.Date(end_date), "%Y%m%d"), "_",
    paste(sort(include_types), collapse = "-"),
    ".rds"
  )
}

af2_b3_build_universe_window <- function(start_date, end_date,
                                         include_types = NULL,
                                         cfg = NULL,
                                         verbose = TRUE,
                                         use_cache = TRUE,
                                         force_download = FALSE,
                                         reprocess = FALSE) {

  cfg <- cfg %||% af2_get_config()

  include_types <- include_types %||% cfg$include_types
  include_types <- af2_b3_validate_types(include_types)

  start_date <- as.Date(start_date)
  end_date   <- as.Date(end_date)

  # Cache path
  cache_dir <- file.path(cfg$cache_dir, "b3_universe")
  if (!dir.exists(cache_dir)) dir.create(cache_dir, recursive = TRUE)

  cache_file <- file.path(cache_dir, af2_b3_cache_key_window(start_date, end_date, include_types))

  if (isTRUE(use_cache) && file.exists(cache_file) && !isTRUE(force_download)) {
    if (verbose) af2_log("AF2_B3:", "Using cache: ", cache_file)
    dt_cached <- readRDS(cache_file)
    return(data.table::as.data.table(dt_cached))
  }

  # 1) Lazy fetch daily window
  df_lazy <- af2_b3_fetch_daily_lazy(
    start_date = start_date,
    end_date   = end_date,
    cfg = cfg,
    verbose = verbose,
    force_download = force_download,
    reprocess = reprocess
  )

  # 2) Apply type filters lazily
  lazy_by_type <- af2_b3_apply_type_filters(df_lazy, include_types)

  # 3) Collect each type separately (bounded)
  out_list <- list()

  for (tp in names(lazy_by_type)) {
    if (verbose) af2_log("AF2_B3:", "Collecting type: ", tp,
                         " for window ", start_date, " to ", end_date)

    df_tp <- dplyr::collect(lazy_by_type[[tp]])
    if (!nrow(df_tp)) next

    dt_min <- af2_b3_select_min_cols(df_tp)
    dt_liq <- af2_b3_unify_liquidity(dt_min)
    dt_liq[, asset_type := tp]

    out_list[[tp]] <- dt_liq
  }

  if (!length(out_list)) {
    stop("af2_b3_build_universe_window: no data returned after filters.")
  }

  dt_win <- data.table::rbindlist(out_list, use.names = TRUE, fill = TRUE)
  data.table::setorder(dt_win, asset_type, symbol, refdate)

  # 4) Validate contract
  required <- c("symbol", "refdate", "open", "high", "low", "close",
                "turnover", "qty", "asset_type")
  miss <- setdiff(required, names(dt_win))
  if (length(miss)) stop("Universe contract violated. Missing cols: ", paste(miss, collapse = ", "))

  # 5) Drop obvious junk
  dt_win <- dt_win[!is.na(symbol) & symbol != "" & !is.na(refdate) & is.finite(close)]

  if (verbose) {
    af2_log("AF2_B3:", "Window rows = ", nrow(dt_win))
    af2_log("AF2_B3:", "Unique symbols = ", length(unique(dt_win$symbol)))
    af2_log("AF2_B3:", "Counts by type:")
    print(dt_win[, .N, by = asset_type][order(-N)])
  }

  if (isTRUE(use_cache)) {
    saveRDS(dt_win, cache_file)
    if (verbose) af2_log("AF2_B3:", "Wrote cache: ", cache_file)
  }

  dt_win
}



###############################################################################
### FILE: modules/01_b3_universe/R/fetch_daily.R
###############################################################################
# Fetch a daily window with rb3, then return *lazy* dataset handle

af2_b3_fetch_daily_lazy <- function(start_date, end_date,
                                    cfg = NULL, verbose = TRUE,
                                    force_download = FALSE,
                                    reprocess = FALSE,
                                    throttle = TRUE) {

  cfg <- cfg %||% af2_get_config()
  af2_b3_init_rb3(cfg, verbose = verbose)

  start_date <- as.Date(start_date)
  end_date   <- as.Date(end_date)

  # Now uses proper B3 bizdays if available
  refdates <- af2_make_bizdays_seq(start_date, end_date)

  if (!length(refdates)) {
    stop("af2_b3_fetch_daily_lazy: empty refdate sequence.")
  }

  if (verbose) {
    af2_log("AF2_B3:", "fetch_marketdata daily window: ",
            as.character(start_date), " to ", as.character(end_date),
            " (", length(refdates), " dates)")
  }

  ok <- TRUE
  tryCatch({
    rb3::fetch_marketdata(
      "b3-cotahist-daily",
      refdate = refdates,
      throttle = isTRUE(throttle),
      force_download = isTRUE(force_download),
      reprocess = isTRUE(reprocess)
    )
  }, error = function(e) {
    ok <<- FALSE
    af2_log("AF2_B3:", "fetch_marketdata daily failed: ", conditionMessage(e))
  })

  if (!ok) {
    for (d in refdates) {
      tryCatch({
        meta <- rb3::download_marketdata("b3-cotahist-daily", refdate = d)
        rb3::read_marketdata(meta)
      }, error = function(e2) {
        if (verbose) af2_log("AF2_B3:", "daily fallback failed for ", d, ": ", conditionMessage(e2))
      })
    }
  }

  df_lazy <- tryCatch({
    rb3::cotahist_get("daily")
  }, error = function(e) {
    stop("cotahist_get('daily') failed: ", conditionMessage(e))
  })

  df_lazy |>
    dplyr::filter(.data$refdate >= start_date, .data$refdate <= end_date)
}


###############################################################################
### FILE: modules/01_b3_universe/R/fetch_yearly.R
###############################################################################
# v2/modules/01_b3_universe/R/fetch_yearly.R
# Fetch one year with rb3, then return *lazy* dataset handle

af2_b3_fetch_yearly_lazy <- function(year, cfg = NULL, verbose = TRUE,
                                     force_download = FALSE,
                                     reprocess = FALSE) {
  cfg <- cfg %||% af2_get_config()
  af2_b3_init_rb3(cfg, verbose = verbose)

  year <- as.integer(year)

  if (verbose) af2_log("AF2_B3:", "fetch_marketdata yearly: ", year)

  ok <- TRUE
  tryCatch({
    rb3::fetch_marketdata(
      "b3-cotahist-yearly",
      year = year,
      throttle = TRUE,
      force_download = isTRUE(force_download),
      reprocess = isTRUE(reprocess)
    )
  }, error = function(e) {
    ok <<- FALSE
    af2_log("AF2_B3:", "fetch_marketdata failed for ", year, ": ", conditionMessage(e))
  })

  if (!ok) {
    # Fallback path
    tryCatch({
      meta <- rb3::download_marketdata("b3-cotahist-yearly", year = year)
      rb3::read_marketdata(meta)
      af2_log("AF2_B3:", "fallback download/read OK for ", year)
    }, error = function(e2) {
      stop("rb3 fallback download/read failed for ", year, ": ", conditionMessage(e2))
    })
  }

  df_lazy <- tryCatch({
    rb3::cotahist_get("yearly")
  }, error = function(e) {
    stop("cotahist_get('yearly') failed: ", conditionMessage(e))
  })

  start_y <- as.Date(paste0(year, "-01-01"))
  end_y   <- as.Date(paste0(year + 1L, "-01-01"))

  df_lazy <- df_lazy |>
    dplyr::filter(.data$refdate >= start_y, .data$refdate < end_y)

  df_lazy
}



###############################################################################
### FILE: modules/01_b3_universe/R/filter_by_type_rb3.R
###############################################################################
# v2/modules/01_b3_universe/R/filter_by_type_rb3.R
# Apply rb3 class filters BEFORE collect

af2_b3_apply_type_filters <- function(df_lazy, include_types) {
  include_types <- af2_b3_validate_types(include_types)

  # Start with empty list of lazy datasets, bind after filtering
  out_list <- list()

  if ("equity" %in% include_types) {
    out_list[["equity"]] <- rb3::cotahist_filter_equity(df_lazy)
  }
  if ("fii" %in% include_types) {
    out_list[["fii"]] <- rb3::cotahist_filter_fii(df_lazy)
  }
  if ("etf" %in% include_types) {
    out_list[["etf"]] <- rb3::cotahist_filter_etf(df_lazy)
  }
  if ("bdr" %in% include_types) {
    out_list[["bdr"]] <- rb3::cotahist_filter_bdr(df_lazy)
  }

  if (!length(out_list)) {
    stop("No include_types provided after validation.")
  }

  out_list
}



###############################################################################
### FILE: modules/01_b3_universe/R/rb3_init.R
###############################################################################
# v2/modules/01_b3_universe/R/rb3_init.R
# Deterministic rb3 cache bootstrap for v2

af2_b3_init_rb3 <- function(cfg = NULL, verbose = TRUE) {
  cfg <- cfg %||% af2_get_config()

  cache_dir <- file.path(cfg$cache_dir, "rb3")
  if (!dir.exists(cache_dir)) dir.create(cache_dir, recursive = TRUE)

  options(rb3.cachedir = normalizePath(cache_dir, winslash = "/", mustWork = FALSE))

  if (verbose) {
    af2_log("AF2_B3:", "rb3.cachedir = ", getOption("rb3.cachedir"))
  }

  # Bootstrap templates DB (safe no-op if already initialized)
  tryCatch({
    rb3::rb3_bootstrap()
    if (verbose) af2_log("AF2_B3:", "rb3_bootstrap OK.")
  }, error = function(e) {
    # We don't hard fail here because rb3 can still read cached data;
    # but we DO log clearly.
    af2_log("AF2_B3:", "rb3_bootstrap warning: ", conditionMessage(e))
  })

  invisible(TRUE)
}



###############################################################################
### FILE: modules/01_b3_universe/R/select_min_cols.R
###############################################################################
# v2/modules/01_b3_universe/R/select_min_cols.R
# Normalize column names across potential rb3 schema differences

af2_b3_pick_col <- function(dt, alternatives) {
  cand <- intersect(alternatives, names(dt))
  if (length(cand)) cand[1L] else NA_character_
}

af2_b3_select_min_cols <- function(dt) {
  # dt is a collected data.frame/data.table from rb3

  # Defensive mapping of OHLC + liquidity
  col_symbol <- af2_b3_pick_col(dt, c("symbol", "ticker"))
  col_ref    <- af2_b3_pick_col(dt, c("refdate", "date"))
  col_open   <- af2_b3_pick_col(dt, c("open", "price.open", "preco_abertura"))
  col_high   <- af2_b3_pick_col(dt, c("high", "price.high", "preco_maximo"))
  col_low    <- af2_b3_pick_col(dt, c("low", "price.low", "preco_minimo"))
  col_close  <- af2_b3_pick_col(dt, c("close", "price.close", "preco_ultimo"))

  # Liquidity candidates:
  # - financial_volume / volume in BRL
  # - trade_quantity in units
  col_volfin <- af2_b3_pick_col(dt, c("financial_volume", "volume", "vol_fin"))
  col_qty <- af2_b3_pick_col(dt, c("trade_quantity", "quantity", "qty"))

  missing_core <- c(
    symbol = col_symbol,
    refdate = col_ref,
    close = col_close
  )
  if (any(is.na(missing_core))) {
    stop(
      "COTAHIST schema missing core columns. Found names: ",
      paste(names(dt), collapse = ", ")
    )
  }

  out <- data.table::as.data.table(dt)

  out_min <- data.table::data.table(
    symbol  = trimws(as.character(out[[col_symbol]])),
    refdate = as.Date(out[[col_ref]]),
    open    = if (!is.na(col_open))  as.numeric(out[[col_open]])  else NA_real_,
    high    = if (!is.na(col_high))  as.numeric(out[[col_high]])  else NA_real_,
    low     = if (!is.na(col_low))   as.numeric(out[[col_low]])   else NA_real_,
    close   = as.numeric(out[[col_close]]),
    vol_fin = if (!is.na(col_volfin)) as.numeric(out[[col_volfin]]) else NA_real_,
    qty_raw = if (!is.na(col_qty))    as.numeric(out[[col_qty]])    else NA_real_
  )

  out_min
}



###############################################################################
### FILE: modules/01_b3_universe/R/unify_liquidity.R
###############################################################################
# v2/modules/01_b3_universe/R/unify_liquidity.R
# Convert raw liquidity into standardized 'turnover' and 'qty'

af2_b3_unify_liquidity <- function(dt_min) {
  dt <- data.table::as.data.table(dt_min)

  if (!all(c("symbol", "refdate", "close") %in% names(dt))) {
    stop("Liquidity unify requires at least symbol/refdate/close.")
  }

  # qty meaning in rb3 can be ambiguous across templates.
  # We treat 'qty_raw' as units proxy and keep it as qty.
  if (!("qty_raw" %in% names(dt))) dt[, qty_raw := NA_real_]
  if (!("vol_fin" %in% names(dt))) dt[, vol_fin := NA_real_]

  dt[, qty := qty_raw]

  # turnover in BRL:
  # Prefer provided financial volume when present, otherwise fallback to qty * close.
  dt[, turnover := data.table::fifelse(
    is.finite(vol_fin) & vol_fin > 0,
    vol_fin,
    data.table::fifelse(
      is.finite(qty) & qty > 0 & is.finite(close),
      qty * close,
      NA_real_
    )
  )]

  dt[, c("vol_fin", "qty_raw") := NULL]

  dt
}



###############################################################################
### FILE: modules/01_b3_universe/R/validate_types.R
###############################################################################
# v2/modules/01_b3_universe/R/validate_types.R

af2_b3_allowed_types <- c("equity", "fii", "etf", "bdr")

af2_b3_validate_types <- function(include_types) {
  include_types <- unique(tolower(include_types))
  bad <- setdiff(include_types, af2_b3_allowed_types)
  if (length(bad)) {
    stop(
      "Invalid include_types: ", paste(bad, collapse = ", "),
      ". Allowed: ", paste(af2_b3_allowed_types, collapse = ", ")
    )
  }
  include_types
}



###############################################################################
### FILE: modules/01_b3_universe/R/zzz_depends.R
###############################################################################
# v2/modules/01_b3_universe/R/zzz_depends.R
# Centralized dependency + core imports (NO recursion)

if (!exists("af2_get_config")) {
  stop("af2_get_config not found. Source v2/modules/00_core/R/config.R first.")
}
if (!exists("af2_log")) {
  stop("af2_log not found. Source v2/modules/00_core/R/logging.R first.")
}

# Keep it dumb and safe: no wrapper, no indirection.
af2_b3_require <- function(pkgs) {
  for (p in pkgs) {
    if (!requireNamespace(p, quietly = TRUE)) {
      stop("Missing package: ", p)
    }
  }
  invisible(TRUE)
}

af2_b3_require(c("data.table", "dplyr", "lubridate", "rb3"))

suppressPackageStartupMessages({
  library(data.table)
  library(dplyr)
  library(lubridate)
  library(rb3)
})



###############################################################################
### FILE: modules/01_b3_universe/README.md
###############################################################################
# Module

Purpose:
- Define INPUT contract
- Define OUTPUT contract
- List functions
- List tests



###############################################################################
### FILE: modules/02_diagnostics/README.md
###############################################################################
# Module

Purpose:
- Define INPUT contract
- Define OUTPUT contract
- List functions
- List tests



###############################################################################
### FILE: modules/03_corporate_actions/R/build_registry.R
###############################################################################
# v2/modules/03_corporate_actions/R/build_registry.R

af2_ca_cache_file <- function(cfg, tag = "splits_dividends") {
  cache_dir <- file.path(cfg$cache_dir, "corp_actions")
  if (!dir.exists(cache_dir)) dir.create(cache_dir, recursive = TRUE)
  file.path(cache_dir, paste0("corp_actions_", tag, ".rds"))
}

# Per-symbol cache directory
af2_ca_cache_dir_by_symbol <- function(cfg) {
  d <- file.path(cfg$cache_dir, "corp_actions", "by_symbol")
  if (!dir.exists(d)) dir.create(d, recursive = TRUE)
  d
}

af2_ca_cache_file_symbol <- function(cfg, symbol) {
  symbol <- toupper(trimws(as.character(symbol)))
  file.path(af2_ca_cache_dir_by_symbol(cfg), paste0(symbol, ".rds"))
}

af2_ca_build_registry <- function(symbols,
                                  asset_types = NULL,
                                  cfg = NULL,
                                  from = "2018-01-01",
                                  to = Sys.Date(),
                                  verbose = TRUE,
                                  use_cache = TRUE,
                                  force_refresh = FALSE,
                                  n_workers = 1L,
                                  cache_mode = c("batch", "by_symbol")) {

  cfg <- cfg %||% af2_get_config()
  symbols <- as.character(symbols)
  symbols <- toupper(trimws(symbols))
  symbols <- symbols[!is.na(symbols) & nzchar(symbols)]
  symbols <- sort(unique(symbols))

  cache_mode <- match.arg(cache_mode)

  if (cache_mode == "by_symbol") {
    if (!exists("af2_ca_build_registry_by_symbol")) {
      stop("by_symbol cache_mode requested but af2_ca_build_registry_by_symbol is not defined.",
           call. = FALSE)
    }
    return(
      af2_ca_build_registry_by_symbol(
        symbols = symbols,
        asset_types = asset_types,
        cfg = cfg,
        from = from,
        to = to,
        verbose = verbose,
        use_cache = use_cache,
        force_refresh = force_refresh
      )
    )
  }

  if (!length(symbols)) stop("af2_ca_build_registry: empty symbols.", call. = FALSE)

  af2_ca_require("digest")

  from <- as.Date(from)
  to   <- as.Date(to)

  # Bucket 'to' by week to avoid daily refetch storms in dev
  to_tag   <- as.Date(cut(to, breaks = "week"))
  from_tag <- from

  # symbols is already sorted+unique above
  sym_hash <- digest::digest(symbols, algo = "xxhash64")

  tag <- paste0(
    format(from_tag, "%Y%m%d"), "_",
    format(to_tag, "%Y%m%d"), "_",
    length(symbols), "_",
    sym_hash
  )

  cache_file <- af2_ca_cache_file(cfg, tag)

  if (isTRUE(use_cache) && file.exists(cache_file) && !isTRUE(force_refresh)) {
    if (verbose) af2_log("AF2_CA:", "Using cache: ", cache_file)
    return(readRDS(cache_file))
  }

  yahoo_syms <- af2_yahoo_symbol_vec(symbols, asset_types)
  map_dt <- data.table::data.table(
    symbol = symbols,
    yahoo_symbol = yahoo_syms
  )
  map_dt <- map_dt[!is.na(yahoo_symbol)]

  if (!nrow(map_dt)) {
    stop("af2_ca_build_registry: no Yahoo symbols could be mapped.", call. = FALSE)
  }

  if (verbose) {
    af2_log("AF2_CA:", "Fetching corporate actions for ", nrow(map_dt), " symbols (Yahoo).")
  }

  worker_fun <- function(i) {
    sym <- map_dt$symbol[i]
    ysym <- map_dt$yahoo_symbol[i]

    dt_s <- af2_ca_fetch_splits_one(ysym, from = from, to = to, verbose = FALSE)
    dt_d <- af2_ca_fetch_dividends_one(ysym, from = from, to = to, verbose = FALSE)

    out <- data.table::rbindlist(list(dt_s, dt_d), use.names = TRUE, fill = TRUE)
    if (!nrow(out)) return(NULL)

    out[, symbol := sym]
    out[, yahoo_symbol := ysym]

    out
  }

  res_list <- list()

  n_workers <- as.integer(n_workers)
  if (is.na(n_workers) || n_workers < 1L) n_workers <- 1L

  # Windows-safe optional parallel
  if (n_workers > 1L) {
    af2_ca_require("parallel")

    cl <- parallel::makeCluster(n_workers)
    on.exit(try(parallel::stopCluster(cl), silent = TRUE), add = TRUE)

    parallel::clusterExport(
      cl,
      varlist = c(
        "map_dt",
        "from", "to",
        "af2_ca_fetch_splits_one",
        "af2_ca_fetch_dividends_one",
        "af2_ca_with_retry",
        "af2_ca_is_rate_limit_error",
        "af2_log"
      ),
      envir = environment()
    )
    parallel::clusterEvalQ(cl, {
      library(data.table)
      library(quantmod)
      library(xts)
      library(zoo)
    })

    idx <- seq_len(nrow(map_dt))
    res_list <- parallel::parLapply(cl, idx, worker_fun)

  } else {
    for (i in seq_len(nrow(map_dt))) {
      res_list[[i]] <- worker_fun(i)
      if (verbose && i %% 50 == 0) {
        af2_log("AF2_CA:", "Progress: ", i, "/", nrow(map_dt))
      }
    }
  }

  dt_all <- data.table::rbindlist(res_list, use.names = TRUE, fill = TRUE)

  if (!nrow(dt_all)) {
    # It is valid to have zero actions, but keep schema stable
    dt_all <- data.table::data.table(
      symbol = character(),
      yahoo_symbol = character(),
      refdate = as.Date(character()),
      action_type = character(),
      value = numeric(),
      source = character()
    )
  }

  # Normalize + order
  dt_all[, refdate := as.Date(refdate)]
  dt_all <- dt_all[order(symbol, action_type, refdate)]

  # Basic contract sanity
  req <- c("symbol", "yahoo_symbol", "refdate", "action_type", "value", "source")
  miss <- setdiff(req, names(dt_all))
  if (length(miss)) stop("Corporate actions registry missing cols: ", paste(miss, collapse = ", "))

  if (isTRUE(use_cache)) {
    saveRDS(dt_all, cache_file)
    if (verbose) af2_log("AF2_CA:", "Wrote cache: ", cache_file)
  }

  dt_all
}

af2_ca_build_registry_by_symbol <- function(symbols,
                                            asset_types = NULL,
                                            cfg = NULL,
                                            from = "2018-01-01",
                                            to = Sys.Date(),
                                            verbose = TRUE,
                                            use_cache = TRUE,
                                            force_refresh = FALSE) {

  cfg <- cfg %||% af2_get_config()

  symbols <- as.character(symbols)
  symbols <- toupper(trimws(symbols))
  symbols <- symbols[!is.na(symbols) & nzchar(symbols)]
  symbols <- sort(unique(symbols))

  if (!length(symbols)) {
    stop("af2_ca_build_registry_by_symbol: empty symbols.", call. = FALSE)
  }

  from <- as.Date(from)
  to   <- as.Date(to)

  yahoo_syms <- af2_yahoo_symbol_vec(symbols, asset_types)
  map_dt <- data.table::data.table(
    symbol = symbols,
    yahoo_symbol = yahoo_syms
  )
  map_dt <- map_dt[!is.na(yahoo_symbol)]

  if (!nrow(map_dt)) {
    stop("af2_ca_build_registry_by_symbol: no Yahoo symbols could be mapped.", call. = FALSE)
  }

  if (verbose) {
    af2_log("AF2_CA:", "by_symbol mode: candidates=", nrow(map_dt))
  }

  res_list <- vector("list", nrow(map_dt))

  for (i in seq_len(nrow(map_dt))) {

    sym  <- map_dt$symbol[i]
    ysym <- map_dt$yahoo_symbol[i]

    cache_file <- af2_ca_cache_file_symbol(cfg, sym)

    if (isTRUE(use_cache) && file.exists(cache_file) && !isTRUE(force_refresh)) {
      dt_cached <- readRDS(cache_file)
      dt_cached <- data.table::as.data.table(dt_cached)
      if (nrow(dt_cached)) {
        dt_cached[, refdate := as.Date(refdate)]
        dt_cached <- dt_cached[refdate >= from & refdate <= to]
      }
      res_list[[i]] <- dt_cached
      next
    }

    dt_s <- af2_ca_fetch_splits_one(ysym, from = from, to = to, verbose = FALSE)
    dt_d <- af2_ca_fetch_dividends_one(ysym, from = from, to = to, verbose = FALSE)

    out <- data.table::rbindlist(list(dt_s, dt_d), use.names = TRUE, fill = TRUE)

    if (!nrow(out)) {
      out <- data.table::data.table(
        symbol = character(),
        yahoo_symbol = character(),
        refdate = as.Date(character()),
        action_type = character(),
        value = numeric(),
        source = character()
      )[0]
    } else {
      out[, symbol := sym]
      out[, yahoo_symbol := ysym]
    }

    if (isTRUE(use_cache)) {
      # Save even empty to avoid refetch storms
      saveRDS(out, cache_file)
    }

    res_list[[i]] <- out

    if (verbose && i %% 50 == 0) {
      af2_log("AF2_CA:", "by_symbol progress: ", i, "/", nrow(map_dt))
    }
  }

  dt_all <- data.table::rbindlist(res_list, use.names = TRUE, fill = TRUE)

  if (!nrow(dt_all)) {
    dt_all <- data.table::data.table(
      symbol = character(),
      yahoo_symbol = character(),
      refdate = as.Date(character()),
      action_type = character(),
      value = numeric(),
      source = character()
    )
  }

  dt_all[, refdate := as.Date(refdate)]
  dt_all <- dt_all[order(symbol, action_type, refdate)]

  req <- c("symbol", "yahoo_symbol", "refdate", "action_type", "value", "source")
  miss <- setdiff(req, names(dt_all))
  if (length(miss)) stop("Corporate actions registry missing cols: ", paste(miss, collapse = ", "))

  dt_all
}



###############################################################################
### FILE: modules/03_corporate_actions/R/fetch_dividends_quantmod.R
###############################################################################
# v2/modules/03_corporate_actions/R/fetch_dividends_quantmod.R
source("v2/modules/03_corporate_actions/R/yahoo_retry.R")

af2_ca_fetch_dividends_one <- function(yahoo_symbol,
                                       from = "2018-01-01",
                                       to = Sys.Date(),
                                       verbose = FALSE,
                                       split.adjust = TRUE) {
  if (is.na(yahoo_symbol) || !nzchar(yahoo_symbol)) return(NULL)

  div_fun <- quantmod::getDividends
  fml <- names(formals(div_fun))

  call_args <- list(
    Symbols = yahoo_symbol,
    from = from,
    to = to,
    auto.assign = FALSE,
    verbose = verbose
  )

  if ("split.adjust" %in% fml) {
    call_args$split.adjust <- split.adjust
  }

  x <- af2_ca_with_retry(
    function() do.call(div_fun, call_args),
    max_tries = 4L,
    base_sleep = 1.5,
    verbose = verbose
  )

  if (is.null(x)) return(NULL)
  if (!inherits(x, "xts")) return(NULL)
  if (NROW(x) == 0) return(NULL)

  dt <- data.table::data.table(
    yahoo_symbol = yahoo_symbol,
    refdate = as.Date(zoo::index(x)),
    action_type = "dividend",
    value = as.numeric(zoo::coredata(x)),
    source = "yahoo"
  )

  dt[is.finite(value) & value != 0 & !is.na(refdate)]
}


###############################################################################
### FILE: modules/03_corporate_actions/R/fetch_splits_quantmod.R
###############################################################################
# v2/modules/03_corporate_actions/R/fetch_splits_quantmod.R
source("v2/modules/03_corporate_actions/R/yahoo_retry.R")

af2_ca_fetch_splits_one <- function(yahoo_symbol,
                                    from = "2018-01-01",
                                    to = Sys.Date(),
                                    verbose = FALSE) {
  if (is.na(yahoo_symbol) || !nzchar(yahoo_symbol)) return(NULL)

  x <- af2_ca_with_retry(
    function() {
      quantmod::getSplits(
        yahoo_symbol,
        from = from,
        to = to,
        auto.assign = FALSE,
        verbose = verbose
      )
    },
    max_tries = 4L,
    base_sleep = 1.5,
    verbose = verbose
  )

  # quantmod returns NA if no split data
  if (is.null(x)) return(NULL)
  if (!inherits(x, "xts")) return(NULL)
  if (NROW(x) == 0) return(NULL)
  if (length(x) == 1 && is.na(as.numeric(x))) return(NULL)

  # xts index = date, coredata = ratio
  dt <- data.table::data.table(
    yahoo_symbol = yahoo_symbol,
    refdate = as.Date(zoo::index(x)),
    action_type = "split",
    value = as.numeric(zoo::coredata(x)),
    source = "yahoo"
  )

  dt[is.finite(value) & !is.na(refdate)]
}


###############################################################################
### FILE: modules/03_corporate_actions/R/select_candidates.R
###############################################################################
# v2/modules/03_corporate_actions/R/select_candidates.R

af2_ca_select_candidates <- function(universe_raw, cfg = NULL, verbose = TRUE) {

  af2_require(c("data.table"))
  cfg <- cfg %||% af2_get_config()

  dt <- data.table::as.data.table(universe_raw)

  # Allow either turnover or vol_fin (rb3 differences)
  if (!"turnover" %in% names(dt) && "vol_fin" %in% names(dt)) {
    dt[, turnover := vol_fin]
  }

  # Minimal columns needed for the prefilter
  af2_assert_cols(
    dt,
    c("symbol", "refdate", "close", "turnover", "asset_type"),
    name = "universe_raw(prefilter)"
  )

  # Normalize
  dt[, symbol := toupper(trimws(as.character(symbol)))]
  dt[, asset_type := tolower(trimws(as.character(asset_type)))]
  dt[, refdate := as.Date(refdate)]
  dt[, close := as.numeric(close)]
  dt[, turnover := as.numeric(turnover)]

  # -------------------------------
  # 0) Define recent window
  # -------------------------------
  end_date <- max(dt$refdate, na.rm = TRUE)

  recent_days <- as.integer(cfg$ca_prefilter_recent_days %||% 252L)
  if (!is.finite(recent_days) || recent_days < 20L) recent_days <- 252L

  # Optional tighter liquidity window (new knob; fallback to recent_days)
  liq_window_days <- as.integer(cfg$ca_prefilter_liq_window_days %||% 63L)
  if (!is.finite(liq_window_days) || liq_window_days < 20L) liq_window_days <- min(63L, recent_days)

  # Active trading filter (new knob)
  active_days <- as.integer(cfg$ca_prefilter_active_days %||% 10L)
  if (!is.finite(active_days) || active_days < 1L) active_days <- 10L

  # We approximate "last N bizdays" by date window,
  # since universe_raw already comes from B3 business dates.
  recent_start <- end_date - ceiling(recent_days * 1.6)
  liq_start    <- end_date - ceiling(liq_window_days * 1.6)
  active_start <- end_date - ceiling(active_days * 1.6)

  dt_recent <- dt[refdate >= recent_start & refdate <= end_date]
  data.table::setorder(dt_recent, symbol, refdate)
  dt_recent <- dt_recent[, tail(.SD, recent_days), by = symbol]

  dt_liqwin <- dt[refdate >= liq_start & refdate <= end_date]

  # -------------------------------
  # 1) Active symbols (must trade recently)
  # -------------------------------
  # A "trade" is any day with a finite close
  active_dt <- dt_recent[is.finite(close) & !is.na(close),
                         .(last_trade = max(refdate, na.rm = TRUE)),
                         by = .(symbol, asset_type)]

  active_dt[, is_active := last_trade >= active_start]
  active_syms <- active_dt[is_active == TRUE, unique(symbol)]

  if (verbose) {
    af2_log("AF2_CA_PREF:", "Active symbols= ", length(active_syms))
  }

  # If active filter is too strict in some environments, fail soft
  if (!length(active_syms)) {
    active_syms <- unique(dt_recent$symbol)
  }

  # -------------------------------
  # 2) Liquidity filter (short window)
  # -------------------------------
  dt_liqwin <- dt_liqwin[symbol %in% active_syms]

  dt_liqwin[, traded_flag := is.finite(close) & !is.na(close)]

  liq <- dt_liqwin[, .(
    median_turnover = stats::median(turnover, na.rm = TRUE),
    days_traded_ratio = mean(traded_flag, na.rm = TRUE)
  ), by = .(symbol, asset_type)]

  liq[is.na(median_turnover), median_turnover := 0]
  liq[is.na(days_traded_ratio), days_traded_ratio := 0]

  liq_ok_dt <- liq[
    median_turnover >= (cfg$min_turnover %||% 5e5) &
      days_traded_ratio >= (cfg$min_days_traded_ratio %||% 0.8)
  ]

  liq_ok_syms <- liq_ok_dt$symbol

  if (verbose) {
    af2_log("AF2_CA_PREF:", "Liquidity ok symbols= ", length(unique(liq_ok_syms)))
  }

  # -------------------------------
  # 3) Gap-flag detector (recent window)
  # -------------------------------
  dt_gap <- dt_recent[symbol %in% liq_ok_syms]
  data.table::setorder(dt_gap, symbol, refdate)

  dt_gap[, close_lag := data.table::shift(close, 1L), by = symbol]
  dt_gap[, ret_1d := data.table::fifelse(
    is.finite(close) & is.finite(close_lag) & close_lag > 0,
    close / close_lag - 1,
    NA_real_
  )]
  dt_gap[, close_lag := NULL]

  # Apply per-type thresholds
  thr_map <- data.table::data.table(
    asset_type = c("equity", "fii", "etf", "bdr"),
    thr = c(
      cfg$ca_prefilter_gap_equity %||% -0.20,
      cfg$ca_prefilter_gap_fii    %||% -0.12,
      cfg$ca_prefilter_gap_etf    %||% -0.15,
      cfg$ca_prefilter_gap_bdr    %||% -0.20
    )
  )

  dt_gap <- merge(dt_gap, thr_map, by = "asset_type", all.x = TRUE)

  gap_flags <- dt_gap[
    is.finite(ret_1d) & ret_1d <= thr,
    .(has_gap = TRUE),
    by = .(symbol)
  ]

  gap_syms <- gap_flags$symbol

  if (verbose) {
    af2_log("AF2_CA_PREF:", "Gap-flag symbols= ", length(unique(gap_syms)))
  }

  # -------------------------------
  # 4) Priority ranking source
  # -------------------------------
  # Priority = liquidity rank within liq_ok set
  # (Cheap, robust, and type-aware)
  liq_ok_dt[, liq_rank_overall := data.table::frank(-median_turnover, ties.method = "first")]
  liq_ok_dt[, liq_rank_type := data.table::frank(-median_turnover, ties.method = "first"), by = asset_type]

  top_overall <- as.integer(cfg$ca_prefilter_top_n_overall %||% 200L)
  top_by_type <- as.integer(cfg$ca_prefilter_top_n_by_type %||% 50L)
  max_cand    <- as.integer(cfg$ca_prefilter_max_candidates %||% 300L)

  if (!is.finite(top_overall) || top_overall < 1L) top_overall <- 200L
  if (!is.finite(top_by_type) || top_by_type < 1L) top_by_type <- 50L
  if (!is.finite(max_cand) || max_cand < 50L) max_cand <- 300L

  c1 <- liq_ok_dt[liq_rank_overall <= top_overall, unique(symbol)]
  c2 <- liq_ok_dt[liq_rank_type <= top_by_type, unique(symbol)]

  # -------------------------------
  # 5) Union + cap
  # -------------------------------
  cand_all <- unique(c(c1, c2, gap_syms))

  # If still empty (edge-case data), fall back to liquidity-ok
  if (!length(cand_all)) cand_all <- unique(liq_ok_syms)

  # Apply hard cap using priority order
  if (length(cand_all) > max_cand && nrow(liq_ok_dt)) {
    # Build a priority table for deterministic trimming
    pri <- liq_ok_dt[, .(symbol, priority = liq_rank_overall)]
    pri <- pri[order(priority)]
    pri_syms <- pri$symbol

    # Keep candidate order: priority first, then anything else
    ordered <- unique(c(intersect(pri_syms, cand_all), cand_all))
    cand_all <- head(ordered, max_cand)
  }

  if (verbose) {
    af2_log("AF2_CA_PREF:", "Candidates final= ", length(cand_all))
    #af2_log("AF2_CA_PREF:", "Selective actions enabled= ", isTRUE(cfg$enable_selective_actions))
    #af2_log("AF2_CA_PREF:", "Yahoo candidate symbols= ", length(cand_all))
  }

  cand_all
}



###############################################################################
### FILE: modules/03_corporate_actions/R/yahoo_retry.R
###############################################################################
# v2/modules/03_corporate_actions/R/yahoo_retry.R

af2_ca_is_rate_limit_error <- function(msg) {
  if (is.null(msg) || !nzchar(msg)) return(FALSE)
  grepl("429|Too Many Requests|rate limit", msg, ignore.case = TRUE)
}

af2_ca_with_retry <- function(fun,
                              max_tries = 4L,
                              base_sleep = 1.5,
                              jitter = 0.2,
                              verbose = FALSE) {

  max_tries <- as.integer(max_tries)
  if (is.na(max_tries) || max_tries < 1L) max_tries <- 1L

  for (k in seq_len(max_tries)) {
    out <- tryCatch(fun(), error = function(e) e)

    if (!inherits(out, "error")) return(out)

    msg <- conditionMessage(out)

    # Only backoff if it looks like rate limiting
    if (!af2_ca_is_rate_limit_error(msg)) {
      if (verbose) af2_log("AF2_CA:", "Non-429 error: ", msg)
      return(NULL)
    }

    # Backoff
    if (k < max_tries) {
      sleep_s <- base_sleep * (2^(k - 1))
      sleep_s <- sleep_s * runif(1, 1 - jitter, 1 + jitter)
      if (verbose) {
        af2_log("AF2_CA:", "429 detected. Retry ", k, "/", max_tries,
                " sleeping ~", round(sleep_s, 2), "s")
      }
      Sys.sleep(sleep_s)
    } else {
      if (verbose) af2_log("AF2_CA:", "429 persisted after retries.")
    }
  }

  NULL
}



###############################################################################
### FILE: modules/03_corporate_actions/R/yahoo_symbol_map.R
###############################################################################
# v2/modules/03_corporate_actions/R/yahoo_symbol_map.R

af2_yahoo_symbol <- function(symbol, asset_type = NULL) {
  s <- toupper(trimws(as.character(symbol)))
  if (is.na(s) || !nzchar(s)) return(NA_character_)

  # If user already passed a Yahoo-style symbol, respect it
  if (grepl("\\.", s)) return(s)

  # Most B3 assets on Yahoo use .SA
  # This covers equities, FIIs, ETFs, many BDRs.
  paste0(s, ".SA")
}

af2_yahoo_symbol_vec <- function(symbols, asset_types = NULL) {
  if (is.null(asset_types)) {
    vapply(symbols, af2_yahoo_symbol, character(1))
  } else {
    mapply(af2_yahoo_symbol, symbols, asset_types, USE.NAMES = FALSE)
  }
}


###############################################################################
### FILE: modules/03_corporate_actions/R/zzz_depends.R
###############################################################################
# v2/modules/03_corporate_actions/R/zzz_depends.R

if (!exists("af2_get_config")) {
  stop("af2_get_config not found. Source v2/modules/00_core/R/config.R first.")
}
if (!exists("af2_log")) {
  stop("af2_log not found. Source v2/modules/00_core/R/logging.R first.")
}
if (!exists("%||%")) {
  stop("%||% not found. Source v2/modules/00_core/R/utils.R first.")
}

af2_ca_require <- function(pkgs) {
  for (p in pkgs) {
    if (!requireNamespace(p, quietly = TRUE)) {
      stop("Missing package for corporate actions module: ", p, call. = FALSE)
    }
  }
  invisible(TRUE)
}

# quantmod is the key dependency here
af2_ca_require(c("data.table", "quantmod", "xts"))

suppressPackageStartupMessages({
  library(data.table)
  library(quantmod)
  library(xts)
})



###############################################################################
### FILE: modules/03_corporate_actions/README.md
###############################################################################
# Module

Purpose:
- Define INPUT contract
- Define OUTPUT contract
- List functions
- List tests



###############################################################################
### FILE: modules/03_corporate_actions/codebase_dump_03_corporate_actions.txt
###############################################################################
Project structure for '/c/Users/Galaxy/LEVI/Projetos R/autofinance_R/v2/modules/03_corporate_actions':
===============================================================================
  R/build_registry.R
  R/fetch_dividends_quantmod.R
  R/fetch_splits_quantmod.R
  R/yahoo_symbol_map.R
  R/zzz_depends.R
  README.md



###############################################################################
### FILE: R/build_registry.R
###############################################################################
# v2/modules/03_corporate_actions/R/build_registry.R

af2_ca_cache_file <- function(cfg, tag = "splits_dividends") {
  cache_dir <- file.path(cfg$cache_dir, "corp_actions")
  if (!dir.exists(cache_dir)) dir.create(cache_dir, recursive = TRUE)
  file.path(cache_dir, paste0("corp_actions_", tag, ".rds"))
}

af2_ca_build_registry <- function(symbols,
                                  asset_types = NULL,
                                  cfg = NULL,
                                  from = "2018-01-01",
                                  to = Sys.Date(),
                                  verbose = TRUE,
                                  use_cache = TRUE,
                                  force_refresh = FALSE,
                                  n_workers = 1L) {

  cfg <- cfg %||% af2_get_config()
  symbols <- unique(toupper(trimws(as.character(symbols))))
  symbols <- symbols[!is.na(symbols) & nzchar(symbols)]
  if (!length(symbols)) stop("af2_ca_build_registry: empty symbols.", call. = FALSE)

  tag <- paste0(
    format(as.Date(from), "%Y%m%d"), "_",
    format(as.Date(to), "%Y%m%d"), "_",
    length(symbols)
  )
  cache_file <- af2_ca_cache_file(cfg, tag)

  if (isTRUE(use_cache) && file.exists(cache_file) && !isTRUE(force_refresh)) {
    if (verbose) af2_log("AF2_CA:", "Using cache: ", cache_file)
    return(readRDS(cache_file))
  }

  yahoo_syms <- af2_yahoo_symbol_vec(symbols, asset_types)
  map_dt <- data.table::data.table(
    symbol = symbols,
    yahoo_symbol = yahoo_syms
  )
  map_dt <- map_dt[!is.na(yahoo_symbol)]

  if (!nrow(map_dt)) {
    stop("af2_ca_build_registry: no Yahoo symbols could be mapped.", call. = FALSE)
  }

  if (verbose) {
    af2_log("AF2_CA:", "Fetching corporate actions for ", nrow(map_dt), " symbols (Yahoo).")
  }

  worker_fun <- function(i) {
    sym <- map_dt$symbol[i]
    ysym <- map_dt$yahoo_symbol[i]

    dt_s <- af2_ca_fetch_splits_one(ysym, from = from, to = to, verbose = FALSE)
    dt_d <- af2_ca_fetch_dividends_one(ysym, from = from, to = to, verbose = FALSE)

    out <- data.table::rbindlist(list(dt_s, dt_d), use.names = TRUE, fill = TRUE)
    if (!nrow(out)) return(NULL)

    out[, symbol := sym]
    out[, yahoo_symbol := ysym]

    out
  }

  res_list <- list()

  n_workers <- as.integer(n_workers)
  if (is.na(n_workers) || n_workers < 1L) n_workers <- 1L

  # Windows-safe optional parallel
  if (n_workers > 1L) {
    af2_ca_require("parallel")

    cl <- parallel::makeCluster(n_workers)
    on.exit(try(parallel::stopCluster(cl), silent = TRUE), add = TRUE)

    parallel::clusterExport(
      cl,
      varlist = c(
        "map_dt",
        "from", "to",
        "af2_ca_fetch_splits_one",
        "af2_ca_fetch_dividends_one"
      ),
      envir = environment()
    )
    parallel::clusterEvalQ(cl, {
      library(data.table)
      library(quantmod)
      library(xts)
      library(zoo)
    })

    idx <- seq_len(nrow(map_dt))
    res_list <- parallel::parLapply(cl, idx, worker_fun)

  } else {
    for (i in seq_len(nrow(map_dt))) {
      res_list[[i]] <- worker_fun(i)
      if (verbose && i %% 50 == 0) {
        af2_log("AF2_CA:", "Progress: ", i, "/", nrow(map_dt))
      }
    }
  }

  dt_all <- data.table::rbindlist(res_list, use.names = TRUE, fill = TRUE)

  if (!nrow(dt_all)) {
    # It is valid to have zero actions, but keep schema stable
    dt_all <- data.table::data.table(
      symbol = character(),
      yahoo_symbol = character(),
      refdate = as.Date(character()),
      action_type = character(),
      value = numeric(),
      source = character()
    )
  }

  # Normalize + order
  dt_all[, refdate := as.Date(refdate)]
  dt_all <- dt_all[order(symbol, action_type, refdate)]

  # Basic contract sanity
  req <- c("symbol", "yahoo_symbol", "refdate", "action_type", "value", "source")
  miss <- setdiff(req, names(dt_all))
  if (length(miss)) stop("Corporate actions registry missing cols: ", paste(miss, collapse = ", "))

  if (isTRUE(use_cache)) {
    saveRDS(dt_all, cache_file)
    if (verbose) af2_log("AF2_CA:", "Wrote cache: ", cache_file)
  }

  dt_all
}



###############################################################################
### FILE: R/fetch_dividends_quantmod.R
###############################################################################
# v2/modules/03_corporate_actions/R/fetch_dividends_quantmod.R

af2_ca_fetch_dividends_one <- function(yahoo_symbol,
                                       from = "2018-01-01",
                                       to = Sys.Date(),
                                       verbose = FALSE,
                                       split.adjust = TRUE) {
  if (is.na(yahoo_symbol) || !nzchar(yahoo_symbol)) return(NULL)

  x <- tryCatch(
    quantmod::getDividends(
      yahoo_symbol,
      from = from,
      to = to,
      auto.assign = FALSE,
      verbose = verbose,
      split.adjust = split.adjust
    ),
    error = function(e) {
      if (verbose) af2_log("AF2_CA:", "getDividends failed for ", yahoo_symbol, ": ", conditionMessage(e))
      NULL
    }
  )

  if (is.null(x)) return(NULL)
  if (!inherits(x, "xts")) return(NULL)
  if (NROW(x) == 0) return(NULL)

  dt <- data.table::data.table(
    yahoo_symbol = yahoo_symbol,
    refdate = as.Date(zoo::index(x)),
    action_type = "dividend",
    value = as.numeric(zoo::coredata(x)),
    source = "yahoo"
  )

  dt[is.finite(value) & value != 0 & !is.na(refdate)]
}


###############################################################################
### FILE: R/fetch_splits_quantmod.R
###############################################################################
# v2/modules/03_corporate_actions/R/fetch_splits_quantmod.R

af2_ca_fetch_splits_one <- function(yahoo_symbol,
                                    from = "2018-01-01",
                                    to = Sys.Date(),
                                    verbose = FALSE) {
  if (is.na(yahoo_symbol) || !nzchar(yahoo_symbol)) return(NULL)

  x <- tryCatch(
    quantmod::getSplits(
      yahoo_symbol,
      from = from,
      to = to,
      auto.assign = FALSE,
      verbose = verbose
    ),
    error = function(e) {
      if (verbose) af2_log("AF2_CA:", "getSplits failed for ", yahoo_symbol, ": ", conditionMessage(e))
      NULL
    }
  )

  # quantmod returns NA if no split data
  if (is.null(x)) return(NULL)
  if (length(x) == 1 && is.na(as.numeric(x))) return(NULL)
  if (!inherits(x, "xts")) return(NULL)

  # xts index = date, coredata = ratio
  dt <- data.table::data.table(
    yahoo_symbol = yahoo_symbol,
    refdate = as.Date(zoo::index(x)),
    action_type = "split",
    value = as.numeric(zoo::coredata(x)),
    source = "yahoo"
  )

  dt[is.finite(value) & !is.na(refdate)]
}


###############################################################################
### FILE: R/yahoo_symbol_map.R
###############################################################################
# v2/modules/03_corporate_actions/R/yahoo_symbol_map.R

af2_yahoo_symbol <- function(symbol, asset_type = NULL) {
  s <- toupper(trimws(as.character(symbol)))
  if (is.na(s) || !nzchar(s)) return(NA_character_)

  # If user already passed a Yahoo-style symbol, respect it
  if (grepl("\\.", s)) return(s)

  # Most B3 assets on Yahoo use .SA
  # This covers equities, FIIs, ETFs, many BDRs.
  paste0(s, ".SA")
}

af2_yahoo_symbol_vec <- function(symbols, asset_types = NULL) {
  if (is.null(asset_types)) {
    vapply(symbols, af2_yahoo_symbol, character(1))
  } else {
    mapply(af2_yahoo_symbol, symbols, asset_types, USE.NAMES = FALSE)
  }
}


###############################################################################
### FILE: R/zzz_depends.R
###############################################################################
# v2/modules/03_corporate_actions/R/zzz_depends.R

if (!exists("af2_get_config")) {
  stop("af2_get_config not found. Source v2/modules/00_core/R/config.R first.")
}
if (!exists("af2_log")) {
  stop("af2_log not found. Source v2/modules/00_core/R/logging.R first.")
}
if (!exists("%||%")) {
  stop("%||% not found. Source v2/modules/00_core/R/utils.R first.")
}

af2_ca_require <- function(pkgs) {
  for (p in pkgs) {
    if (!requireNamespace(p, quietly = TRUE)) {
      stop("Missing package for corporate actions module: ", p, call. = FALSE)
    }
  }
  invisible(TRUE)
}

# quantmod is the key dependency here
af2_ca_require(c("data.table", "quantmod", "xts"))

suppressPackageStartupMessages({
  library(data.table)
  library(quantmod)
  library(xts)
})



###############################################################################
### FILE: README.md
###############################################################################
# Module

Purpose:
- Define INPUT contract
- Define OUTPUT contract
- List functions
- List tests






###############################################################################
### FILE: modules/04_adjuster/R/apply_adjustments.R
###############################################################################
# v2/modules/04_adjuster/R/apply_adjustments.R

# Helper: reverse cumulative product excluding same-day event.
# For a vector of daily event factors:
# factor(date) = product of event_factors for events with refdate > date
af2_adj_rev_cumprod_exclusive <- function(x) {
  if (!length(x)) return(x)
  v <- rev(cumprod(rev(x)))
  data.table::shift(v, 1L, type = "lead", fill = 1)
}

# Compute adjustments for one symbol
af2_adj_compute_symbol_adjustments <- function(dt_sym, ev_sym) {
  dt <- data.table::as.data.table(dt_sym)
  data.table::setorder(dt, refdate)

  # Universe raw contract minimum for adjuster
  af2_assert_cols(dt,
                  c("symbol", "refdate", "open", "high", "low", "close",
                    "turnover", "qty", "asset_type"),
                  name = "universe_raw(symbol)")

  # Prep event table for this symbol
  ev <- data.table::as.data.table(ev_sym)
  if (!nrow(ev)) {
    ev <- data.table(
      symbol = unique(dt$symbol)[1],
      refdate = as.Date(character()),
      split_value = numeric(),
      div_cash = numeric(),
      source_mask = character(),
      has_manual = logical()
    )
  }

  # Join events onto daily grid
  dt[, split_value := 1]
  dt[, div_cash := 0]
  dt[, source_mask := "none"]
  dt[, has_manual := FALSE]

  if (nrow(ev)) {
    dt[ev, on = .(symbol, refdate),
       `:=`(
         split_value = i.split_value,
         div_cash = i.div_cash,
         source_mask = i.source_mask,
         has_manual = i.has_manual
       )]
  }

  dt[is.na(split_value), split_value := 1]
  dt[is.na(div_cash), div_cash := 0]
  dt[is.na(source_mask), source_mask := "none"]
  dt[is.na(has_manual), has_manual := FALSE]

  # -----------------------
  # 1) Split cumulative factor
  # -----------------------
  dt[, split_factor_cum := af2_adj_rev_cumprod_exclusive(split_value)]

  # Apply split adjustment to OHLC
  dt[, open_adj_split  := open  * split_factor_cum]
  dt[, high_adj_split  := high  * split_factor_cum]
  dt[, low_adj_split   := low   * split_factor_cum]
  dt[, close_adj_split := close * split_factor_cum]

  # -----------------------
  # 2) Dividend event factor
  # -----------------------
  dt[, close_prev := data.table::shift(close_adj_split, 1L)]

  # Default no-dividend factor
  dt[, div_factor_event := 1]

  # Flag issues when we cannot compute a sane dividend factor
  dt[, issue_div := FALSE]

  has_div_row <- dt$div_cash > 0

  if (any(has_div_row, na.rm = TRUE)) {
    # bad cases
    bad_idx <- which(
      has_div_row & (
        !is.finite(dt$close_prev) |
          is.na(dt$close_prev) |
          dt$close_prev <= 0 |
          dt$div_cash >= dt$close_prev
      )
    )
    if (length(bad_idx)) dt[bad_idx, issue_div := TRUE]

    # good cases
    good_idx <- which(
      has_div_row &
        is.finite(dt$close_prev) &
        !is.na(dt$close_prev) &
        dt$close_prev > 0 &
        dt$div_cash < dt$close_prev
    )

    if (length(good_idx)) {
      dt[good_idx,
         div_factor_event := (close_prev - div_cash) / close_prev]
    }
  }

  # Guarantee numeric stability
  dt[!is.finite(div_factor_event) | is.na(div_factor_event), div_factor_event := 1]
  dt[div_factor_event < 0, div_factor_event := 0]

  # -----------------------
  # 3) Dividend cumulative factor
  # -----------------------
  dt[, div_factor_cum := af2_adj_rev_cumprod_exclusive(div_factor_event)]

  # -----------------------
  # 4) Final factor + apply
  # -----------------------
  dt[, adj_factor_final := split_factor_cum * div_factor_cum]

  dt[, open_adj_final  := open  * adj_factor_final]
  dt[, high_adj_final  := high  * adj_factor_final]
  dt[, low_adj_final   := low   * adj_factor_final]
  dt[, close_adj_final := close * adj_factor_final]

  # Prepare adjustment timeline output for auditing
  adj_timeline <- dt[, .(
    symbol,
    refdate,
    split_value,
    div_cash,
    split_factor_cum,
    div_factor_event,
    div_factor_cum,
    adj_factor_final,
    source_mask,
    has_manual,
    issue_div
  )]

  list(
    panel_cols = dt,
    adjustments = adj_timeline
  )
}

# Apply adjustments to full universe_raw
# Returns:
#   list(panel_adj = ..., adjustments = ...)
af2_adj_apply_adjustments <- function(universe_raw,
                                      events,
                                      verbose = TRUE) {

  dt <- data.table::as.data.table(universe_raw)
  data.table::setorder(dt, symbol, refdate)

  ev <- data.table::as.data.table(events)
  if (!nrow(ev)) {
    ev <- data.table(
      symbol = character(),
      refdate = as.Date(character()),
      split_value = numeric(),
      div_cash = numeric(),
      source_mask = character(),
      has_manual = logical()
    )
  }

  syms <- unique(dt$symbol)

  res_pan <- vector("list", length(syms))
  res_adj <- vector("list", length(syms))

  for (i in seq_along(syms)) {
    s <- syms[i]

    dt_sym <- dt[symbol == s]
    ev_sym <- ev[symbol == s]

    out <- af2_adj_compute_symbol_adjustments(dt_sym, ev_sym)

    res_pan[[i]] <- out$panel_cols
    res_adj[[i]] <- out$adjustments

    if (verbose && i %% 200 == 0) {
      af2_log("AF2_ADJ:", "Progress ", i, "/", length(syms))
    }
  }

  panel_all <- data.table::rbindlist(res_pan, use.names = TRUE, fill = TRUE)
  adj_all   <- data.table::rbindlist(res_adj, use.names = TRUE, fill = TRUE)

  data.table::setorder(panel_all, symbol, refdate)
  data.table::setorder(adj_all, symbol, refdate)

  list(panel_adj = panel_all, adjustments = adj_all)
}



###############################################################################
### FILE: modules/04_adjuster/R/build_adjustments.R
###############################################################################
# v2/modules/04_adjuster/R/build_adjustments.R

# Build normalized event table for the adjuster.
# Input corp_actions contract (from Module 03):
#   symbol, yahoo_symbol, refdate, action_type, value, source
#
# Output event table:
#   symbol, refdate, split_value, div_cash, source_mask, has_manual

af2_adj_normalize_corp_actions <- function(corp_actions) {
  if (is.null(corp_actions)) {
    return(data.table(
      symbol = character(),
      refdate = as.Date(character()),
      action_type = character(),
      value = numeric(),
      source = character()
    ))
  }

  dt <- data.table::as.data.table(corp_actions)

  # Allow either registry schema with yahoo_symbol or not
  if ("yahoo_symbol" %in% names(dt)) dt[, yahoo_symbol := NULL]

  # Basic required
  af2_assert_cols(dt, c("symbol", "refdate", "action_type", "value", "source"),
                  name = "corp_actions")

  dt[, symbol := toupper(trimws(as.character(symbol)))]
  dt[, action_type := tolower(trimws(as.character(action_type)))]
  dt[, refdate := as.Date(refdate)]
  dt[, value := as.numeric(value)]
  dt[, source := tolower(trimws(as.character(source)))]

  dt <- dt[!is.na(symbol) & nzchar(symbol) & !is.na(refdate)]
  dt <- dt[action_type %in% c("split", "dividend")]
  # --------------------------------------------
  # Normalize split values to PRICE FACTORS
  # Yahoo/quantmod typically returns split ratios
  # (e.g., 2 for 2:1). For backward price adjustment,
  # we need the inverse (1/ratio).
  # --------------------------------------------
  dt[action_type == "split" & is.finite(value) & value > 0,
     value := 1 / value]

  dt
}

af2_adj_normalize_manual_events <- function(manual_events) {
  if (is.null(manual_events)) {
    return(data.table(
      symbol = character(),
      refdate = as.Date(character()),
      action_type = character(),
      value = numeric(),
      source = character()
    ))
  }

  dt <- data.table::as.data.table(manual_events)

  af2_assert_cols(dt, c("symbol", "refdate", "action_type", "value"),
                  name = "manual_events")

  if (!"source" %in% names(dt)) dt[, source := "manual"]

  dt[, symbol := toupper(trimws(as.character(symbol)))]
  dt[, action_type := tolower(trimws(as.character(action_type)))]
  dt[, refdate := as.Date(refdate)]
  dt[, value := as.numeric(value)]
  dt[, source := "manual"]

  dt <- dt[!is.na(symbol) & nzchar(symbol) & !is.na(refdate)]
  dt <- dt[action_type %in% c("split", "dividend")]
  dt[action_type == "split" & is.finite(value) & value > 0,
     value := 1 / value]

  dt
}

af2_adj_build_events <- function(corp_actions,
                                 manual_events = NULL,
                                 verbose = TRUE) {

  ca <- af2_adj_normalize_corp_actions(corp_actions)
  me <- af2_adj_normalize_manual_events(manual_events)

  dt_all <- data.table::rbindlist(list(ca, me), use.names = TRUE, fill = TRUE)
  if (!nrow(dt_all)) {
    return(data.table(
      symbol = character(),
      refdate = as.Date(character()),
      split_value = numeric(),
      div_cash = numeric(),
      source_mask = character(),
      has_manual = logical()
    ))
  }

  # Aggregate same-day events:
  # - splits: multiply price factors
  # - dividends: sum cash amounts
  splits <- dt_all[action_type == "split",
                   .(split_value = prod(value, na.rm = TRUE),
                     source_mask = paste(sort(unique(source)), collapse = "+")),
                   by = .(symbol, refdate)]

  divs <- dt_all[action_type == "dividend",
                 .(div_cash = sum(value, na.rm = TRUE),
                   source_mask_div = paste(sort(unique(source)), collapse = "+")),
                 by = .(symbol, refdate)]

  # Merge into unified event table
  ev <- merge(
    splits, divs,
    by = c("symbol", "refdate"),
    all = TRUE
  )

  ev[is.na(split_value), split_value := 1]
  ev[is.na(div_cash), div_cash := 0]

  # Compose source mask
  ev[, source_mask := fifelse(
    !is.na(source_mask) & !is.na(source_mask_div),
    paste0(source_mask, "+", source_mask_div),
    fifelse(!is.na(source_mask), source_mask, source_mask_div)
  )]
  ev[is.na(source_mask), source_mask := "unknown"]

  ev[, c("source_mask_div") := NULL]

  ev[, has_manual := grepl("manual", source_mask)]

  # Clean obvious nonsense
  ev <- ev[!is.na(symbol) & nzchar(symbol) & !is.na(refdate)]
  ev <- ev[is.finite(split_value) & split_value > 0]
  ev <- ev[is.finite(div_cash) & div_cash >= 0]

  if (verbose) {
    af2_log("AF2_ADJ:", "Built events: ", nrow(ev), " rows for ",
            length(unique(ev$symbol)), " symbols.")
  }

  data.table::setorder(ev, symbol, refdate)
  ev
}



###############################################################################
### FILE: modules/04_adjuster/R/build_panel_adj.R
###############################################################################
# v2/modules/04_adjuster/R/build_panel_adj.R

# High-level builder:
#   universe_raw (Module 01 output)
#   corp_actions (Module 03 output)
#   manual_events (optional)
#
# Returns:
#   list(panel_adj = ..., adjustments = ..., events = ...)

af2_build_panel_adj <- function(universe_raw,
                                corp_actions = NULL,
                                manual_events = NULL,
                                cfg = NULL,
                                verbose = TRUE) {

  cfg <- cfg %||% af2_get_config()

  dt <- data.table::as.data.table(universe_raw)

  # Strict universe column expectations for v2
  af2_assert_cols(
    dt,
    c("symbol", "refdate", "open", "high", "low", "close",
      "turnover", "qty", "asset_type"),
    name = "universe_raw"
  )

  dt[, symbol := toupper(trimws(as.character(symbol)))]
  dt[, refdate := as.Date(refdate)]

  # ------------------------------------------------------------------
  # Defensive dedupe (rb3 edge cases)
  # We keep the first row per symbol/refdate after ordering.
  # This prevents hard failures on occasional upstream duplicates.
  # ------------------------------------------------------------------
  data.table::setorder(dt, asset_type, symbol, refdate)

  dup_check <- dt[, .N, by = .(symbol, refdate)][N > 1L]
  if (nrow(dup_check)) {
    af2_log(
      "AF2_ADJ:",
      "WARNING: universe_raw had duplicated symbol/refdate rows. ",
      "Examples: ",
      paste(utils::head(paste0(dup_check$symbol, "@", dup_check$refdate), 5), collapse = ", "),
      ". Keeping first row per key."
    )
    dt <- dt[, .SD[1L], by = .(symbol, refdate)]
  }


  af2_assert_no_dupes(dt, c("symbol", "refdate"), name = "universe_raw")

  # 1) Build event table (split_value + div_cash per symbol-date)
  events <- af2_adj_build_events(
    corp_actions = if (isTRUE(cfg$enable_splits)) corp_actions else NULL,
    manual_events = if (isTRUE(cfg$enable_manual_events)) manual_events else NULL,
    verbose = verbose
  )

  # 2) Apply adjustments
  out <- af2_adj_apply_adjustments(
    universe_raw = dt,
    events = events,
    verbose = verbose
  )

  panel <- out$panel_adj
  adj_tl <- out$adjustments

  # 3) Add raw aliases for clarity/audit
  panel[, `:=`(
    open_raw = open,
    high_raw = high,
    low_raw  = low,
    close_raw = close
  )]

  # 4) Compute adjustment_state per symbol (research-grade honesty)
  # We base this on:
  # - presence of split/dividend events
  # - whether manual was involved
  # - whether dividend computation had issues

  # Restrict event flags to the panel date range for state semantics
  panel_min <- min(panel$refdate, na.rm = TRUE)
  panel_max <- max(panel$refdate, na.rm = TRUE)

  events_state <- events[
    refdate >= panel_min & refdate <= panel_max
  ]
  
  ev_flags <- if (nrow(events_state)) {
    events_state[, .(
      has_split = any(is.finite(split_value) & split_value != 1),
      has_div   = any(is.finite(div_cash) & div_cash > 0),
      has_manual = any(isTRUE(has_manual))
    ), by = symbol]
  } else {
    data.table(symbol = unique(panel$symbol),
               has_split = FALSE, has_div = FALSE, has_manual = FALSE)
  }

  issue_flags <- adj_tl[, .(
    issue_div_any = any(isTRUE(issue_div))
  ), by = symbol]

  state_dt <- merge(ev_flags, issue_flags, by = "symbol", all = TRUE)
  state_dt[is.na(has_split), has_split := FALSE]
  state_dt[is.na(has_div), has_div := FALSE]
  state_dt[is.na(has_manual), has_manual := FALSE]
  state_dt[is.na(issue_div_any), issue_div_any := FALSE]

  state_dt[, adjustment_state := fifelse(
    issue_div_any, "suspect_unresolved",
    fifelse(
      has_manual, "manual_override",
      fifelse(
        has_split & has_div, "split_dividend",
        fifelse(
          has_split, "split_only",
          fifelse(
            has_div, "dividend_only",
            "ok"
          )
        )
      )
    )
  )]

  panel[state_dt, on = "symbol", adjustment_state := i.adjustment_state]

  # 5) Final column cleanup ordering
  keep_cols <- c(
    "symbol", "refdate", "asset_type",
    "open_raw", "high_raw", "low_raw", "close_raw",
    "open_adj_split", "high_adj_split", "low_adj_split", "close_adj_split",
    "open_adj_final", "high_adj_final", "low_adj_final", "close_adj_final",
    "turnover", "qty",
    "adjustment_state"
  )

  # Some columns may be missing if upstream had NA open/high/low;
  # preserve everything but move preferred cols to front.
  present_keep <- intersect(keep_cols, names(panel))
  other_cols <- setdiff(names(panel), present_keep)
  data.table::setcolorder(panel, c(present_keep, other_cols))

  if (verbose) {
    af2_log("AF2_ADJ:", "panel_adj rows = ", nrow(panel))
    af2_log("AF2_ADJ:", "symbols = ", length(unique(panel$symbol)))
    af2_log("AF2_ADJ:", "states:")
    print(panel[, .N, by = adjustment_state][order(-N)])
  }

  list(
    panel_adj = panel,
    adjustments = adj_tl,
    events = events
  )
}



###############################################################################
### FILE: modules/04_adjuster/R/build_panel_adj_selective.R
###############################################################################
# v2/modules/04_adjuster/R/build_panel_adj_selective.R
# High-level wrapper implementing the selective Yahoo "trick".

af2_build_panel_adj_selective <- function(universe_raw,
                                          manual_events = NULL,
                                          cfg = NULL,
                                          from_ca = "2018-01-01",
                                          to_ca = Sys.Date(),
                                          verbose = TRUE,
                                          use_cache = TRUE,
                                          force_refresh = FALSE,
                                          n_workers = 1L) {

  cfg <- cfg %||% af2_get_config()

  dt <- data.table::as.data.table(universe_raw)
  af2_assert_cols(
    dt,
    c("symbol", "refdate", "open", "high", "low", "close", "turnover", "qty", "asset_type"),
    name = "universe_raw"
  )

  # 1) Decide candidate symbols for Yahoo actions
  if (isTRUE(cfg$enable_selective_actions)) {
    cand <- af2_ca_select_candidates(
      universe_raw = dt,
      cfg = cfg,
      verbose = verbose
    )
  } else {
    cand <- sort(unique(toupper(dt$symbol)))
  }

  if (verbose) {
    af2_log("AF2_CA_PREF:", "Selective actions enabled=", isTRUE(cfg$enable_selective_actions))
    af2_log("AF2_CA_PREF:", "Yahoo candidate symbols=", length(cand))
  }

  # 2) Fetch registry ONLY for candidates
  ca <- NULL
  if (length(cand)) {
    ca <- af2_ca_build_registry(
      symbols = cand,
      asset_types = NULL,
      cfg = cfg,
      from = from_ca,
      to = to_ca,
      verbose = verbose,
      use_cache = use_cache,
      force_refresh = force_refresh,
      n_workers = n_workers,
      cache_mode = cfg$ca_cache_mode %||% "batch"
    )
  }

  # 3) Run the normal adjuster builder
  af2_build_panel_adj(
    universe_raw = dt,
    corp_actions = ca,
    manual_events = manual_events,
    cfg = cfg,
    verbose = verbose
  )
}



###############################################################################
### FILE: modules/04_adjuster/R/validate_panel_adj.R
###############################################################################
# v2/modules/04_adjuster/R/validate_panel_adj.R

af2_validate_panel_adj <- function(panel_adj) {

  af2_require(c("data.table"))

  af2_assert_cols(
    panel_adj,
    c("symbol", "refdate", "close_adj_final", "asset_type", "adjustment_state"),
    name = "panel_adj"
  )

  dt <- data.table::as.data.table(panel_adj)
  dt[, refdate := as.Date(refdate)]

  # Must have liquidity column for screener use
  has_turnover <- "turnover" %in% names(dt)
  has_vol_fin  <- "vol_fin" %in% names(dt)
  if (!has_turnover && !has_vol_fin) {
    stop("panel_adj must contain 'turnover' or 'vol_fin'.", call. = FALSE)
  }

  # No duplicate symbol-date
  af2_assert_no_dupes(dt, c("symbol", "refdate"), name = "panel_adj")

  invisible(TRUE)
}



###############################################################################
### FILE: modules/04_adjuster/R/zzz_depends.R
###############################################################################
# v2/modules/04_adjuster/R/zzz_depends.R
# Dependencies + guardrails for Module 04 (Adjuster)

# Must have core loaded first
if (!exists("af2_get_config")) {
  stop("af2_get_config not found. Source v2/modules/00_core/R/config.R first.")
}
if (!exists("af2_log")) {
  stop("af2_log not found. Source v2/modules/00_core/R/logging.R first.")
}
if (!exists("%||%")) {
  stop("%||% not found. Source v2/modules/00_core/R/utils.R first.")
}
if (!exists("af2_require")) {
  stop("af2_require not found. Source v2/modules/00_core/R/utils.R first.")
}
if (!exists("af2_assert_cols")) {
  stop("af2_assert_cols not found. Source v2/modules/00_core/R/utils.R first.")
}
if (!exists("af2_assert_no_dupes")) {
  stop("af2_assert_no_dupes not found. Source v2/modules/00_core/R/utils.R first.")
}

af2_adj_require <- function(pkgs) {
  for (p in pkgs) {
    if (!requireNamespace(p, quietly = TRUE)) {
      stop("Missing package for adjuster module: ", p, call. = FALSE)
    }
  }
  invisible(TRUE)
}

af2_adj_require(c("data.table"))

suppressPackageStartupMessages({
  library(data.table)
})



###############################################################################
### FILE: modules/04_adjuster/README.md
###############################################################################
# Module

Purpose:
- Define INPUT contract
- Define OUTPUT contract
- List functions
- List tests



###############################################################################
### FILE: modules/05_screener/R/compute_metrics.R
###############################################################################
# v2/modules/05_screener/R/compute_metrics.R

af2_compute_symbol_metrics <- function(dt_sym, horizons_days) {
  af2_require("data.table")
  dt_sym <- data.table::as.data.table(dt_sym)
  data.table::setorder(dt_sym, refdate)

  n <- nrow(dt_sym)
  if (n < 30L) return(NULL)

  # Returns from adjusted final price
  dt_sym[, close_lag := data.table::shift(close_adj_final, 1L), by = symbol]
  dt_sym[, ret_simple := ifelse(
    !is.na(close_lag) & close_lag != 0,
    (close_adj_final / close_lag) - 1,
    NA_real_
  )]
  dt_sym[, close_lag := NULL]

  last_idx <- n
  out <- list(symbol = dt_sym$symbol[1])

  # Momentum + short/long vol
  # PATCH 2025-12-08: robust horizon indexing + NA-safe return calc
  safe_price_ret <- function(p0, p1) {
    if (is.na(p0) || is.na(p1)) return(NA_real_)
    if (!is.finite(p0) || !is.finite(p1)) return(NA_real_)
    if (p0 == 0) return(NA_real_)
    (p1 / p0) - 1
  }

  for (h in horizons_days) {
    h <- as.integer(h)

    # Need at least h+1 points to compute a price-to-price horizon
    if (h > 1L && (last_idx - h) >= 1L) {

      idx0 <- last_idx - h
      p0 <- dt_sym$close_adj_final[idx0]
      p1 <- dt_sym$close_adj_final[last_idx]

      out[[paste0("ret_", h, "d")]] <- safe_price_ret(p0, p1)

      # Vol over last h observations of daily returns
      idx_start <- max(1L, last_idx - h + 1L)
      rwin <- dt_sym$ret_simple[idx_start:last_idx]
      out[[paste0("vol_", h, "d")]] <- stats::sd(rwin, na.rm = TRUE) * sqrt(252)

    } else {
      # Explicitly populate missing horizons to avoid silent shape drift
      out[[paste0("ret_", h, "d")]] <- NA_real_
      out[[paste0("vol_", h, "d")]] <- NA_real_
    }
  }

  # Drawdown + Ulcer (NA-robust)
  prices <- dt_sym$close_adj_final
  if (requireNamespace("zoo", quietly = TRUE)) {
    prices <- zoo::na.locf(prices, na.rm = FALSE)
  }

  cummax_p <- cummax(prices)
  dd <- prices / cummax_p - 1
  out$max_dd <- suppressWarnings(min(dd, na.rm = TRUE))
  out$ulcer_index <- sqrt(mean((dd * 100)^2, na.rm = TRUE))

  # Amihud-like illiquidity
  if (!"turnover" %in% names(dt_sym) && "vol_fin" %in% names(dt_sym)) {
    dt_sym[, turnover := vol_fin]
  }
  valid <- is.finite(dt_sym$ret_simple) & is.finite(dt_sym$turnover) & dt_sym$turnover > 0
  out$amihud <- if (any(valid)) {
    mean(abs(dt_sym$ret_simple[valid]) / dt_sym$turnover[valid], na.rm = TRUE)
  } else NA_real_

  data.table::as.data.table(out)
}



###############################################################################
### FILE: modules/05_screener/R/liquidity_filter.R
###############################################################################
# v2/modules/05_screener/R/liquidity_filter.R

af2_compute_liquidity_from_panel <- function(panel_adj,
                                             min_turnover,
                                             min_days_traded_ratio) {
  af2_require("data.table")
  dt <- data.table::as.data.table(panel_adj)

  # unify turnover column name
  if (!"turnover" %in% names(dt) && "vol_fin" %in% names(dt)) {
    dt[, turnover := vol_fin]
  }

  dt[, traded_flag := is.finite(close_adj_final) & !is.na(close_adj_final)]

  liq <- dt[, .(
    median_turnover = stats::median(turnover, na.rm = TRUE),
    days_traded_ratio = mean(traded_flag, na.rm = TRUE)
  ), by = symbol]

  liq[is.na(median_turnover), median_turnover := 0]
  liq[is.na(days_traded_ratio), days_traded_ratio := 0]

  liq[
    median_turnover >= min_turnover &
      days_traded_ratio >= min_days_traded_ratio
  ]
}



###############################################################################
### FILE: modules/05_screener/R/run_screener.R
###############################################################################
# v2/modules/05_screener/R/run_screener.R

af2_run_screener <- function(panel_adj,
                             config = NULL,
                             allow_unresolved = NULL) {

  af2_require("data.table")
  # If caller didn't specify, default to core config policy
  if (is.null(allow_unresolved)) {
    cfg_core <- af2_get_config()
    allow_unresolved <- isTRUE(cfg_core$allow_unresolved_in_screener)
  }

  cfg <- af2_get_screener_config(config)

  # 0) Validate input contract hard
  af2_validate_screener_input(panel_adj, allow_unresolved = allow_unresolved)

  dt <- data.table::as.data.table(panel_adj)
  dt[, refdate := as.Date(refdate)]

  # unify turnover name
  if (!"turnover" %in% names(dt) && "vol_fin" %in% names(dt)) {
    dt[, turnover := vol_fin]
  }

  # 1) Liquidity filter
  liq <- af2_compute_liquidity_from_panel(
    dt,
    min_turnover = cfg$min_turnover,
    min_days_traded_ratio = cfg$min_days_traded_ratio
  )
  if (!nrow(liq)) stop("af2_run_screener: no symbols pass liquidity filter.", call. = FALSE)

  dt <- dt[symbol %in% liq$symbol]
  data.table::setorder(dt, symbol, refdate)

  # 2) Compute metrics per symbol on last lookback window
  metrics_list <- list()
  syms <- unique(dt$symbol)

  for (sym in syms) {
    sdt <- dt[symbol == sym]

    # Ensure we keep enough rows to compute the longest horizon return.
    need_n <- max(
     as.integer(cfg$lookback_days),
     as.integer(max(cfg$horizons_days)) + 1L
    )

    if (nrow(sdt) > need_n) {
     sdt <- sdt[(.N - need_n + 1):.N]
    }

    m <- af2_compute_symbol_metrics(sdt, cfg$horizons_days)
    if (!is.null(m)) {
      # attach asset_type
      m[, asset_type := unique(sdt$asset_type)[1]]
      metrics_list[[sym]] <- m
    }
  }

  metrics <- data.table::rbindlist(metrics_list, fill = TRUE)
  if (!nrow(metrics)) stop("af2_run_screener: metrics computation yielded zero rows.", call. = FALSE)

  # 3) Score + rank
  out <- af2_score_and_rank(metrics, cfg$score_weights)

  by_type <- split(out, out$asset_type)
  by_type <- lapply(by_type, function(x) x[order(x$rank_type)])

  list(
    full = out[order(rank_overall)],
    by_type = by_type
  )

}



###############################################################################
### FILE: modules/05_screener/R/score_rank.R
###############################################################################
# v2/modules/05_screener/R/score_rank.R

af2_score_and_rank <- function(metrics, score_weights) {
  af2_require("data.table")
  dt <- data.table::as.data.table(metrics)

  dt[, score := 0]

  for (nm in names(score_weights)) {
    if (!nm %in% names(dt)) next
    x <- dt[[nm]]
    if (all(is.na(x))) next
    mu <- mean(x, na.rm = TRUE)
    s  <- stats::sd(x, na.rm = TRUE)
    if (!is.finite(s) || s == 0) next

    z <- (x - mu) / s
    z[!is.finite(z) | is.na(z)] <- 0
    dt[, score := score + score_weights[[nm]] * z]
  }

  dt[, rank_overall := rank(-score, ties.method = "first")]
  if ("asset_type" %in% names(dt)) {
    dt[, rank_type := rank(-score, ties.method = "first"), by = asset_type]
  } else {
    dt[, rank_type := NA_integer_]
  }

  dt[order(rank_overall)]
}



###############################################################################
### FILE: modules/05_screener/R/screener_config.R
###############################################################################
# v2/modules/05_screener/R/screener_config.R

af2_screener_config_default <- list(
  lookback_days   = 252L,
  horizons_days   = c(21L, 63L, 126L, 252L),

  # Liquidity
  min_turnover = 5e5,
  min_days_traded_ratio = 0.8,

  # Scoring weights (z-score aggregation)
  score_weights = list(
    # Momentum
    ret_21d  = +0.3,
    ret_63d  = +0.6,
    ret_126d = +0.9,
    ret_252d = +1.0,

    # Risk / stability penalties
    vol_21d  = -0.4,
    vol_252d = -0.7,
    max_dd   = -0.8,
    ulcer_index = -0.8,

    # Liquidity penalty
    amihud = -0.5
  )
)

af2_get_screener_config <- function(config = NULL) {
  cfg <- af2_screener_config_default

  if (!is.null(config)) {
    for (nm in names(config)) cfg[[nm]] <- config[[nm]]
  }

  # Defensive normalization
  if (is.null(cfg$horizons_days)) cfg$horizons_days <- integer()
  cfg$horizons_days <- as.integer(cfg$horizons_days)
  cfg$lookback_days <- as.integer(cfg$lookback_days)

  if (length(cfg$horizons_days)) {
    max_h <- max(cfg$horizons_days, na.rm = TRUE)
    if (is.finite(max_h) && cfg$lookback_days < (max_h + 1L)) {
      cfg$lookback_days <- max_h + 1L
    }
  }

  cfg
}



###############################################################################
### FILE: modules/05_screener/R/validate_screener_input.R
###############################################################################
# v2/modules/05_screener/R/validate_screener_input.R

af2_validate_screener_input <- function(panel_adj, allow_unresolved = FALSE) {
  af2_require(c("data.table"))
  af2_assert_cols(
    panel_adj,
    c("symbol", "refdate", "close_adj_final", "asset_type", "adjustment_state"),
    name = "panel_adj"
  )

  dt <- data.table::as.data.table(panel_adj)
  dt[, refdate := as.Date(refdate)]

  # Basic type sanity
  if (!is.character(dt$symbol)) stop("panel_adj$symbol must be character.", call. = FALSE)
  if (!is.character(dt$asset_type)) stop("panel_adj$asset_type must be character.", call. = FALSE)
  if (!is.character(dt$adjustment_state)) stop("panel_adj$adjustment_state must be character.", call. = FALSE)

  # Must have at least one liquidity column
  has_turnover <- "turnover" %in% names(dt)
  has_vol_fin  <- "vol_fin" %in% names(dt)
  if (!has_turnover && !has_vol_fin) {
    stop("panel_adj must contain either 'turnover' or 'vol_fin' for liquidity logic.", call. = FALSE)
  }

  # No duplicate rows per symbol-date
  af2_assert_no_dupes(dt, c("symbol", "refdate"), name = "panel_adj")

  # Adjustment state policy
  bad <- dt[adjustment_state == "suspect_unresolved"]
  if (nrow(bad) && !isTRUE(allow_unresolved)) {
    stop(
      "Screener input contains unresolved suspects.\n",
      "You must fix upstream adjuster/manual registry OR set allow_unresolved=TRUE.\n",
      "Example symbols: ", paste(unique(utils::head(bad$symbol, 10)), collapse = ", "),
      call. = FALSE
    )
  }

  invisible(TRUE)
}



###############################################################################
### FILE: modules/05_screener/README.md
###############################################################################
# Module

Purpose:
- Define INPUT contract
- Define OUTPUT contract
- List functions
- List tests



###############################################################################
### FILE: scripts/00_bootstrap_v2.R
###############################################################################
# v2/scripts/00_bootstrap_v2.R
# Creates the v2 directory structure + minimal placeholder READMEs.
# Run from project root: source("v2/scripts/00_bootstrap_v2.R")

af2_bootstrap_v2 <- function(root = "v2", verbose = TRUE) {
  dirs <- c(
    root,
    file.path(root, "README.md"),
    file.path(root, "contracts"),
    file.path(root, "data", "raw"),
    file.path(root, "data", "cache"),
    file.path(root, "data", "fixtures"),
    file.path(root, "data", "manual"),
    file.path(root, "logs"),
    file.path(root, "modules"),
    file.path(root, "modules", "00_core", "R"),
    file.path(root, "modules", "00_core", "tests"),
    file.path(root, "modules", "01_b3_universe", "R"),
    file.path(root, "modules", "01_b3_universe", "tests"),
    file.path(root, "modules", "02_diagnostics", "R"),
    file.path(root, "modules", "02_diagnostics", "tests"),
    file.path(root, "modules", "03_corporate_actions", "R"),
    file.path(root, "modules", "03_corporate_actions", "tests"),
    file.path(root, "modules", "04_adjuster", "R"),
    file.path(root, "modules", "04_adjuster", "tests"),
    file.path(root, "modules", "05_screener", "R"),
    file.path(root, "modules", "05_screener", "tests"),
    file.path(root, "modules", "06_risk", "R"),
    file.path(root, "modules", "06_risk", "tests"),
    file.path(root, "modules", "07_portfolio", "R"),
    file.path(root, "modules", "07_portfolio", "tests"),
    file.path(root, "modules", "08_backtest", "R"),
    file.path(root, "modules", "08_backtest", "tests"),
    file.path(root, "scripts")
  )

  # Create directories (ignore .md entries)
  dir_paths <- dirs[!grepl("\\.md$", dirs)]
  for (d in dir_paths) {
    if (!dir.exists(d)) {
      dir.create(d, recursive = TRUE, showWarnings = FALSE)
      if (verbose) message("Created: ", d)
    }
  }

  # Minimal contracts placeholders
  contract_files <- c(
    "universe_raw.md",
    "adjustments.md",
    "panel_adj.md",
    "screener_input.md",
    "screener_output.md"
  )
  for (f in contract_files) {
    p <- file.path(root, "contracts", f)
    if (!file.exists(p)) {
      writeLines(
        c(
          paste0("# ", f),
          "",
          "This is a placeholder. Fill with the explicit schema + guarantees."
        ),
        con = p
      )
      if (verbose) message("Seeded contract: ", p)
    }
  }

  # Module READMEs
  module_readmes <- c(
    file.path(root, "modules", "00_core", "README.md"),
    file.path(root, "modules", "01_b3_universe", "README.md"),
    file.path(root, "modules", "02_diagnostics", "README.md"),
    file.path(root, "modules", "03_corporate_actions", "README.md"),
    file.path(root, "modules", "04_adjuster", "README.md"),
    file.path(root, "modules", "05_screener", "README.md")
  )
  for (p in module_readmes) {
    if (!file.exists(p)) {
      writeLines(
        c(
          "# Module",
          "",
          "Purpose:",
          "- Define INPUT contract",
          "- Define OUTPUT contract",
          "- List functions",
          "- List tests"
        ),
        con = p
      )
      if (verbose) message("Seeded README: ", p)
    }
  }

  # Root README
  root_readme <- file.path(root, "README.md")
  if (!file.exists(root_readme)) {
    writeLines(
      c(
        "# autofinance_R v2",
        "",
        "Principles:",
        "- In-memory first",
        "- Contract-first",
        "- Fixtures-first",
        "- Screener cannot fetch or adjust data",
        "- Adjuster is the single owner of history mutation"
      ),
      con = root_readme
    )
    if (verbose) message("Seeded: ", root_readme)
  }

  invisible(TRUE)
}

af2_bootstrap_v2()



###############################################################################
### FILE: scripts/00_make_fixtures.R
###############################################################################
# v2/scripts/00_make_fixtures.R
# Generates deterministic mock panels for screener development.
# Run from project root:
#   source("v2/modules/00_core/R/utils.R")
#   source("v2/modules/00_core/R/config.R")
#   source("v2/scripts/00_make_fixtures.R")

af2_make_price_path <- function(dates, start_price = 10,
                                drift = 0.0003, vol = 0.01,
                                seed = 1L) {
  set.seed(seed)
  n <- length(dates)
  eps <- rnorm(n, mean = drift, sd = vol)
  px <- start_price * cumprod(1 + eps)
  pmax(px, 0.01)
}

af2_write_fixture <- function(dt, name, cfg) {
  p <- file.path(cfg$fixtures_dir, paste0(name, ".rds"))
  saveRDS(dt, p)
  message("Wrote fixture: ", p)
}

af2_make_fixtures <- function(config = NULL) {
  af2_require(c("data.table", "lubridate"))
  cfg <- af2_get_config(config)

  # ~260 business days ending today
  end_date <- Sys.Date()
  start_date <- end_date - 400
  dates <- af2_make_bizdays_seq(start_date, end_date)
  dates <- tail(dates, 260)

  symbols <- c("AAA4", "BBB11", "CCC34", "DDD11")
  asset_type_map <- c(
    AAA4 = "equity",
    BBB11 = "fii",
    CCC34 = "bdr",
    DDD11 = "etf"
  )

  # Construct 4 different behaviors
  px_A <- af2_make_price_path(dates, 10, drift = 0.0008, vol = 0.007, seed = 11)  # strong uptrend
  px_B <- af2_make_price_path(dates, 100, drift = 0.0001, vol = 0.003, seed = 22) # low vol/flat
  px_C <- af2_make_price_path(dates, 30, drift = 0.0003, vol = 0.020, seed = 33)  # volatile
  px_D <- af2_make_price_path(dates, 50, drift = -0.0002, vol = 0.010, seed = 44) # mild down

  price_list <- list(AAA4 = px_A, BBB11 = px_B, CCC34 = px_C, DDD11 = px_D)

  # Base liquidity
  liq_level <- c(AAA4 = 2e6, BBB11 = 8e5, CCC34 = 1.5e6, DDD11 = 1.2e6)

  rows <- list()
  for (sym in symbols) {
    px <- price_list[[sym]]
    turnover <- liq_level[[sym]] * (1 + rnorm(length(px), 0, 0.1))
    turnover <- pmax(turnover, 1e4)

    dt <- data.table::data.table(
      symbol = sym,
      refdate = dates,
      close_raw = px,
      close_adj_split = px,
      close_adj_final = px,
      turnover = turnover,
      qty = round(turnover / px),
      asset_type = asset_type_map[[sym]],
      adjustment_state = "ok"
    )
    rows[[sym]] <- dt
  }

  panel_mock_small <- data.table::rbindlist(rows)
  data.table::setorder(panel_mock_small, symbol, refdate)

  # Edge cases fixture
  panel_mock_edge <- data.table::copy(panel_mock_small)

  # Make one symbol illiquid
  panel_mock_edge[symbol == "BBB11", turnover := 1e4]

  # Insert missing block for CCC34
  miss_idx <- panel_mock_edge[symbol == "CCC34", .I][50:70]
  panel_mock_edge[miss_idx, close_adj_final := NA_real_]

  # Mark DDD11 unresolved suspect
  panel_mock_edge[symbol == "DDD11", adjustment_state := "suspect_unresolved"]

  # "Split case" fixture (simulates pre-adjustment discontinuity,
  # but we store final as already fixed for screener use)
  panel_mock_split <- data.table::copy(panel_mock_small)
  # create raw discontinuity for AAA4 around mid
  mid <- panel_mock_split[symbol == "AAA4", .I][130]
  panel_mock_split[mid:nrow(panel_mock_split)][symbol == "AAA4", close_raw := close_raw / 5]
  # but keep adjusted final coherent
  panel_mock_split[symbol == "AAA4", close_adj_split := close_adj_final]
  panel_mock_split[symbol == "AAA4", adjustment_state := "split_only"]

  # Save
  af2_write_fixture(panel_mock_small, "panel_mock_small", cfg)
  af2_write_fixture(panel_mock_edge, "panel_mock_edge_cases", cfg)
  af2_write_fixture(panel_mock_split, "panel_mock_split_case", cfg)

  invisible(TRUE)
}

af2_make_fixtures()



###############################################################################
### FILE: scripts/01a_smoke_b3_fetch_one_year.R
###############################################################################
# v2/scripts/01a_smoke_b3_fetch_one_year.R
# Real-data smoke test:
# - fetch 1 year
# - include only 1-2 types
# - confirm contract + speed + caching

source("v2/modules/00_core/R/utils.R")
source("v2/modules/00_core/R/config.R")
source("v2/modules/00_core/R/logging.R")

source("v2/modules/01_b3_universe/R/zzz_depends.R")
source("v2/modules/01_b3_universe/R/rb3_init.R")
source("v2/modules/01_b3_universe/R/validate_types.R")
source("v2/modules/01_b3_universe/R/select_min_cols.R")
source("v2/modules/01_b3_universe/R/unify_liquidity.R")
source("v2/modules/01_b3_universe/R/filter_by_type_rb3.R")
source("v2/modules/01_b3_universe/R/fetch_yearly.R")
source("v2/modules/01_b3_universe/R/build_universe.R")

cfg <- af2_get_config()
af2_log("AF2_CFG:", "\n", paste(capture.output(str(cfg)), collapse = "\n"))

year_test <- max(cfg$years)
types_test <- c("equity", "etf")

af2_log("AF2_B3:", "SMOKE: year=", year_test, " types=", paste(types_test, collapse = ","))

t0 <- Sys.time()
dt <- af2_b3_build_universe_year(
  year = year_test,
  include_types = types_test,
  cfg = cfg,
  verbose = TRUE,
  use_cache = TRUE,
  force_download = FALSE,
  reprocess = FALSE
)
t1 <- Sys.time()

af2_log("AF2_B3:", "SMOKE elapsed seconds: ", round(as.numeric(difftime(t1, t0, units = "secs")), 2))

af2_log("AF2_B3:", "Head:")
print(utils::head(dt, 10))

# Contract check
req <- c("symbol","refdate","open","high","low","close","turnover","qty","asset_type")
stopifnot(all(req %in% names(dt)))

af2_log("AF2_B3:", "SMOKE OK.")



###############################################################################
### FILE: scripts/01b_build_universe_small_window.R
###############################################################################
# v2/scripts/01b_build_universe_small_window.R
# Build a small 2-year universe for all 4 types
# and save a narrow raw panel artifact.

source("v2/modules/00_core/R/utils.R")
source("v2/modules/00_core/R/config.R")
source("v2/modules/00_core/R/logging.R")

source("v2/modules/01_b3_universe/R/zzz_depends.R")
source("v2/modules/01_b3_universe/R/rb3_init.R")
source("v2/modules/01_b3_universe/R/validate_types.R")
source("v2/modules/01_b3_universe/R/select_min_cols.R")
source("v2/modules/01_b3_universe/R/unify_liquidity.R")
source("v2/modules/01_b3_universe/R/filter_by_type_rb3.R")
source("v2/modules/01_b3_universe/R/fetch_yearly.R")
source("v2/modules/01_b3_universe/R/fetch_daily.R")
source("v2/modules/01_b3_universe/R/build_universe.R")

cfg <- af2_get_config()

# Choose mode here to avoid future screener regressions.
# "yearly" = backfill-style artifact
# "daily"  = screener-grade recent window
mode <- "yearly"
types_all <- c("equity","fii","etf","bdr")

if (mode == "yearly") {

  years_small <- sort(unique(c(max(cfg$years) - 1L, max(cfg$years))))

  af2_log("AF2_B3:", "Building small-window universe (YEARLY): ",
          paste(years_small, collapse = ", "),
          " types=", paste(types_all, collapse = ","))

  dt_all <- af2_b3_build_universe(
    years = years_small,
    include_types = types_all,
    cfg = cfg,
    verbose = TRUE,
    use_cache = TRUE
  )

  artifact_file <- file.path(
    file.path(cfg$raw_dir, "b3_universe"),
    paste0("universe_raw_", min(years_small), "_", max(years_small), ".rds")
  )

} else {

  # Recent ~2-year screener-style window
  end_date <- Sys.Date() - 1
  start_date <- end_date - 730

  af2_log("AF2_B3:", "Building small-window universe (DAILY): ",
          as.character(start_date), " to ", as.character(end_date),
          " types=", paste(types_all, collapse = ","))

  dt_all <- af2_b3_build_universe_window(
    start_date = start_date,
    end_date   = end_date,
    include_types = types_all,
    cfg = cfg,
    verbose = TRUE,
    use_cache = TRUE
  )

  artifact_file <- file.path(
    file.path(cfg$raw_dir, "b3_universe"),
    paste0("universe_raw_daily_",
           format(as.Date(start_date), "%Y%m%d"), "_",
           format(as.Date(end_date), "%Y%m%d"),
           ".rds")
  )
}

af2_log("AF2_B3:", "Universe rows total: ", nrow(dt_all))
af2_log("AF2_B3:", "Symbols total: ", length(unique(dt_all$symbol)))

artifact_dir <- file.path(cfg$raw_dir, "b3_universe")
if (!dir.exists(artifact_dir)) dir.create(artifact_dir, recursive = TRUE)

saveRDS(dt_all, artifact_file)
af2_log("AF2_B3:", "Wrote artifact: ", artifact_file)

RUN_DAILY_SMOKE <- FALSE

if (mode == "yearly" && isTRUE(RUN_DAILY_SMOKE)) {
  end_date <- Sys.Date() - 1
  start_date <- end_date - 90  # ~3 months
  dt_daily_lazy <- af2_b3_fetch_daily_lazy(
    start_date, end_date,
    cfg = cfg,
    verbose = TRUE,
    throttle = FALSE
  )
  # just force a tiny collect to prove it works
  print(dt_daily_lazy |> dplyr::slice_head(n = 5) |> dplyr::collect())
}



###############################################################################
### FILE: scripts/02a_smoke_corp_actions_quantmod.R
###############################################################################
# v2/scripts/02a_smoke_corp_actions_quantmod.R

# Core
source("v2/modules/00_core/R/utils.R")
source("v2/modules/00_core/R/config.R")
source("v2/modules/00_core/R/logging.R")

# Universe (to get a recent symbol list)
source("v2/modules/01_b3_universe/R/zzz_depends.R")
source("v2/modules/01_b3_universe/R/rb3_init.R")
source("v2/modules/01_b3_universe/R/validate_types.R")
source("v2/modules/01_b3_universe/R/select_min_cols.R")
source("v2/modules/01_b3_universe/R/unify_liquidity.R")
source("v2/modules/01_b3_universe/R/filter_by_type_rb3.R")
source("v2/modules/01_b3_universe/R/fetch_yearly.R")
source("v2/modules/01_b3_universe/R/build_universe.R")

# Corporate actions
source("v2/modules/03_corporate_actions/R/zzz_depends.R")
source("v2/modules/03_corporate_actions/R/yahoo_symbol_map.R")
source("v2/modules/03_corporate_actions/R/fetch_splits_quantmod.R")
source("v2/modules/03_corporate_actions/R/fetch_dividends_quantmod.R")
source("v2/modules/03_corporate_actions/R/build_registry.R")

cfg <- af2_get_config()

# Use last config year, tiny types subset to keep smoke fast
year_test <- max(cfg$years)
types_test <- c("equity")

af2_log("AF2_B3:", "SMOKE universe for corp-actions seed: year=", year_test)

dt_univ <- af2_b3_build_universe_year(
  year = year_test,
  include_types = types_test,
  cfg = cfg,
  verbose = TRUE,
  use_cache = TRUE
)

# Grab a small symbol slice
syms <- unique(dt_univ$symbol)
syms <- head(syms, 20)

af2_log("AF2_CA:", "SMOKE fetching splits+dividends for 20 symbols...")

dt_ca <- af2_ca_build_registry(
  symbols = syms,
  cfg = cfg,
  from = as.Date(paste0(year_test - 3, "-01-01")),
  to = Sys.Date(),
  verbose = TRUE,
  use_cache = TRUE,
  force_refresh = FALSE,
  n_workers = 1L
)

print(dt_ca)
af2_log("AF2_CA:", "OK - corp-actions smoke finished.")



###############################################################################
### FILE: scripts/04_run_screener_mock_only.R
###############################################################################
# v2/scripts/04_run_screener_mock_only.R
# Runs the v2 screener ONLY on fixtures.
# This is your daily sanity anchor.

# Core
source("v2/modules/00_core/R/utils.R")
source("v2/modules/00_core/R/config.R")
source("v2/modules/00_core/R/logging.R")

# Screener
source("v2/modules/05_screener/R/screener_config.R")
source("v2/modules/05_screener/R/validate_screener_input.R")
source("v2/modules/05_screener/R/liquidity_filter.R")
source("v2/modules/05_screener/R/compute_metrics.R")
source("v2/modules/05_screener/R/score_rank.R")
source("v2/modules/05_screener/R/run_screener.R")

cfg <- af2_get_config()

fixture_path <- file.path(cfg$fixtures_dir, "panel_mock_small.rds")
if (!file.exists(fixture_path)) {
  stop("Fixture not found: ", fixture_path,
       "\nRun: source('v2/scripts/00_make_fixtures.R')", call. = FALSE)
}

panel <- readRDS(fixture_path)

af2_log_cfg(cfg)
af2_log("AF2_SCR:", "Running screener on mock_small...")

res <- af2_run_screener(panel)

stopifnot(is.list(res), "full" %in% names(res))
stopifnot(nrow(res$full) == 4L)
stopifnot(all(c("AAA4","BBB11","CCC34","DDD11") %in% res$full$symbol))

# Rankings should be complete for this fixture
stopifnot(all(!is.na(res$full$rank_overall)))

print(utils::head(res$full, 10))

af2_log("AF2_SCR:", "OK - mock-only screener passed.")



###############################################################################
### FILE: scripts/04a_smoke_adjuster_small_window.R
###############################################################################
# v2/scripts/04a_smoke_adjuster_small_window.R

# Core
source("v2/modules/00_core/R/utils.R")
source("v2/modules/00_core/R/config.R")
source("v2/modules/00_core/R/logging.R")

# Module 01 (universe)
source("v2/modules/01_b3_universe/R/zzz_depends.R")
source("v2/modules/01_b3_universe/R/rb3_init.R")
source("v2/modules/01_b3_universe/R/validate_types.R")
source("v2/modules/01_b3_universe/R/select_min_cols.R")
source("v2/modules/01_b3_universe/R/unify_liquidity.R")
source("v2/modules/01_b3_universe/R/filter_by_type_rb3.R")
source("v2/modules/01_b3_universe/R/fetch_yearly.R")
source("v2/modules/01_b3_universe/R/fetch_daily.R")
source("v2/modules/01_b3_universe/R/build_universe.R")

# Module 03 (corp actions)
source("v2/modules/03_corporate_actions/R/zzz_depends.R")
source("v2/modules/03_corporate_actions/R/yahoo_symbol_map.R")
source("v2/modules/03_corporate_actions/R/fetch_splits_quantmod.R")
source("v2/modules/03_corporate_actions/R/fetch_dividends_quantmod.R")
source("v2/modules/03_corporate_actions/R/build_registry.R")

# Module 04 (adjuster)
source("v2/modules/04_adjuster/R/zzz_depends.R")
source("v2/modules/04_adjuster/R/build_adjustments.R")
source("v2/modules/04_adjuster/R/apply_adjustments.R")
source("v2/modules/04_adjuster/R/build_panel_adj.R")
source("v2/modules/04_adjuster/R/validate_panel_adj.R")

cfg <- af2_get_config()

# 1) Build small recent universe window
end_date <- Sys.Date() - 1
start_date <- end_date - 365  # 1 year smoke

types_all <- c("equity","fii","etf","bdr")

af2_log("AF2_SMOKE04:", "Universe window ", start_date, " to ", end_date)

univ <- af2_b3_build_universe_window(
  start_date = start_date,
  end_date   = end_date,
  include_types = types_all,
  cfg = cfg,
  verbose = TRUE,
  use_cache = TRUE
)

# take a small symbol subset for faster Yahoo calls
set.seed(1)
syms <- sort(unique(univ$symbol))
syms_small <- head(sample(syms, min(20, length(syms))), 20)

af2_log("AF2_SMOKE04:", "Corp actions for ", length(syms_small), " symbols")

ca <- af2_ca_build_registry(
  symbols = syms_small,
  cfg = cfg,
  from = "2018-01-01",
  to = Sys.Date(),
  verbose = TRUE,
  use_cache = TRUE,
  force_refresh = FALSE,
  n_workers = 1L
)

# 2) Filter universe to same subset
univ_small <- univ[symbol %in% syms_small]

# 3) Build adjusted panel
res <- af2_build_panel_adj(
  universe_raw = univ_small,
  corp_actions = ca,
  manual_events = NULL,
  cfg = cfg,
  verbose = TRUE
)

panel_adj <- res$panel_adj

# 4) Validate
af2_validate_panel_adj(panel_adj)

# 5) Show sample
print(utils::head(panel_adj, 20))

af2_log("AF2_SMOKE04:", "OK - adjuster smoke passed.")



###############################################################################
### FILE: scripts/05a_smoke_screener_real_small_window.R
###############################################################################
# v2/scripts/05a_smoke_screener_real_small_window.R
# End-to-end real-data smoke:
# Universe (rb3 daily) -> Corp actions (quantmod/Yahoo cached)
# -> Adjuster -> Screener
#
# Goal:
# - Prove the full v2 spine works on a small real window + sampled symbols
# - Avoid Yahoo hammering via Module 03 cache
# - Surface any contract mismatches early

# ----------------------------
# 00) Core
# ----------------------------
source("v2/modules/00_core/R/utils.R")
source("v2/modules/00_core/R/config.R")
source("v2/modules/00_core/R/logging.R")

cfg <- af2_get_config()

af2_log_cfg(cfg)

# ----------------------------
# 01) Universe (rb3)
# ----------------------------
source("v2/modules/01_b3_universe/R/zzz_depends.R")
source("v2/modules/01_b3_universe/R/rb3_init.R")
source("v2/modules/01_b3_universe/R/validate_types.R")
source("v2/modules/01_b3_universe/R/select_min_cols.R")
source("v2/modules/01_b3_universe/R/unify_liquidity.R")
source("v2/modules/01_b3_universe/R/filter_by_type_rb3.R")
source("v2/modules/01_b3_universe/R/fetch_yearly.R")
source("v2/modules/01_b3_universe/R/fetch_daily.R")
source("v2/modules/01_b3_universe/R/build_universe.R")

types_all <- c("equity", "fii", "etf", "bdr")

end_date   <- Sys.Date() - 1
start_date <- end_date - 730  # ~2y for faster smoke

af2_log("AF2_SMOKE05:", "Universe window ", as.character(start_date), " to ", as.character(end_date))

dt_univ <- af2_b3_build_universe_window(
  start_date = start_date,
  end_date   = end_date,
  include_types = types_all,
  cfg = cfg,
  verbose = TRUE,
  use_cache = TRUE
)

af2_log("AF2_SMOKE05:", "Universe rows=", nrow(dt_univ),
        " symbols=", length(unique(dt_univ$symbol)))

# ----------------------------
# 02) Sample symbols
# ----------------------------
set.seed(42)
sample_n <- 50L

all_syms <- unique(dt_univ$symbol)
syms_smoke <- if (length(all_syms) > sample_n) sample(all_syms, sample_n) else all_syms

dt_univ_smoke <- dt_univ[symbol %in% syms_smoke]

af2_log("AF2_SMOKE05:", "Sampled symbols=", length(syms_smoke),
        " sampled rows=", nrow(dt_univ_smoke))

# ----------------------------
# 03) Corporate actions (quantmod/Yahoo)
# ----------------------------
source("v2/modules/03_corporate_actions/R/zzz_depends.R")
source("v2/modules/03_corporate_actions/R/yahoo_symbol_map.R")
source("v2/modules/03_corporate_actions/R/fetch_splits_quantmod.R")
source("v2/modules/03_corporate_actions/R/fetch_dividends_quantmod.R")
source("v2/modules/03_corporate_actions/R/build_registry.R")

from_ca <- as.Date("2018-01-01")
to_ca   <- Sys.Date()

# keep conservative parallel for Windows; adjust if you want
n_workers <- 2L

af2_log("AF2_SMOKE05:", "Building corp-actions registry for ", length(syms_smoke), " symbols")

registry <- af2_ca_build_registry(
  symbols = syms_smoke,
  cfg = cfg,
  from = from_ca,
  to = to_ca,
  verbose = TRUE,
  use_cache = TRUE,
  force_refresh = FALSE,
  n_workers = n_workers
)

af2_log("AF2_SMOKE05:", "Registry rows=", nrow(registry),
        " symbols with actions=", length(unique(registry$symbol)))

# ----------------------------
# 04) Adjuster (Module 04)
# ----------------------------
source("v2/modules/04_adjuster/R/zzz_depends.R")
source("v2/modules/04_adjuster/R/build_adjustments.R")
source("v2/modules/04_adjuster/R/apply_adjustments.R")
source("v2/modules/04_adjuster/R/build_panel_adj.R")
source("v2/modules/04_adjuster/R/validate_panel_adj.R")

res_adj <- af2_build_panel_adj(
  universe_raw = dt_univ_smoke,
  corp_actions = registry,
  manual_events = NULL,
  cfg = cfg,
  verbose = TRUE
)

panel_adj <- res_adj$panel_adj

af2_validate_panel_adj(panel_adj)

af2_log("AF2_SMOKE05:", "panel_adj rows=", nrow(panel_adj),
        " symbols=", length(unique(panel_adj$symbol)))

# ----------------------------
# 05) Screener (real data)
# ----------------------------
source("v2/modules/05_screener/R/screener_config.R")
source("v2/modules/05_screener/R/validate_screener_input.R")
source("v2/modules/05_screener/R/liquidity_filter.R")
source("v2/modules/05_screener/R/compute_metrics.R")
source("v2/modules/05_screener/R/score_rank.R")
source("v2/modules/05_screener/R/run_screener.R")

af2_log("AF2_SMOKE05:", "Running real-data screener (allow_unresolved=TRUE for smoke).")

res <- af2_run_screener(
  panel_adj,
  config = list(
    lookback_days = 80L,
    horizons_days = c(21L, 63L)
  ),
  allow_unresolved = TRUE
)

af2_log("AF2_SMOKE05:", "by_type integrity check:")
print(lapply(res$by_type, function(x) unique(x$asset_type)))

af2_log("AF2_SMOKE05:", "Top 10 overall:")
print(utils::head(res$full, 10))

af2_log("AF2_SMOKE05:", "Top 5 by type:")
for (tp in names(res$by_type)) {
  af2_log("AF2_SMOKE05:", "Type=", tp)
  print(utils::head(res$by_type[[tp]], 5))
}

af2_log("AF2_SMOKE05:", "OK - real-data screener smoke passed.")



###############################################################################
### FILE: scripts/05b_hard_screener_full_selective.R
###############################################################################
# v2/scripts/05b_hard_screener_full_selective.R
# Full-B3-ish hard test WITH the selective Yahoo "trick".
# Expectation:
# - Universe may have ~2000+ symbols
# - Yahoo fetch should be a small fraction (candidates)
# - Per-symbol caching can be enabled

# ----------------------------
# 00) Core
# ----------------------------
source("v2/modules/00_core/R/utils.R")
source("v2/modules/00_core/R/config.R")
source("v2/modules/00_core/R/logging.R")

cfg <- af2_get_config(list(
  # Turn on the real architecture knobs here
  enable_selective_actions = TRUE,

  # Strongly recommended for the hard run:
  ca_cache_mode = "by_symbol",

  # You can tighten/loosen these as you learn
  ca_prefilter_top_n_overall = 200L,
  ca_prefilter_top_n_by_type = 50L,
  ca_prefilter_max_candidates = 300L
))

af2_log_cfg(cfg)

# ----------------------------
# 01) Universe (rb3)
# ----------------------------
source("v2/modules/01_b3_universe/R/zzz_depends.R")
source("v2/modules/01_b3_universe/R/rb3_init.R")
source("v2/modules/01_b3_universe/R/validate_types.R")
source("v2/modules/01_b3_universe/R/select_min_cols.R")
source("v2/modules/01_b3_universe/R/unify_liquidity.R")
source("v2/modules/01_b3_universe/R/filter_by_type_rb3.R")
source("v2/modules/01_b3_universe/R/fetch_daily.R")
source("v2/modules/01_b3_universe/R/build_universe.R")

types_all <- c("equity", "fii", "etf", "bdr")

end_date   <- Sys.Date() - 1
start_date <- end_date - 730

af2_log("AF2_HARD05:", "Universe window ", as.character(start_date), " to ", as.character(end_date))

dt_univ <- af2_b3_build_universe_window(
  start_date = start_date,
  end_date   = end_date,
  include_types = types_all,
  cfg = cfg,
  verbose = TRUE,
  use_cache = TRUE
)

af2_log("AF2_HARD05:", "Universe rows=", nrow(dt_univ),
        " symbols=", length(unique(dt_univ$symbol)))

# ----------------------------
# 02) Corporate actions + Adjuster (selective wrapper)
# ----------------------------
source("v2/modules/03_corporate_actions/R/zzz_depends.R")
source("v2/modules/03_corporate_actions/R/yahoo_symbol_map.R")
source("v2/modules/03_corporate_actions/R/fetch_splits_quantmod.R")
source("v2/modules/03_corporate_actions/R/fetch_dividends_quantmod.R")
source("v2/modules/03_corporate_actions/R/build_registry.R")
source("v2/modules/03_corporate_actions/R/select_candidates.R")

source("v2/modules/04_adjuster/R/zzz_depends.R")
source("v2/modules/04_adjuster/R/build_adjustments.R")
source("v2/modules/04_adjuster/R/apply_adjustments.R")
source("v2/modules/04_adjuster/R/build_panel_adj.R")
source("v2/modules/04_adjuster/R/build_panel_adj_selective.R")
source("v2/modules/04_adjuster/R/validate_panel_adj.R")

af2_log("AF2_HARD05:", "Building adjusted panel with selective Yahoo registry...")

res_adj <- af2_build_panel_adj_selective(
  universe_raw = dt_univ,
  manual_events = NULL,
  cfg = cfg,
  from_ca = "2018-01-01",
  to_ca   = Sys.Date(),
  verbose = TRUE,
  use_cache = TRUE,
  force_refresh = FALSE,
  n_workers = 1L
)

panel_adj <- res_adj$panel_adj
af2_validate_panel_adj(panel_adj)

af2_log("AF2_HARD05:", "panel_adj rows=", nrow(panel_adj),
        " symbols=", length(unique(panel_adj$symbol)))

# ----------------------------
# 03) Screener
# ----------------------------
source("v2/modules/05_screener/R/screener_config.R")
source("v2/modules/05_screener/R/validate_screener_input.R")
source("v2/modules/05_screener/R/liquidity_filter.R")
source("v2/modules/05_screener/R/compute_metrics.R")
source("v2/modules/05_screener/R/score_rank.R")
source("v2/modules/05_screener/R/run_screener.R")

af2_log("AF2_HARD05:", "Running screener on full adjusted panel...")

res <- af2_run_screener(
  panel_adj,
  config = list(
    lookback_days = 252L,
    horizons_days = c(21L, 63L, 126L, 252L)
  ),
  allow_unresolved = NULL
)

af2_log("AF2_HARD05:", "Top 20 overall:")
print(utils::head(res$full, 20))

af2_log("AF2_HARD05:", "OK - hard selective full run finished.")



